{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"OCCWL Wrapper Library (occwl)","text":"<p>\u2192 API Documentation</p> <p>\u2192 Developer's Guide</p>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#occwl.base","title":"<code>base</code>","text":""},{"location":"api/#occwl.base.BottomUpEdgeIterator","title":"<code>BottomUpEdgeIterator</code>","text":"<p>A mixin class that adds the ability to iterate over edges from lower-level entities (vertices).</p> Source code in <code>src/occwl/base.py</code> <pre><code>class BottomUpEdgeIterator:\n    \"\"\"\n    A mixin class that adds the ability to iterate over edges from lower-level entities\n    (vertices).\n    \"\"\"\n    def edge_continuity(self, edge):\n        \"\"\"\n        Get the neighboring faces' continuity at given edge\n\n        Args:\n            edge (occwl.edge.Edge): Edge\n\n        Returns:\n            GeomAbs_Shape: enum describing the continuity order\n        \"\"\"\n        faces = list(self.faces_from_edge(edge))\n        # Handle seam edges which only have one face around them\n        if len(faces) == 1:\n            faces.append(faces[-1])\n        return edge.continuity(faces[0], faces[1])\n\n    def edges_from_vertex(self, vertex):\n        \"\"\"\n        Get an iterator to go over the edges adjacent to a vertex\n\n        Args:\n            face (occwl.face.Face): Input face\n\n        Returns:\n            Iterator[occwl.edge.Edge]: Edge iterator\n        \"\"\"\n        from occwl.vertex import Vertex\n        from occwl.edge import Edge\n        assert isinstance(vertex, Vertex)\n        return map(Edge, self._top_exp.edges_from_vertex(vertex.topods_shape()))\n</code></pre>"},{"location":"api/#occwl.base.BottomUpEdgeIterator.edge_continuity","title":"<code>edge_continuity(edge)</code>","text":"<p>Get the neighboring faces' continuity at given edge</p> <p>Parameters:</p> Name Type Description Default <code>edge</code> <code>Edge</code> <p>Edge</p> required <p>Returns:</p> Name Type Description <code>GeomAbs_Shape</code> <p>enum describing the continuity order</p> Source code in <code>src/occwl/base.py</code> <pre><code>def edge_continuity(self, edge):\n    \"\"\"\n    Get the neighboring faces' continuity at given edge\n\n    Args:\n        edge (occwl.edge.Edge): Edge\n\n    Returns:\n        GeomAbs_Shape: enum describing the continuity order\n    \"\"\"\n    faces = list(self.faces_from_edge(edge))\n    # Handle seam edges which only have one face around them\n    if len(faces) == 1:\n        faces.append(faces[-1])\n    return edge.continuity(faces[0], faces[1])\n</code></pre>"},{"location":"api/#occwl.base.BottomUpEdgeIterator.edges_from_vertex","title":"<code>edges_from_vertex(vertex)</code>","text":"<p>Get an iterator to go over the edges adjacent to a vertex</p> <p>Parameters:</p> Name Type Description Default <code>face</code> <code>Face</code> <p>Input face</p> required <p>Returns:</p> Type Description <p>Iterator[occwl.edge.Edge]: Edge iterator</p> Source code in <code>src/occwl/base.py</code> <pre><code>def edges_from_vertex(self, vertex):\n    \"\"\"\n    Get an iterator to go over the edges adjacent to a vertex\n\n    Args:\n        face (occwl.face.Face): Input face\n\n    Returns:\n        Iterator[occwl.edge.Edge]: Edge iterator\n    \"\"\"\n    from occwl.vertex import Vertex\n    from occwl.edge import Edge\n    assert isinstance(vertex, Vertex)\n    return map(Edge, self._top_exp.edges_from_vertex(vertex.topods_shape()))\n</code></pre>"},{"location":"api/#occwl.base.BottomUpFaceIterator","title":"<code>BottomUpFaceIterator</code>","text":"<p>A mixin class that adds the ability to iterate over faces from lower-level entities (vertices and edges).</p> Source code in <code>src/occwl/base.py</code> <pre><code>class BottomUpFaceIterator:\n    \"\"\"\n    A mixin class that adds the ability to iterate over faces from lower-level entities\n    (vertices and edges).\n    \"\"\"\n    def faces_from_edge(self, edge):\n        \"\"\"\n        Get an iterator to go over the faces adjacent to an edge\n\n        Args:\n            edge (occwl.edge.Edge): Input edge\n\n        Returns:\n            Iterator[occwl.face.Face]: Face iterator\n        \"\"\"\n        from occwl.edge import Edge\n        from occwl.face import Face\n        assert isinstance(edge, Edge)\n        return map(Face, self._top_exp.faces_from_edge(edge.topods_shape()))\n\n    def faces_from_vertex(self, vertex):\n        \"\"\"\n        Get an iterator to go over the faces adjacent to a vertex\n\n        Args:\n            edge (occwl.vertex.Vertex): Input vertex\n\n        Returns:\n            Iterator[occwl.face.Face]: Face iterator\n        \"\"\"\n        from occwl.vertex import Vertex\n        from occwl.face import Face\n        assert isinstance(vertex, Vertex)\n        return map(Face, self._top_exp.faces_from_vertex(vertex.topods_shape()))\n\n    def edge_continuity(self, edge):\n        \"\"\"\n        Get the neighboring faces' continuity at given edge\n\n        Args:\n            edge (occwl.edge.Edge): Edge\n\n        Returns:\n            GeomAbs_Shape: enum describing the continuity order\n        \"\"\"\n        faces = list(self.faces_from_edge(edge))\n        # Handle seam edges which only have one face around them\n        if len(faces) == 1:\n            faces.append(faces[-1])\n        return edge.continuity(faces[0], faces[1])\n</code></pre>"},{"location":"api/#occwl.base.BottomUpFaceIterator.edge_continuity","title":"<code>edge_continuity(edge)</code>","text":"<p>Get the neighboring faces' continuity at given edge</p> <p>Parameters:</p> Name Type Description Default <code>edge</code> <code>Edge</code> <p>Edge</p> required <p>Returns:</p> Name Type Description <code>GeomAbs_Shape</code> <p>enum describing the continuity order</p> Source code in <code>src/occwl/base.py</code> <pre><code>def edge_continuity(self, edge):\n    \"\"\"\n    Get the neighboring faces' continuity at given edge\n\n    Args:\n        edge (occwl.edge.Edge): Edge\n\n    Returns:\n        GeomAbs_Shape: enum describing the continuity order\n    \"\"\"\n    faces = list(self.faces_from_edge(edge))\n    # Handle seam edges which only have one face around them\n    if len(faces) == 1:\n        faces.append(faces[-1])\n    return edge.continuity(faces[0], faces[1])\n</code></pre>"},{"location":"api/#occwl.base.BottomUpFaceIterator.faces_from_edge","title":"<code>faces_from_edge(edge)</code>","text":"<p>Get an iterator to go over the faces adjacent to an edge</p> <p>Parameters:</p> Name Type Description Default <code>edge</code> <code>Edge</code> <p>Input edge</p> required <p>Returns:</p> Type Description <p>Iterator[occwl.face.Face]: Face iterator</p> Source code in <code>src/occwl/base.py</code> <pre><code>def faces_from_edge(self, edge):\n    \"\"\"\n    Get an iterator to go over the faces adjacent to an edge\n\n    Args:\n        edge (occwl.edge.Edge): Input edge\n\n    Returns:\n        Iterator[occwl.face.Face]: Face iterator\n    \"\"\"\n    from occwl.edge import Edge\n    from occwl.face import Face\n    assert isinstance(edge, Edge)\n    return map(Face, self._top_exp.faces_from_edge(edge.topods_shape()))\n</code></pre>"},{"location":"api/#occwl.base.BottomUpFaceIterator.faces_from_vertex","title":"<code>faces_from_vertex(vertex)</code>","text":"<p>Get an iterator to go over the faces adjacent to a vertex</p> <p>Parameters:</p> Name Type Description Default <code>edge</code> <code>Vertex</code> <p>Input vertex</p> required <p>Returns:</p> Type Description <p>Iterator[occwl.face.Face]: Face iterator</p> Source code in <code>src/occwl/base.py</code> <pre><code>def faces_from_vertex(self, vertex):\n    \"\"\"\n    Get an iterator to go over the faces adjacent to a vertex\n\n    Args:\n        edge (occwl.vertex.Vertex): Input vertex\n\n    Returns:\n        Iterator[occwl.face.Face]: Face iterator\n    \"\"\"\n    from occwl.vertex import Vertex\n    from occwl.face import Face\n    assert isinstance(vertex, Vertex)\n    return map(Face, self._top_exp.faces_from_vertex(vertex.topods_shape()))\n</code></pre>"},{"location":"api/#occwl.base.BoundingBoxMixin","title":"<code>BoundingBoxMixin</code>","text":"<p>A mixin class that adds the ability to compute approximate and exact bounding box of the Shape.</p> Source code in <code>src/occwl/base.py</code> <pre><code>class BoundingBoxMixin:\n    \"\"\"\n    A mixin class that adds the ability to compute approximate and exact bounding box\n    of the Shape.\n    \"\"\"\n    def box(self):\n        \"\"\"\n        Get a quick bounding box of the Shape\n\n        Returns:\n            Box: Bounding box\n        \"\"\"\n        from occwl.geometry import geom_utils\n        b = Bnd_Box()\n        brepbndlib_Add(self.topods_shape(), b)\n        return geom_utils.box_to_geometry(b)\n\n    def exact_box(self, use_shapetolerance=False):\n        \"\"\"\n        Get a slow, but accurate box for the Shape.\n\n        Args:\n            use_shapetolerance (bool, optional) Include the tolerance of edges\n                                                and vertices in the box.\n\n        Returns:\n            Box: Bounding box\n        \"\"\"\n        from occwl.geometry import geom_utils\n        b = Bnd_Box()\n        use_triangulation = True\n        brepbndlib_AddOptimal(self.topods_shape(), b, use_triangulation, use_shapetolerance)\n        return geom_utils.box_to_geometry(b)\n\n    def scale_to_box(self, box_side, copy=True):\n        \"\"\"\n        Translate and scale the Shape so it fits exactly \n        into the [-box_side, box_side]^3 box\n\n        Args:\n            box_side (float) The side length of the box\n            copy (bool)      True - Copy entities and apply the transform to\n                                    the underlying geometry\n                             False - Apply the transform to the topods Locator\n                                     if possible \n\n        Returns:\n            occwl.*.*: The scaled version of this Shape\n        \"\"\"\n        from occwl.geometry import geom_utils\n        # Get an exact box for the Shape\n        box = self.exact_box()\n        center = box.center()\n        longest_length = box.max_box_length()\n\n        orig = gp_Pnt(0.0, 0.0, 0.0)\n        center = geom_utils.numpy_to_gp(center)\n        vec_center_to_orig = gp_Vec(center, orig)\n        move_to_center = gp_Trsf()\n        move_to_center.SetTranslation(vec_center_to_orig)\n\n        scale_trsf = gp_Trsf()\n        scale_trsf.SetScale(orig, (2.0 * box_side) / longest_length)\n        trsf_to_apply = scale_trsf.Multiplied(move_to_center)\n\n        return self._apply_transform(trsf_to_apply, copy=copy)\n\n\n    def scale_to_unit_box(self, copy=True):\n        \"\"\"\n        Translate and scale the Shape so it fits exactly \n        into the [-1, 1]^3 box\n\n        Args:\n            copy (bool)      True - Copy entities and apply the transform to\n                                        the underlying geometry\n                                False - Apply the transform to the topods Locator\n                                        if possible \n        Returns:\n            The scaled version of this shape\n        \"\"\"\n        return self.scale_to_box(1.0, copy=copy)\n</code></pre>"},{"location":"api/#occwl.base.BoundingBoxMixin.box","title":"<code>box()</code>","text":"<p>Get a quick bounding box of the Shape</p> <p>Returns:</p> Name Type Description <code>Box</code> <p>Bounding box</p> Source code in <code>src/occwl/base.py</code> <pre><code>def box(self):\n    \"\"\"\n    Get a quick bounding box of the Shape\n\n    Returns:\n        Box: Bounding box\n    \"\"\"\n    from occwl.geometry import geom_utils\n    b = Bnd_Box()\n    brepbndlib_Add(self.topods_shape(), b)\n    return geom_utils.box_to_geometry(b)\n</code></pre>"},{"location":"api/#occwl.base.BoundingBoxMixin.exact_box","title":"<code>exact_box(use_shapetolerance=False)</code>","text":"<p>Get a slow, but accurate box for the Shape.</p> <p>Returns:</p> Name Type Description <code>Box</code> <p>Bounding box</p> Source code in <code>src/occwl/base.py</code> <pre><code>def exact_box(self, use_shapetolerance=False):\n    \"\"\"\n    Get a slow, but accurate box for the Shape.\n\n    Args:\n        use_shapetolerance (bool, optional) Include the tolerance of edges\n                                            and vertices in the box.\n\n    Returns:\n        Box: Bounding box\n    \"\"\"\n    from occwl.geometry import geom_utils\n    b = Bnd_Box()\n    use_triangulation = True\n    brepbndlib_AddOptimal(self.topods_shape(), b, use_triangulation, use_shapetolerance)\n    return geom_utils.box_to_geometry(b)\n</code></pre>"},{"location":"api/#occwl.base.BoundingBoxMixin.scale_to_box","title":"<code>scale_to_box(box_side, copy=True)</code>","text":"<p>Translate and scale the Shape so it fits exactly  into the [-box_side, box_side]^3 box</p> <p>Returns:</p> Type Description <p>occwl..: The scaled version of this Shape</p> Source code in <code>src/occwl/base.py</code> <pre><code>def scale_to_box(self, box_side, copy=True):\n    \"\"\"\n    Translate and scale the Shape so it fits exactly \n    into the [-box_side, box_side]^3 box\n\n    Args:\n        box_side (float) The side length of the box\n        copy (bool)      True - Copy entities and apply the transform to\n                                the underlying geometry\n                         False - Apply the transform to the topods Locator\n                                 if possible \n\n    Returns:\n        occwl.*.*: The scaled version of this Shape\n    \"\"\"\n    from occwl.geometry import geom_utils\n    # Get an exact box for the Shape\n    box = self.exact_box()\n    center = box.center()\n    longest_length = box.max_box_length()\n\n    orig = gp_Pnt(0.0, 0.0, 0.0)\n    center = geom_utils.numpy_to_gp(center)\n    vec_center_to_orig = gp_Vec(center, orig)\n    move_to_center = gp_Trsf()\n    move_to_center.SetTranslation(vec_center_to_orig)\n\n    scale_trsf = gp_Trsf()\n    scale_trsf.SetScale(orig, (2.0 * box_side) / longest_length)\n    trsf_to_apply = scale_trsf.Multiplied(move_to_center)\n\n    return self._apply_transform(trsf_to_apply, copy=copy)\n</code></pre>"},{"location":"api/#occwl.base.BoundingBoxMixin.scale_to_unit_box","title":"<code>scale_to_unit_box(copy=True)</code>","text":"<p>Translate and scale the Shape so it fits exactly  into the [-1, 1]^3 box</p> <p>Returns:     The scaled version of this shape</p> Source code in <code>src/occwl/base.py</code> <pre><code>def scale_to_unit_box(self, copy=True):\n    \"\"\"\n    Translate and scale the Shape so it fits exactly \n    into the [-1, 1]^3 box\n\n    Args:\n        copy (bool)      True - Copy entities and apply the transform to\n                                    the underlying geometry\n                            False - Apply the transform to the topods Locator\n                                    if possible \n    Returns:\n        The scaled version of this shape\n    \"\"\"\n    return self.scale_to_box(1.0, copy=copy)\n</code></pre>"},{"location":"api/#occwl.base.EdgeContainerMixin","title":"<code>EdgeContainerMixin</code>","text":"<p>A mixin class that adds the ability to perform operations on the edges in the shape</p> Source code in <code>src/occwl/base.py</code> <pre><code>class EdgeContainerMixin:\n    \"\"\"\n    A mixin class that adds the ability to perform operations on the edges\n    in the shape\n    \"\"\"\n    def num_edges(self):\n        \"\"\"\n        Number of edges in the Shape\n\n        Returns:\n            int: Number of edges\n        \"\"\"\n        return self._top_exp.number_of_edges()\n\n    def edges(self):\n        \"\"\"\n        Get an iterator to go over all edges in the Shape\n\n        Returns:\n            Iterator[occwl.edge.Edge]: Edge iterator\n        \"\"\"\n        from occwl.edge import Edge\n        return map(Edge, self._top_exp.edges())\n\n    def vertices_from_edge(self, edge):\n        \"\"\"\n        Get an iterator to go over the vertices bounding an edge\n\n        Args:\n            edge (occwl.edge.Edge): Input edge\n\n        Returns:\n            Iterator[occwl.vertex.Vertex]: Vertex iterator\n        \"\"\"\n        from occwl.vertex import Vertex\n        from occwl.edge import Edge\n        assert isinstance(edge, Edge)\n        return map(Vertex, self._top_exp.vertices_from_edge(edge.topods_shape()))\n\n    def find_closest_edge_slow(self, datum):\n        \"\"\"\n        Find the closest edge to the given datum point.\n        The function is for testing only.  It will be slow \n        as it loops over all edges in the Shape.\n        A quick way to find the closest entity is to call\n        Shape.find_closest_point_data(), but then you\n        may get a face, edge or vertex back.\n\n        Args:\n            datum (np.ndarray or tuple): 3D datum point\n\n        Returns:\n            Face: The closest face in the Shape\n        \"\"\"\n        return _find_closest_shape_in_list(self.edges(), datum)\n\n    def split_all_closed_edges(self, max_tol=0.01, precision=0.01, num_splits=1):\n        \"\"\"\n        Split all the closed edges in this shape\n\n        Args:\n            max_tol (float, optional): Maximum tolerance allowed. Defaults to 0.01.\n            precision (float, optional): Precision of the tool when splitting. Defaults to 0.01.\n            num_splits (int, optional): Number of splits to perform. Each split edge will result in num_splits + 1 edges. Defaults to 1.\n\n        Returns:\n            occwl.*.*: Shape with closed edges split\n        \"\"\"\n        divider = ShapeUpgrade_ShapeDivideClosedEdges(self.topods_shape())\n        divider.SetPrecision(precision)\n        divider.SetMinTolerance(0.1 * max_tol)\n        divider.SetMaxTolerance(max_tol)\n        divider.SetNbSplitPoints(num_splits)\n        ok = divider.Perform()\n        if not ok:\n            # Splitting failed or there were no closed edges to split\n            # Return the original shape\n            return self\n        return type(self)(divider.Result())\n</code></pre>"},{"location":"api/#occwl.base.EdgeContainerMixin.edges","title":"<code>edges()</code>","text":"<p>Get an iterator to go over all edges in the Shape</p> <p>Returns:</p> Type Description <p>Iterator[occwl.edge.Edge]: Edge iterator</p> Source code in <code>src/occwl/base.py</code> <pre><code>def edges(self):\n    \"\"\"\n    Get an iterator to go over all edges in the Shape\n\n    Returns:\n        Iterator[occwl.edge.Edge]: Edge iterator\n    \"\"\"\n    from occwl.edge import Edge\n    return map(Edge, self._top_exp.edges())\n</code></pre>"},{"location":"api/#occwl.base.EdgeContainerMixin.find_closest_edge_slow","title":"<code>find_closest_edge_slow(datum)</code>","text":"<p>Find the closest edge to the given datum point. The function is for testing only.  It will be slow  as it loops over all edges in the Shape. A quick way to find the closest entity is to call Shape.find_closest_point_data(), but then you may get a face, edge or vertex back.</p> <p>Parameters:</p> Name Type Description Default <code>datum</code> <code>ndarray or tuple</code> <p>3D datum point</p> required <p>Returns:</p> Name Type Description <code>Face</code> <p>The closest face in the Shape</p> Source code in <code>src/occwl/base.py</code> <pre><code>def find_closest_edge_slow(self, datum):\n    \"\"\"\n    Find the closest edge to the given datum point.\n    The function is for testing only.  It will be slow \n    as it loops over all edges in the Shape.\n    A quick way to find the closest entity is to call\n    Shape.find_closest_point_data(), but then you\n    may get a face, edge or vertex back.\n\n    Args:\n        datum (np.ndarray or tuple): 3D datum point\n\n    Returns:\n        Face: The closest face in the Shape\n    \"\"\"\n    return _find_closest_shape_in_list(self.edges(), datum)\n</code></pre>"},{"location":"api/#occwl.base.EdgeContainerMixin.num_edges","title":"<code>num_edges()</code>","text":"<p>Number of edges in the Shape</p> <p>Returns:</p> Name Type Description <code>int</code> <p>Number of edges</p> Source code in <code>src/occwl/base.py</code> <pre><code>def num_edges(self):\n    \"\"\"\n    Number of edges in the Shape\n\n    Returns:\n        int: Number of edges\n    \"\"\"\n    return self._top_exp.number_of_edges()\n</code></pre>"},{"location":"api/#occwl.base.EdgeContainerMixin.split_all_closed_edges","title":"<code>split_all_closed_edges(max_tol=0.01, precision=0.01, num_splits=1)</code>","text":"<p>Split all the closed edges in this shape</p> <p>Parameters:</p> Name Type Description Default <code>max_tol</code> <code>float</code> <p>Maximum tolerance allowed. Defaults to 0.01.</p> <code>0.01</code> <code>precision</code> <code>float</code> <p>Precision of the tool when splitting. Defaults to 0.01.</p> <code>0.01</code> <code>num_splits</code> <code>int</code> <p>Number of splits to perform. Each split edge will result in num_splits + 1 edges. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Type Description <p>occwl..: Shape with closed edges split</p> Source code in <code>src/occwl/base.py</code> <pre><code>def split_all_closed_edges(self, max_tol=0.01, precision=0.01, num_splits=1):\n    \"\"\"\n    Split all the closed edges in this shape\n\n    Args:\n        max_tol (float, optional): Maximum tolerance allowed. Defaults to 0.01.\n        precision (float, optional): Precision of the tool when splitting. Defaults to 0.01.\n        num_splits (int, optional): Number of splits to perform. Each split edge will result in num_splits + 1 edges. Defaults to 1.\n\n    Returns:\n        occwl.*.*: Shape with closed edges split\n    \"\"\"\n    divider = ShapeUpgrade_ShapeDivideClosedEdges(self.topods_shape())\n    divider.SetPrecision(precision)\n    divider.SetMinTolerance(0.1 * max_tol)\n    divider.SetMaxTolerance(max_tol)\n    divider.SetNbSplitPoints(num_splits)\n    ok = divider.Perform()\n    if not ok:\n        # Splitting failed or there were no closed edges to split\n        # Return the original shape\n        return self\n    return type(self)(divider.Result())\n</code></pre>"},{"location":"api/#occwl.base.EdgeContainerMixin.vertices_from_edge","title":"<code>vertices_from_edge(edge)</code>","text":"<p>Get an iterator to go over the vertices bounding an edge</p> <p>Parameters:</p> Name Type Description Default <code>edge</code> <code>Edge</code> <p>Input edge</p> required <p>Returns:</p> Type Description <p>Iterator[occwl.vertex.Vertex]: Vertex iterator</p> Source code in <code>src/occwl/base.py</code> <pre><code>def vertices_from_edge(self, edge):\n    \"\"\"\n    Get an iterator to go over the vertices bounding an edge\n\n    Args:\n        edge (occwl.edge.Edge): Input edge\n\n    Returns:\n        Iterator[occwl.vertex.Vertex]: Vertex iterator\n    \"\"\"\n    from occwl.vertex import Vertex\n    from occwl.edge import Edge\n    assert isinstance(edge, Edge)\n    return map(Vertex, self._top_exp.vertices_from_edge(edge.topods_shape()))\n</code></pre>"},{"location":"api/#occwl.base.FaceContainerMixin","title":"<code>FaceContainerMixin</code>","text":"<p>A mixin class that adds the ability to perform operations on the faces in the shape</p> Source code in <code>src/occwl/base.py</code> <pre><code>class FaceContainerMixin:\n    \"\"\"\n    A mixin class that adds the ability to perform operations on the faces\n    in the shape\n    \"\"\"\n    def num_faces(self):\n        \"\"\"\n        Number of faces in the Shape\n\n        Returns:\n            int: Number of faces\n        \"\"\"\n        return self._top_exp.number_of_faces()\n\n    def faces(self):\n        \"\"\"\n        Get an iterator to go over all faces in the Shape\n\n        Returns:\n            Iterator[occwl.face.Face]: Face iterator\n        \"\"\"\n        from occwl.face import Face\n        return map(Face, self._top_exp.faces())\n\n    def vertices_from_face(self, face):\n        \"\"\"\n        Get an iterator to go over the vertices in a face\n\n        Args:\n            face (occwl.face.Face): Input face\n\n        Returns:\n            Iterator[occwl.vertex.Vertex]: Vertex iterator\n        \"\"\"\n        from occwl.vertex import Vertex\n        from occwl.face import Face\n        assert isinstance(face, Face)\n        return map(Vertex, self._top_exp.vertices_from_face(face.topods_shape()))\n\n    def edges_from_face(self, face):\n        \"\"\"\n        Get an iterator to go over the edges in a face\n\n        Args:\n            face (occwl.face.Face): Input face\n\n        Returns:\n            Iterator[occwl.edge.Edge]: Edge iterator\n        \"\"\"\n        from occwl.edge import Edge\n        from occwl.face import Face\n        assert isinstance(face, Face)\n        return map(Edge, self._top_exp.edges_from_face(face.topods_shape()))\n\n    def wires_from_face(self, face):\n        \"\"\"\n        Get an iterator to go over the wires bounding a face\n\n        Args:\n            face (occwl.face.Face): Input face\n\n        Returns:\n            Iterator[occwl.wire.Wire]: Wire iterator\n        \"\"\"\n        from occwl.wire import Wire\n        from occwl.face import Face\n        assert isinstance(face, Face)\n        return map(Wire, self._top_exp.wires_from_face(face.topods_shape()))\n\n    def find_closest_face_slow(self, datum):\n        \"\"\"\n        Find the closest face to the given datum point.\n        The function is for testing only. It will be slow \n        as it loops over all faces in the Shape.\n        A quick way to find the closest entity is to call\n        Shape.find_closest_point_data(), but then you\n        may get a face, edge or vertex back.\n\n        Args:\n            datum (np.ndarray or tuple): 3D datum point\n\n        Returns:\n            Face: The closest face in the Shape\n        \"\"\"\n        return _find_closest_shape_in_list(self.faces(), datum)\n\n    def split_all_closed_faces(self, max_tol=0.01, precision=0.01, num_splits=1):\n        \"\"\"\n        Split all the closed faces in this shape\n\n        Args:\n            max_tol (float, optional): Maximum tolerance allowed. Defaults to 0.01.\n            precision (float, optional): Precision of the tool when splitting. Defaults to 0.01.\n            num_splits (int, optional): Number of splits to perform. Each split face will result in num_splits + 1 faces. Defaults to 1.\n\n        Returns:\n            occwl.*.*: Shape with closed faces split\n        \"\"\"\n        divider = ShapeUpgrade_ShapeDivideClosed(self.topods_shape())\n        divider.SetPrecision(precision)\n        divider.SetMinTolerance(0.1 * max_tol)\n        divider.SetMaxTolerance(max_tol)\n        divider.SetNbSplitPoints(num_splits)\n        ok = divider.Perform()\n        if not ok:\n            # Splitting failed or there were no closed faces to split\n            # Return the original shape\n            return self\n        return type(self)(divider.Result())\n</code></pre>"},{"location":"api/#occwl.base.FaceContainerMixin.edges_from_face","title":"<code>edges_from_face(face)</code>","text":"<p>Get an iterator to go over the edges in a face</p> <p>Parameters:</p> Name Type Description Default <code>face</code> <code>Face</code> <p>Input face</p> required <p>Returns:</p> Type Description <p>Iterator[occwl.edge.Edge]: Edge iterator</p> Source code in <code>src/occwl/base.py</code> <pre><code>def edges_from_face(self, face):\n    \"\"\"\n    Get an iterator to go over the edges in a face\n\n    Args:\n        face (occwl.face.Face): Input face\n\n    Returns:\n        Iterator[occwl.edge.Edge]: Edge iterator\n    \"\"\"\n    from occwl.edge import Edge\n    from occwl.face import Face\n    assert isinstance(face, Face)\n    return map(Edge, self._top_exp.edges_from_face(face.topods_shape()))\n</code></pre>"},{"location":"api/#occwl.base.FaceContainerMixin.faces","title":"<code>faces()</code>","text":"<p>Get an iterator to go over all faces in the Shape</p> <p>Returns:</p> Type Description <p>Iterator[occwl.face.Face]: Face iterator</p> Source code in <code>src/occwl/base.py</code> <pre><code>def faces(self):\n    \"\"\"\n    Get an iterator to go over all faces in the Shape\n\n    Returns:\n        Iterator[occwl.face.Face]: Face iterator\n    \"\"\"\n    from occwl.face import Face\n    return map(Face, self._top_exp.faces())\n</code></pre>"},{"location":"api/#occwl.base.FaceContainerMixin.find_closest_face_slow","title":"<code>find_closest_face_slow(datum)</code>","text":"<p>Find the closest face to the given datum point. The function is for testing only. It will be slow  as it loops over all faces in the Shape. A quick way to find the closest entity is to call Shape.find_closest_point_data(), but then you may get a face, edge or vertex back.</p> <p>Parameters:</p> Name Type Description Default <code>datum</code> <code>ndarray or tuple</code> <p>3D datum point</p> required <p>Returns:</p> Name Type Description <code>Face</code> <p>The closest face in the Shape</p> Source code in <code>src/occwl/base.py</code> <pre><code>def find_closest_face_slow(self, datum):\n    \"\"\"\n    Find the closest face to the given datum point.\n    The function is for testing only. It will be slow \n    as it loops over all faces in the Shape.\n    A quick way to find the closest entity is to call\n    Shape.find_closest_point_data(), but then you\n    may get a face, edge or vertex back.\n\n    Args:\n        datum (np.ndarray or tuple): 3D datum point\n\n    Returns:\n        Face: The closest face in the Shape\n    \"\"\"\n    return _find_closest_shape_in_list(self.faces(), datum)\n</code></pre>"},{"location":"api/#occwl.base.FaceContainerMixin.num_faces","title":"<code>num_faces()</code>","text":"<p>Number of faces in the Shape</p> <p>Returns:</p> Name Type Description <code>int</code> <p>Number of faces</p> Source code in <code>src/occwl/base.py</code> <pre><code>def num_faces(self):\n    \"\"\"\n    Number of faces in the Shape\n\n    Returns:\n        int: Number of faces\n    \"\"\"\n    return self._top_exp.number_of_faces()\n</code></pre>"},{"location":"api/#occwl.base.FaceContainerMixin.split_all_closed_faces","title":"<code>split_all_closed_faces(max_tol=0.01, precision=0.01, num_splits=1)</code>","text":"<p>Split all the closed faces in this shape</p> <p>Parameters:</p> Name Type Description Default <code>max_tol</code> <code>float</code> <p>Maximum tolerance allowed. Defaults to 0.01.</p> <code>0.01</code> <code>precision</code> <code>float</code> <p>Precision of the tool when splitting. Defaults to 0.01.</p> <code>0.01</code> <code>num_splits</code> <code>int</code> <p>Number of splits to perform. Each split face will result in num_splits + 1 faces. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Type Description <p>occwl..: Shape with closed faces split</p> Source code in <code>src/occwl/base.py</code> <pre><code>def split_all_closed_faces(self, max_tol=0.01, precision=0.01, num_splits=1):\n    \"\"\"\n    Split all the closed faces in this shape\n\n    Args:\n        max_tol (float, optional): Maximum tolerance allowed. Defaults to 0.01.\n        precision (float, optional): Precision of the tool when splitting. Defaults to 0.01.\n        num_splits (int, optional): Number of splits to perform. Each split face will result in num_splits + 1 faces. Defaults to 1.\n\n    Returns:\n        occwl.*.*: Shape with closed faces split\n    \"\"\"\n    divider = ShapeUpgrade_ShapeDivideClosed(self.topods_shape())\n    divider.SetPrecision(precision)\n    divider.SetMinTolerance(0.1 * max_tol)\n    divider.SetMaxTolerance(max_tol)\n    divider.SetNbSplitPoints(num_splits)\n    ok = divider.Perform()\n    if not ok:\n        # Splitting failed or there were no closed faces to split\n        # Return the original shape\n        return self\n    return type(self)(divider.Result())\n</code></pre>"},{"location":"api/#occwl.base.FaceContainerMixin.vertices_from_face","title":"<code>vertices_from_face(face)</code>","text":"<p>Get an iterator to go over the vertices in a face</p> <p>Parameters:</p> Name Type Description Default <code>face</code> <code>Face</code> <p>Input face</p> required <p>Returns:</p> Type Description <p>Iterator[occwl.vertex.Vertex]: Vertex iterator</p> Source code in <code>src/occwl/base.py</code> <pre><code>def vertices_from_face(self, face):\n    \"\"\"\n    Get an iterator to go over the vertices in a face\n\n    Args:\n        face (occwl.face.Face): Input face\n\n    Returns:\n        Iterator[occwl.vertex.Vertex]: Vertex iterator\n    \"\"\"\n    from occwl.vertex import Vertex\n    from occwl.face import Face\n    assert isinstance(face, Face)\n    return map(Vertex, self._top_exp.vertices_from_face(face.topods_shape()))\n</code></pre>"},{"location":"api/#occwl.base.FaceContainerMixin.wires_from_face","title":"<code>wires_from_face(face)</code>","text":"<p>Get an iterator to go over the wires bounding a face</p> <p>Parameters:</p> Name Type Description Default <code>face</code> <code>Face</code> <p>Input face</p> required <p>Returns:</p> Type Description <p>Iterator[occwl.wire.Wire]: Wire iterator</p> Source code in <code>src/occwl/base.py</code> <pre><code>def wires_from_face(self, face):\n    \"\"\"\n    Get an iterator to go over the wires bounding a face\n\n    Args:\n        face (occwl.face.Face): Input face\n\n    Returns:\n        Iterator[occwl.wire.Wire]: Wire iterator\n    \"\"\"\n    from occwl.wire import Wire\n    from occwl.face import Face\n    assert isinstance(face, Face)\n    return map(Wire, self._top_exp.wires_from_face(face.topods_shape()))\n</code></pre>"},{"location":"api/#occwl.base.ShellContainerMixin","title":"<code>ShellContainerMixin</code>","text":"<p>A mixin class that adds the ability to perform operations on the shells in the shape</p> Source code in <code>src/occwl/base.py</code> <pre><code>class ShellContainerMixin:\n    \"\"\"\n    A mixin class that adds the ability to perform operations on the shells\n    in the shape\n    \"\"\"\n    def num_shells(self):\n        \"\"\"\n        Number of shells in the Shape\n\n        Returns:\n            int: Number of shells\n        \"\"\"\n        return self._top_exp.number_of_shells()\n\n    def shells(self):\n        \"\"\"\n        Get an iterator to go over all shells in the Shape\n\n        Returns:\n            Iterator[occwl.shell.Shell]: Shell iterator\n        \"\"\"\n        from occwl.shell import Shell\n        return map(Shell, self._top_exp.shells())\n</code></pre>"},{"location":"api/#occwl.base.ShellContainerMixin.num_shells","title":"<code>num_shells()</code>","text":"<p>Number of shells in the Shape</p> <p>Returns:</p> Name Type Description <code>int</code> <p>Number of shells</p> Source code in <code>src/occwl/base.py</code> <pre><code>def num_shells(self):\n    \"\"\"\n    Number of shells in the Shape\n\n    Returns:\n        int: Number of shells\n    \"\"\"\n    return self._top_exp.number_of_shells()\n</code></pre>"},{"location":"api/#occwl.base.ShellContainerMixin.shells","title":"<code>shells()</code>","text":"<p>Get an iterator to go over all shells in the Shape</p> <p>Returns:</p> Type Description <p>Iterator[occwl.shell.Shell]: Shell iterator</p> Source code in <code>src/occwl/base.py</code> <pre><code>def shells(self):\n    \"\"\"\n    Get an iterator to go over all shells in the Shape\n\n    Returns:\n        Iterator[occwl.shell.Shell]: Shell iterator\n    \"\"\"\n    from occwl.shell import Shell\n    return map(Shell, self._top_exp.shells())\n</code></pre>"},{"location":"api/#occwl.base.SolidContainerMixin","title":"<code>SolidContainerMixin</code>","text":"<p>A mixin class that adds the ability to perform operations on the solids in the shape</p> Source code in <code>src/occwl/base.py</code> <pre><code>class SolidContainerMixin:\n    \"\"\"\n    A mixin class that adds the ability to perform operations on the solids\n    in the shape\n    \"\"\"\n    def num_solids(self):\n        \"\"\"\n        Number of solids in the Compound\n\n        Returns:\n            int: Number of solids\n        \"\"\"\n        return self._top_exp.number_of_solids()\n\n    def solids(self):\n        \"\"\"\n        Get an iterator to go over all solids in the Compound\n\n        Returns:\n            Iterator[occwl.solid.Solid]: Solid iterator\n        \"\"\"\n        from occwl.solid import Solid\n        return map(Solid, self._top_exp.solids())\n</code></pre>"},{"location":"api/#occwl.base.SolidContainerMixin.num_solids","title":"<code>num_solids()</code>","text":"<p>Number of solids in the Compound</p> <p>Returns:</p> Name Type Description <code>int</code> <p>Number of solids</p> Source code in <code>src/occwl/base.py</code> <pre><code>def num_solids(self):\n    \"\"\"\n    Number of solids in the Compound\n\n    Returns:\n        int: Number of solids\n    \"\"\"\n    return self._top_exp.number_of_solids()\n</code></pre>"},{"location":"api/#occwl.base.SolidContainerMixin.solids","title":"<code>solids()</code>","text":"<p>Get an iterator to go over all solids in the Compound</p> <p>Returns:</p> Type Description <p>Iterator[occwl.solid.Solid]: Solid iterator</p> Source code in <code>src/occwl/base.py</code> <pre><code>def solids(self):\n    \"\"\"\n    Get an iterator to go over all solids in the Compound\n\n    Returns:\n        Iterator[occwl.solid.Solid]: Solid iterator\n    \"\"\"\n    from occwl.solid import Solid\n    return map(Solid, self._top_exp.solids())\n</code></pre>"},{"location":"api/#occwl.base.SurfacePropertiesMixin","title":"<code>SurfacePropertiesMixin</code>","text":"<p>A mixin class that adds the ability to query surface properties (e.g. area).</p> Source code in <code>src/occwl/base.py</code> <pre><code>class SurfacePropertiesMixin:\n    \"\"\"\n    A mixin class that adds the ability to query surface properties (e.g. area).\n    \"\"\"\n    def area(self):\n        \"\"\"\n        Compute the area of the Shape\n\n        Returns:\n            float: Area\n        \"\"\"\n        geometry_properties = GProp_GProps()\n        brepgprop_SurfaceProperties(self.topods_shape(), geometry_properties)\n        return geometry_properties.Mass()\n</code></pre>"},{"location":"api/#occwl.base.SurfacePropertiesMixin.area","title":"<code>area()</code>","text":"<p>Compute the area of the Shape</p> <p>Returns:</p> Name Type Description <code>float</code> <p>Area</p> Source code in <code>src/occwl/base.py</code> <pre><code>def area(self):\n    \"\"\"\n    Compute the area of the Shape\n\n    Returns:\n        float: Area\n    \"\"\"\n    geometry_properties = GProp_GProps()\n    brepgprop_SurfaceProperties(self.topods_shape(), geometry_properties)\n    return geometry_properties.Mass()\n</code></pre>"},{"location":"api/#occwl.base.TriangulatorMixin","title":"<code>TriangulatorMixin</code>","text":"<p>A mixin class that adds the ability to triangulate the faces that are present in the shape.</p> Source code in <code>src/occwl/base.py</code> <pre><code>class TriangulatorMixin:\n    \"\"\"\n    A mixin class that adds the ability to triangulate the faces that are present\n    in the shape.\n    \"\"\"\n    def triangulate_all_faces(\n        self,\n        triangle_face_tol=0.01,  # Tolerance between triangle and surface\n        tol_relative_to_face=True,  # The tolerance value is relative to the face size\n        angle_tol_rads=0.1,  # Angle between normals/tangents at triangle vertices\n    ):\n        return self.triangulate(\n            triangle_face_tol=triangle_face_tol,\n            tol_relative_to_face=tol_relative_to_face,\n            angle_tol_rads=angle_tol_rads,\n        )\n\n    def triangulate(\n        self,\n        triangle_face_tol=0.01,  # Tolerance between triangle and surface\n        tol_relative_to_face=True,  # The tolerance value is relative to the face size\n        angle_tol_rads=0.1,  # Angle between normals/tangents at triangle vertices\n    ):\n        \"\"\"\n        Triangulate all the faces in the shape. You can then get the triangles \n        from each face separately using face.get_triangles().\n        If you wanted triangles for the entire shape then call\n        shape.get_triangles() below.\n        For more details see \n        https://old.opencascade.com/doc/occt-7.1.0/overview/html/occt_user_guides__modeling_algos.html#occt_modalg_11\n\n        Args:\n            triangle_face_tol (float, optional): Tolerance between triangle and surface. Defaults to 0.01.\n            tol_relative_to_face (bool): Whether tolerance is relative to face size\n            angle_tol_rads (float, optional): Angle tolerance in radians. Defaults to 0.1.\n\n        Returns:\n            bool: Is successful\n        \"\"\"\n        mesh = BRepMesh_IncrementalMesh(\n            self.topods_shape(),\n            triangle_face_tol,\n            tol_relative_to_face,\n            angle_tol_rads,\n            True,\n        )\n        mesh.Perform()\n        return mesh.IsDone()\n\n    def get_triangles(\n        self,\n        triangle_face_tol=0.01,  # Tolerance between triangle and surface\n        tol_relative_to_face=True,  # The tolerance value is relative to the face size\n        angle_tol_rads=0.1,  # Angle between normals/tangents at triangle vertices\n    ):\n        \"\"\"\n        Compute and get the tessellation of the entire shape\n\n        Args:\n            triangle_face_tol (float, optional): Toelrance between triangle and surface. Defaults to 0.01.\n            tol_relative_to_face (bool): Whether tolerance is relative to face size\n            angle_tol_rads (float, optional): Angle tolerance in radians. Defaults to 0.1.\n\n        Returns:\n            2D np.ndarray (float): Vertices or None if triangulation failed\n            2D np.ndarray (int): Faces or None if triangulation failed\n        \"\"\"\n        ok = self.triangulate_all_faces(\n            triangle_face_tol, tol_relative_to_face, angle_tol_rads\n        )\n        if not ok:\n            # Failed to triangulate\n            return None, None\n        verts = []\n        tris = []\n        faces = self.faces()\n        last_vert_index = 0\n        for face in faces:\n            fverts, ftris = face.get_triangles()\n            verts.extend(fverts)\n            for tri in ftris:\n                new_indices = [index + last_vert_index for index in tri]\n                tris.append(new_indices)\n            last_vert_index = len(verts)\n        return np.asarray(verts, dtype=np.float32), np.asarray(tris, dtype=np.int32)\n</code></pre>"},{"location":"api/#occwl.base.TriangulatorMixin.get_triangles","title":"<code>get_triangles(triangle_face_tol=0.01, tol_relative_to_face=True, angle_tol_rads=0.1)</code>","text":"<p>Compute and get the tessellation of the entire shape</p> <p>Parameters:</p> Name Type Description Default <code>triangle_face_tol</code> <code>float</code> <p>Toelrance between triangle and surface. Defaults to 0.01.</p> <code>0.01</code> <code>tol_relative_to_face</code> <code>bool</code> <p>Whether tolerance is relative to face size</p> <code>True</code> <code>angle_tol_rads</code> <code>float</code> <p>Angle tolerance in radians. Defaults to 0.1.</p> <code>0.1</code> <p>Returns:</p> Type Description <p>2D np.ndarray (float): Vertices or None if triangulation failed</p> <p>2D np.ndarray (int): Faces or None if triangulation failed</p> Source code in <code>src/occwl/base.py</code> <pre><code>def get_triangles(\n    self,\n    triangle_face_tol=0.01,  # Tolerance between triangle and surface\n    tol_relative_to_face=True,  # The tolerance value is relative to the face size\n    angle_tol_rads=0.1,  # Angle between normals/tangents at triangle vertices\n):\n    \"\"\"\n    Compute and get the tessellation of the entire shape\n\n    Args:\n        triangle_face_tol (float, optional): Toelrance between triangle and surface. Defaults to 0.01.\n        tol_relative_to_face (bool): Whether tolerance is relative to face size\n        angle_tol_rads (float, optional): Angle tolerance in radians. Defaults to 0.1.\n\n    Returns:\n        2D np.ndarray (float): Vertices or None if triangulation failed\n        2D np.ndarray (int): Faces or None if triangulation failed\n    \"\"\"\n    ok = self.triangulate_all_faces(\n        triangle_face_tol, tol_relative_to_face, angle_tol_rads\n    )\n    if not ok:\n        # Failed to triangulate\n        return None, None\n    verts = []\n    tris = []\n    faces = self.faces()\n    last_vert_index = 0\n    for face in faces:\n        fverts, ftris = face.get_triangles()\n        verts.extend(fverts)\n        for tri in ftris:\n            new_indices = [index + last_vert_index for index in tri]\n            tris.append(new_indices)\n        last_vert_index = len(verts)\n    return np.asarray(verts, dtype=np.float32), np.asarray(tris, dtype=np.int32)\n</code></pre>"},{"location":"api/#occwl.base.TriangulatorMixin.triangulate","title":"<code>triangulate(triangle_face_tol=0.01, tol_relative_to_face=True, angle_tol_rads=0.1)</code>","text":"<p>Triangulate all the faces in the shape. You can then get the triangles  from each face separately using face.get_triangles(). If you wanted triangles for the entire shape then call shape.get_triangles() below. For more details see  https://old.opencascade.com/doc/occt-7.1.0/overview/html/occt_user_guides__modeling_algos.html#occt_modalg_11</p> <p>Parameters:</p> Name Type Description Default <code>triangle_face_tol</code> <code>float</code> <p>Tolerance between triangle and surface. Defaults to 0.01.</p> <code>0.01</code> <code>tol_relative_to_face</code> <code>bool</code> <p>Whether tolerance is relative to face size</p> <code>True</code> <code>angle_tol_rads</code> <code>float</code> <p>Angle tolerance in radians. Defaults to 0.1.</p> <code>0.1</code> <p>Returns:</p> Name Type Description <code>bool</code> <p>Is successful</p> Source code in <code>src/occwl/base.py</code> <pre><code>def triangulate(\n    self,\n    triangle_face_tol=0.01,  # Tolerance between triangle and surface\n    tol_relative_to_face=True,  # The tolerance value is relative to the face size\n    angle_tol_rads=0.1,  # Angle between normals/tangents at triangle vertices\n):\n    \"\"\"\n    Triangulate all the faces in the shape. You can then get the triangles \n    from each face separately using face.get_triangles().\n    If you wanted triangles for the entire shape then call\n    shape.get_triangles() below.\n    For more details see \n    https://old.opencascade.com/doc/occt-7.1.0/overview/html/occt_user_guides__modeling_algos.html#occt_modalg_11\n\n    Args:\n        triangle_face_tol (float, optional): Tolerance between triangle and surface. Defaults to 0.01.\n        tol_relative_to_face (bool): Whether tolerance is relative to face size\n        angle_tol_rads (float, optional): Angle tolerance in radians. Defaults to 0.1.\n\n    Returns:\n        bool: Is successful\n    \"\"\"\n    mesh = BRepMesh_IncrementalMesh(\n        self.topods_shape(),\n        triangle_face_tol,\n        tol_relative_to_face,\n        angle_tol_rads,\n        True,\n    )\n    mesh.Perform()\n    return mesh.IsDone()\n</code></pre>"},{"location":"api/#occwl.base.VertexContainerMixin","title":"<code>VertexContainerMixin</code>","text":"<p>A mixin class that adds the ability to perform operations on the vertices in the shape</p> Source code in <code>src/occwl/base.py</code> <pre><code>class VertexContainerMixin:\n    \"\"\"\n    A mixin class that adds the ability to perform operations on the vertices\n    in the shape\n    \"\"\"\n    def num_vertices(self):\n        \"\"\"\n        Number of vertices in the Shape\n\n        Returns:\n            int: Number of vertices\n        \"\"\"\n        return self._top_exp.number_of_vertices()\n\n    def vertices(self):\n        \"\"\"\n        Get an iterator to go over all vertices in the Shape\n\n        Returns:\n            Iterator[occwl.vertex.Vertex]: Vertex iterator\n        \"\"\"\n        from occwl.vertex import Vertex\n        return map(Vertex, self._top_exp.vertices())\n</code></pre>"},{"location":"api/#occwl.base.VertexContainerMixin.num_vertices","title":"<code>num_vertices()</code>","text":"<p>Number of vertices in the Shape</p> <p>Returns:</p> Name Type Description <code>int</code> <p>Number of vertices</p> Source code in <code>src/occwl/base.py</code> <pre><code>def num_vertices(self):\n    \"\"\"\n    Number of vertices in the Shape\n\n    Returns:\n        int: Number of vertices\n    \"\"\"\n    return self._top_exp.number_of_vertices()\n</code></pre>"},{"location":"api/#occwl.base.VertexContainerMixin.vertices","title":"<code>vertices()</code>","text":"<p>Get an iterator to go over all vertices in the Shape</p> <p>Returns:</p> Type Description <p>Iterator[occwl.vertex.Vertex]: Vertex iterator</p> Source code in <code>src/occwl/base.py</code> <pre><code>def vertices(self):\n    \"\"\"\n    Get an iterator to go over all vertices in the Shape\n\n    Returns:\n        Iterator[occwl.vertex.Vertex]: Vertex iterator\n    \"\"\"\n    from occwl.vertex import Vertex\n    return map(Vertex, self._top_exp.vertices())\n</code></pre>"},{"location":"api/#occwl.base.VolumePropertiesMixin","title":"<code>VolumePropertiesMixin</code>","text":"<p>A mixin class that adds the ability to query volumetric properties (e.g. volume, center of mass, etc.).</p> Source code in <code>src/occwl/base.py</code> <pre><code>class VolumePropertiesMixin:\n    \"\"\"\n    A mixin class that adds the ability to query volumetric properties (e.g. volume, center of mass, etc.).\n    \"\"\"\n    def volume(self, tolerance=1e-9):\n        \"\"\"\n        Compute the volume of the Shape\n\n        Args:\n            tolerance (float, optional): Tolerance. Defaults to 1e-9.\n\n        Returns:\n            float: Volume\n        \"\"\"\n        props = GProp_GProps()\n        brepgprop_VolumeProperties(self.topods_shape(), props, tolerance)\n        return props.Mass()\n\n    def center_of_mass(self, tolerance=1e-9):\n        \"\"\"\n        Compute the center of mass of the Shape\n\n        Args:\n            tolerance (float, optional): Tolerance. Defaults to 1e-9.\n\n        Returns:\n            np.ndarray: 3D point\n        \"\"\"\n        from occwl.geometry import geom_utils\n        props = GProp_GProps()\n        brepgprop_VolumeProperties(self.topods_shape(), props, tolerance)\n        com = props.CentreOfMass()\n        return geom_utils.gp_to_numpy(com)\n\n    def moment_of_inertia(self, point, direction, tolerance=1e-9):\n        \"\"\"\n        Compute the moment of inertia about an axis\n\n        Args:\n            point (np.ndarray): 3D point (origin of the axis)\n            direction (np.ndarray): 3D direction of the axis\n            tolerance (float, optional): Tolerance. Defaults to 1e-9.\n\n        Returns:\n            float: Moment of inertia\n        \"\"\"\n        from occwl.geometry import geom_utils\n        props = GProp_GProps()\n        brepgprop_VolumeProperties(self.topods_shape(), props, tolerance)\n        axis = gp_Ax1(\n            geom_utils.numpy_to_gp(point), geom_utils.numpy_to_gp_dir(direction)\n        )\n        return props.MomentOfInertia(axis)\n</code></pre>"},{"location":"api/#occwl.base.VolumePropertiesMixin.center_of_mass","title":"<code>center_of_mass(tolerance=1e-09)</code>","text":"<p>Compute the center of mass of the Shape</p> <p>Parameters:</p> Name Type Description Default <code>tolerance</code> <code>float</code> <p>Tolerance. Defaults to 1e-9.</p> <code>1e-09</code> <p>Returns:</p> Type Description <p>np.ndarray: 3D point</p> Source code in <code>src/occwl/base.py</code> <pre><code>def center_of_mass(self, tolerance=1e-9):\n    \"\"\"\n    Compute the center of mass of the Shape\n\n    Args:\n        tolerance (float, optional): Tolerance. Defaults to 1e-9.\n\n    Returns:\n        np.ndarray: 3D point\n    \"\"\"\n    from occwl.geometry import geom_utils\n    props = GProp_GProps()\n    brepgprop_VolumeProperties(self.topods_shape(), props, tolerance)\n    com = props.CentreOfMass()\n    return geom_utils.gp_to_numpy(com)\n</code></pre>"},{"location":"api/#occwl.base.VolumePropertiesMixin.moment_of_inertia","title":"<code>moment_of_inertia(point, direction, tolerance=1e-09)</code>","text":"<p>Compute the moment of inertia about an axis</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>ndarray</code> <p>3D point (origin of the axis)</p> required <code>direction</code> <code>ndarray</code> <p>3D direction of the axis</p> required <code>tolerance</code> <code>float</code> <p>Tolerance. Defaults to 1e-9.</p> <code>1e-09</code> <p>Returns:</p> Name Type Description <code>float</code> <p>Moment of inertia</p> Source code in <code>src/occwl/base.py</code> <pre><code>def moment_of_inertia(self, point, direction, tolerance=1e-9):\n    \"\"\"\n    Compute the moment of inertia about an axis\n\n    Args:\n        point (np.ndarray): 3D point (origin of the axis)\n        direction (np.ndarray): 3D direction of the axis\n        tolerance (float, optional): Tolerance. Defaults to 1e-9.\n\n    Returns:\n        float: Moment of inertia\n    \"\"\"\n    from occwl.geometry import geom_utils\n    props = GProp_GProps()\n    brepgprop_VolumeProperties(self.topods_shape(), props, tolerance)\n    axis = gp_Ax1(\n        geom_utils.numpy_to_gp(point), geom_utils.numpy_to_gp_dir(direction)\n    )\n    return props.MomentOfInertia(axis)\n</code></pre>"},{"location":"api/#occwl.base.VolumePropertiesMixin.volume","title":"<code>volume(tolerance=1e-09)</code>","text":"<p>Compute the volume of the Shape</p> <p>Parameters:</p> Name Type Description Default <code>tolerance</code> <code>float</code> <p>Tolerance. Defaults to 1e-9.</p> <code>1e-09</code> <p>Returns:</p> Name Type Description <code>float</code> <p>Volume</p> Source code in <code>src/occwl/base.py</code> <pre><code>def volume(self, tolerance=1e-9):\n    \"\"\"\n    Compute the volume of the Shape\n\n    Args:\n        tolerance (float, optional): Tolerance. Defaults to 1e-9.\n\n    Returns:\n        float: Volume\n    \"\"\"\n    props = GProp_GProps()\n    brepgprop_VolumeProperties(self.topods_shape(), props, tolerance)\n    return props.Mass()\n</code></pre>"},{"location":"api/#occwl.base.WireContainerMixin","title":"<code>WireContainerMixin</code>","text":"<p>A mixin class that adds the ability to perform operations on the wires in the shape</p> Source code in <code>src/occwl/base.py</code> <pre><code>class WireContainerMixin:\n    \"\"\"\n    A mixin class that adds the ability to perform operations on the wires\n    in the shape\n    \"\"\"\n    def num_wires(self):\n        \"\"\"\n        Number of wires in the Shape\n\n        Returns:\n            int: Number of wires\n        \"\"\"\n        return self._top_exp.number_of_wires()\n\n    def wires(self):\n        \"\"\"\n        Get an iterator to go over all wires in the Shape\n\n        Returns:\n            Iterator[occwl.wire.Wire]: Wire iterator\n        \"\"\"\n        from occwl.wire import Wire\n        return map(Wire, self._top_exp.wires())\n</code></pre>"},{"location":"api/#occwl.base.WireContainerMixin.num_wires","title":"<code>num_wires()</code>","text":"<p>Number of wires in the Shape</p> <p>Returns:</p> Name Type Description <code>int</code> <p>Number of wires</p> Source code in <code>src/occwl/base.py</code> <pre><code>def num_wires(self):\n    \"\"\"\n    Number of wires in the Shape\n\n    Returns:\n        int: Number of wires\n    \"\"\"\n    return self._top_exp.number_of_wires()\n</code></pre>"},{"location":"api/#occwl.base.WireContainerMixin.wires","title":"<code>wires()</code>","text":"<p>Get an iterator to go over all wires in the Shape</p> <p>Returns:</p> Type Description <p>Iterator[occwl.wire.Wire]: Wire iterator</p> Source code in <code>src/occwl/base.py</code> <pre><code>def wires(self):\n    \"\"\"\n    Get an iterator to go over all wires in the Shape\n\n    Returns:\n        Iterator[occwl.wire.Wire]: Wire iterator\n    \"\"\"\n    from occwl.wire import Wire\n    return map(Wire, self._top_exp.wires())\n</code></pre>"},{"location":"api/#occwl.compound","title":"<code>compound</code>","text":""},{"location":"api/#occwl.compound.Compound","title":"<code>Compound</code>","text":"<p>               Bases: <code>Shape</code>, <code>BottomUpFaceIterator</code>, <code>BoundingBoxMixin</code>, <code>BottomUpEdgeIterator</code>, <code>EdgeContainerMixin</code>, <code>FaceContainerMixin</code>, <code>SolidContainerMixin</code>, <code>ShellContainerMixin</code>, <code>SurfacePropertiesMixin</code>, <code>TriangulatorMixin</code>, <code>VertexContainerMixin</code>, <code>VolumePropertiesMixin</code>, <code>WireContainerMixin</code></p> <p>A compound which can be worked with as many shapes lumped together.</p> Source code in <code>src/occwl/compound.py</code> <pre><code>class Compound(Shape, BottomUpFaceIterator, BoundingBoxMixin, BottomUpEdgeIterator,\n    EdgeContainerMixin, FaceContainerMixin, SolidContainerMixin, ShellContainerMixin, SurfacePropertiesMixin,\n    TriangulatorMixin, VertexContainerMixin, VolumePropertiesMixin, WireContainerMixin):\n    \"\"\"\n    A compound which can be worked with as many shapes\n    lumped together.\n    \"\"\"\n    def __init__(self, shape):\n        assert isinstance(shape, TopoDS_Compound)\n        super().__init__(shape)\n\n    @staticmethod\n    def load_from_step(filename, verbosity=False):\n        \"\"\"\n        Load everything from a STEP file as a single Compound\n\n        Args:\n            filename (str or pathlib.Path): STEP filename\n            verbosity (bool): Whether to print detailed information while loading\n\n        Returns:\n            occwl.compound.Compound: Compound shape\n        \"\"\"\n        shp = read_step_file(str(filename), as_compound=True, verbosity=verbosity)\n        if not isinstance(shp, TopoDS_Compound):\n            shp, success = list_of_shapes_to_compound([shp])\n            assert success\n        return Compound(shp)\n\n    @staticmethod\n    def load_step_with_attributes(step_filename):\n        \"\"\"Load shapes from a step file with the\n        name information.   Other attributes could be\n        retro-fitted\n\n        Args:\n            step_filename (str): Path to STEP file\n\n        Returns:\n            occwl.Compound, dict occwl.Shape to attributes \n        \"\"\"        \n        # Read the file and get the shape\n        reader = STEPControl_Reader()\n        tr = reader.WS().TransferReader()\n        reader.ReadFile(str(step_filename))\n        reader.TransferRoots()\n        shape = reader.OneShape()\n\n        occwl_shape_to_attributes = {}\n        def check_shape_type(shape_type):\n            exp = TopExp_Explorer(shape, shape_type)\n            while exp.More():\n                s = exp.Current()\n                exp.Next()\n                item = tr.EntityFromShapeResult(s, 1)\n                if item is None:\n                    continue\n                item = StepRepr_RepresentationItem.DownCast(item)\n                if item is None:\n                    continue\n                name = item.Name().ToCString()\n                occwl_shape = Shape.occwl_shape(s)\n                occwl_shape_to_attributes[occwl_shape] = {\n                    \"name\": name\n                }\n\n        check_shape_type(TopAbs_FACE)\n        check_shape_type(TopAbs_EDGE)\n        check_shape_type(TopAbs_SHELL)\n        check_shape_type(TopAbs_SOLID)\n        check_shape_type(TopAbs_COMPOUND)\n        check_shape_type(TopAbs_COMPSOLID)\n\n        shp, success = list_of_shapes_to_compound([shape])\n        assert success, \"Failed to convert to a single compound\"\n        return Compound(shp), occwl_shape_to_attributes\n\n\n    @staticmethod\n    def load_from_occ_native(filename, verbosity=False):\n        \"\"\"\n        Load everything from the OCC native .brep file \n        format into a single occwl.compound.Compound.\n\n        Note:  Saving to and loading from the native file format \n               is between one and two orders of magnitude faster \n               than loading from STEP, so it is recommended for \n               large scale data processing\n\n        Args:\n            filename (str or pathlib.Path): .brep filename\n            verbosity (bool): Whether to print detailed information while loading\n\n        Returns:\n            occwl.compound.Compound: Compound shape\n        \"\"\"\n        shape_set = BRepTools_ShapeSet()\n        with open(filename, \"r\") as fp:\n            shape_set.ReadFromString(fp.read())\n        shapes = []\n        for i in range(shape_set.NbShapes()):\n            shapes.append(shape_set.Shape(i+1))\n        shp, success = list_of_shapes_to_compound(shapes)\n        assert success\n        return Compound(shp)\n</code></pre>"},{"location":"api/#occwl.compound.Compound.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Equality check for the shape</p> <p>NOTE: This function only checks if the shape is the same. It doesn't check the edge orienation for example, so </p> <p>edge1 == edge2</p> <p>does not necessarily mean </p> <p>edge1.reversed() == edge2.reversed()</p> Source code in <code>src/occwl/shape.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"\n    Equality check for the shape\n\n    NOTE: This function only checks if the shape is the same.\n    It doesn't check the edge orienation for example, so \n\n    edge1 == edge2\n\n    does not necessarily mean \n\n    edge1.reversed() == edge2.reversed()\n    \"\"\"\n    return self.topods_shape().__hash__() == other.topods_shape().__hash__()\n</code></pre>"},{"location":"api/#occwl.compound.Compound.__hash__","title":"<code>__hash__()</code>","text":"<p>Hash for the shape</p> <p>Returns:</p> Name Type Description <code>int</code> <p>Hash value</p> Source code in <code>src/occwl/shape.py</code> <pre><code>def __hash__(self):\n    \"\"\"\n    Hash for the shape\n\n    Returns:\n        int: Hash value\n    \"\"\"\n    return self.topods_shape().__hash__()\n</code></pre>"},{"location":"api/#occwl.compound.Compound.area","title":"<code>area()</code>","text":"<p>Compute the area of the Shape</p> <p>Returns:</p> Name Type Description <code>float</code> <p>Area</p> Source code in <code>src/occwl/base.py</code> <pre><code>def area(self):\n    \"\"\"\n    Compute the area of the Shape\n\n    Returns:\n        float: Area\n    \"\"\"\n    geometry_properties = GProp_GProps()\n    brepgprop_SurfaceProperties(self.topods_shape(), geometry_properties)\n    return geometry_properties.Mass()\n</code></pre>"},{"location":"api/#occwl.compound.Compound.box","title":"<code>box()</code>","text":"<p>Get a quick bounding box of the Shape</p> <p>Returns:</p> Name Type Description <code>Box</code> <p>Bounding box</p> Source code in <code>src/occwl/base.py</code> <pre><code>def box(self):\n    \"\"\"\n    Get a quick bounding box of the Shape\n\n    Returns:\n        Box: Bounding box\n    \"\"\"\n    from occwl.geometry import geom_utils\n    b = Bnd_Box()\n    brepbndlib_Add(self.topods_shape(), b)\n    return geom_utils.box_to_geometry(b)\n</code></pre>"},{"location":"api/#occwl.compound.Compound.center_of_mass","title":"<code>center_of_mass(tolerance=1e-09)</code>","text":"<p>Compute the center of mass of the Shape</p> <p>Parameters:</p> Name Type Description Default <code>tolerance</code> <code>float</code> <p>Tolerance. Defaults to 1e-9.</p> <code>1e-09</code> <p>Returns:</p> Type Description <p>np.ndarray: 3D point</p> Source code in <code>src/occwl/base.py</code> <pre><code>def center_of_mass(self, tolerance=1e-9):\n    \"\"\"\n    Compute the center of mass of the Shape\n\n    Args:\n        tolerance (float, optional): Tolerance. Defaults to 1e-9.\n\n    Returns:\n        np.ndarray: 3D point\n    \"\"\"\n    from occwl.geometry import geom_utils\n    props = GProp_GProps()\n    brepgprop_VolumeProperties(self.topods_shape(), props, tolerance)\n    com = props.CentreOfMass()\n    return geom_utils.gp_to_numpy(com)\n</code></pre>"},{"location":"api/#occwl.compound.Compound.convert_geometric_identity_transforms_to_identity","title":"<code>convert_geometric_identity_transforms_to_identity()</code>","text":"<p>Open Cascade models sometimes contain transforms which are \"geometrically\" identify transforms, but the identity flag is not set.</p> <p>This function checks each transform and sets the flag if  the appropriate.</p> Source code in <code>src/occwl/shape.py</code> <pre><code>def convert_geometric_identity_transforms_to_identity(self):\n    \"\"\"\n    Open Cascade models sometimes contain transforms which\n    are \"geometrically\" identify transforms, but the identity\n    flag is not set.\n\n    This function checks each transform and sets the flag if \n    the appropriate.\n    \"\"\"\n    identity = TopLoc_Location()\n    if geom_utils.is_geometric_identity(\n        self.topods_shape().Location().Transformation()\n    ):\n        self.topods_shape().Location(identity)\n        self._top_exp = TopologyUtils.TopologyExplorer(self.topods_shape(), True)\n\n    for face in self._top_exp.faces():\n        if geom_utils.is_geometric_identity(face.Location().Transformation()):\n            face.Location(identity)\n\n    for edge in self._top_exp.edges():\n        if geom_utils.is_geometric_identity(edge.Location().Transformation()):\n            edge.Location(identity)\n\n    for vertex in self._top_exp.vertices():\n        if geom_utils.is_geometric_identity(vertex.Location().Transformation()):\n            vertex.Location(identity)\n</code></pre>"},{"location":"api/#occwl.compound.Compound.edge_continuity","title":"<code>edge_continuity(edge)</code>","text":"<p>Get the neighboring faces' continuity at given edge</p> <p>Parameters:</p> Name Type Description Default <code>edge</code> <code>Edge</code> <p>Edge</p> required <p>Returns:</p> Name Type Description <code>GeomAbs_Shape</code> <p>enum describing the continuity order</p> Source code in <code>src/occwl/base.py</code> <pre><code>def edge_continuity(self, edge):\n    \"\"\"\n    Get the neighboring faces' continuity at given edge\n\n    Args:\n        edge (occwl.edge.Edge): Edge\n\n    Returns:\n        GeomAbs_Shape: enum describing the continuity order\n    \"\"\"\n    faces = list(self.faces_from_edge(edge))\n    # Handle seam edges which only have one face around them\n    if len(faces) == 1:\n        faces.append(faces[-1])\n    return edge.continuity(faces[0], faces[1])\n</code></pre>"},{"location":"api/#occwl.compound.Compound.edges","title":"<code>edges()</code>","text":"<p>Get an iterator to go over all edges in the Shape</p> <p>Returns:</p> Type Description <p>Iterator[occwl.edge.Edge]: Edge iterator</p> Source code in <code>src/occwl/base.py</code> <pre><code>def edges(self):\n    \"\"\"\n    Get an iterator to go over all edges in the Shape\n\n    Returns:\n        Iterator[occwl.edge.Edge]: Edge iterator\n    \"\"\"\n    from occwl.edge import Edge\n    return map(Edge, self._top_exp.edges())\n</code></pre>"},{"location":"api/#occwl.compound.Compound.edges_from_face","title":"<code>edges_from_face(face)</code>","text":"<p>Get an iterator to go over the edges in a face</p> <p>Parameters:</p> Name Type Description Default <code>face</code> <code>Face</code> <p>Input face</p> required <p>Returns:</p> Type Description <p>Iterator[occwl.edge.Edge]: Edge iterator</p> Source code in <code>src/occwl/base.py</code> <pre><code>def edges_from_face(self, face):\n    \"\"\"\n    Get an iterator to go over the edges in a face\n\n    Args:\n        face (occwl.face.Face): Input face\n\n    Returns:\n        Iterator[occwl.edge.Edge]: Edge iterator\n    \"\"\"\n    from occwl.edge import Edge\n    from occwl.face import Face\n    assert isinstance(face, Face)\n    return map(Edge, self._top_exp.edges_from_face(face.topods_shape()))\n</code></pre>"},{"location":"api/#occwl.compound.Compound.edges_from_vertex","title":"<code>edges_from_vertex(vertex)</code>","text":"<p>Get an iterator to go over the edges adjacent to a vertex</p> <p>Parameters:</p> Name Type Description Default <code>face</code> <code>Face</code> <p>Input face</p> required <p>Returns:</p> Type Description <p>Iterator[occwl.edge.Edge]: Edge iterator</p> Source code in <code>src/occwl/base.py</code> <pre><code>def edges_from_vertex(self, vertex):\n    \"\"\"\n    Get an iterator to go over the edges adjacent to a vertex\n\n    Args:\n        face (occwl.face.Face): Input face\n\n    Returns:\n        Iterator[occwl.edge.Edge]: Edge iterator\n    \"\"\"\n    from occwl.vertex import Vertex\n    from occwl.edge import Edge\n    assert isinstance(vertex, Vertex)\n    return map(Edge, self._top_exp.edges_from_vertex(vertex.topods_shape()))\n</code></pre>"},{"location":"api/#occwl.compound.Compound.exact_box","title":"<code>exact_box(use_shapetolerance=False)</code>","text":"<p>Get a slow, but accurate box for the Shape.</p> <p>Returns:</p> Name Type Description <code>Box</code> <p>Bounding box</p> Source code in <code>src/occwl/base.py</code> <pre><code>def exact_box(self, use_shapetolerance=False):\n    \"\"\"\n    Get a slow, but accurate box for the Shape.\n\n    Args:\n        use_shapetolerance (bool, optional) Include the tolerance of edges\n                                            and vertices in the box.\n\n    Returns:\n        Box: Bounding box\n    \"\"\"\n    from occwl.geometry import geom_utils\n    b = Bnd_Box()\n    use_triangulation = True\n    brepbndlib_AddOptimal(self.topods_shape(), b, use_triangulation, use_shapetolerance)\n    return geom_utils.box_to_geometry(b)\n</code></pre>"},{"location":"api/#occwl.compound.Compound.faces","title":"<code>faces()</code>","text":"<p>Get an iterator to go over all faces in the Shape</p> <p>Returns:</p> Type Description <p>Iterator[occwl.face.Face]: Face iterator</p> Source code in <code>src/occwl/base.py</code> <pre><code>def faces(self):\n    \"\"\"\n    Get an iterator to go over all faces in the Shape\n\n    Returns:\n        Iterator[occwl.face.Face]: Face iterator\n    \"\"\"\n    from occwl.face import Face\n    return map(Face, self._top_exp.faces())\n</code></pre>"},{"location":"api/#occwl.compound.Compound.faces_from_edge","title":"<code>faces_from_edge(edge)</code>","text":"<p>Get an iterator to go over the faces adjacent to an edge</p> <p>Parameters:</p> Name Type Description Default <code>edge</code> <code>Edge</code> <p>Input edge</p> required <p>Returns:</p> Type Description <p>Iterator[occwl.face.Face]: Face iterator</p> Source code in <code>src/occwl/base.py</code> <pre><code>def faces_from_edge(self, edge):\n    \"\"\"\n    Get an iterator to go over the faces adjacent to an edge\n\n    Args:\n        edge (occwl.edge.Edge): Input edge\n\n    Returns:\n        Iterator[occwl.face.Face]: Face iterator\n    \"\"\"\n    from occwl.edge import Edge\n    from occwl.face import Face\n    assert isinstance(edge, Edge)\n    return map(Face, self._top_exp.faces_from_edge(edge.topods_shape()))\n</code></pre>"},{"location":"api/#occwl.compound.Compound.faces_from_vertex","title":"<code>faces_from_vertex(vertex)</code>","text":"<p>Get an iterator to go over the faces adjacent to a vertex</p> <p>Parameters:</p> Name Type Description Default <code>edge</code> <code>Vertex</code> <p>Input vertex</p> required <p>Returns:</p> Type Description <p>Iterator[occwl.face.Face]: Face iterator</p> Source code in <code>src/occwl/base.py</code> <pre><code>def faces_from_vertex(self, vertex):\n    \"\"\"\n    Get an iterator to go over the faces adjacent to a vertex\n\n    Args:\n        edge (occwl.vertex.Vertex): Input vertex\n\n    Returns:\n        Iterator[occwl.face.Face]: Face iterator\n    \"\"\"\n    from occwl.vertex import Vertex\n    from occwl.face import Face\n    assert isinstance(vertex, Vertex)\n    return map(Face, self._top_exp.faces_from_vertex(vertex.topods_shape()))\n</code></pre>"},{"location":"api/#occwl.compound.Compound.find_closest_edge_slow","title":"<code>find_closest_edge_slow(datum)</code>","text":"<p>Find the closest edge to the given datum point. The function is for testing only.  It will be slow  as it loops over all edges in the Shape. A quick way to find the closest entity is to call Shape.find_closest_point_data(), but then you may get a face, edge or vertex back.</p> <p>Parameters:</p> Name Type Description Default <code>datum</code> <code>ndarray or tuple</code> <p>3D datum point</p> required <p>Returns:</p> Name Type Description <code>Face</code> <p>The closest face in the Shape</p> Source code in <code>src/occwl/base.py</code> <pre><code>def find_closest_edge_slow(self, datum):\n    \"\"\"\n    Find the closest edge to the given datum point.\n    The function is for testing only.  It will be slow \n    as it loops over all edges in the Shape.\n    A quick way to find the closest entity is to call\n    Shape.find_closest_point_data(), but then you\n    may get a face, edge or vertex back.\n\n    Args:\n        datum (np.ndarray or tuple): 3D datum point\n\n    Returns:\n        Face: The closest face in the Shape\n    \"\"\"\n    return _find_closest_shape_in_list(self.edges(), datum)\n</code></pre>"},{"location":"api/#occwl.compound.Compound.find_closest_face_slow","title":"<code>find_closest_face_slow(datum)</code>","text":"<p>Find the closest face to the given datum point. The function is for testing only. It will be slow  as it loops over all faces in the Shape. A quick way to find the closest entity is to call Shape.find_closest_point_data(), but then you may get a face, edge or vertex back.</p> <p>Parameters:</p> Name Type Description Default <code>datum</code> <code>ndarray or tuple</code> <p>3D datum point</p> required <p>Returns:</p> Name Type Description <code>Face</code> <p>The closest face in the Shape</p> Source code in <code>src/occwl/base.py</code> <pre><code>def find_closest_face_slow(self, datum):\n    \"\"\"\n    Find the closest face to the given datum point.\n    The function is for testing only. It will be slow \n    as it loops over all faces in the Shape.\n    A quick way to find the closest entity is to call\n    Shape.find_closest_point_data(), but then you\n    may get a face, edge or vertex back.\n\n    Args:\n        datum (np.ndarray or tuple): 3D datum point\n\n    Returns:\n        Face: The closest face in the Shape\n    \"\"\"\n    return _find_closest_shape_in_list(self.faces(), datum)\n</code></pre>"},{"location":"api/#occwl.compound.Compound.find_closest_point_data","title":"<code>find_closest_point_data(datum)</code>","text":"<p>Find the information about the closest point on this shape</p> <p>Parameters:</p> Name Type Description Default <code>datum</code> <code>ndarray</code> <p>3D Point</p> required <p>Returns:</p> Name Type Description <code>ClosestPointData</code> <p>Data about the closest point on this shape</p> <code>None</code> <p>if error</p> Source code in <code>src/occwl/shape.py</code> <pre><code>def find_closest_point_data(self, datum):\n    \"\"\"\n    Find the information about the closest point on this shape\n\n    Args:\n        datum (np.ndarray): 3D Point\n\n    Returns:\n        ClosestPointData: Data about the closest point on this shape\n        None: if error\n    \"\"\"\n    # Folowing https://dev.opencascade.org/content/how-retrieve-nearest-face-shape-given-gppnt\n    # Create a vertex from the point\n    occ_point = geom_utils.numpy_to_gp(datum)\n    vertex_maker = BRepBuilderAPI_MakeVertex(occ_point)\n    vertex = vertex_maker.Shape()\n    dist_shape_shape = BRepExtrema_DistShapeShape(\n        vertex, self.topods_shape(), Extrema_ExtFlag_MIN\n    )\n    ok = dist_shape_shape.Perform()\n    if not ok:\n        return None\n\n    return ClosestPointData(dist_shape_shape)\n</code></pre>"},{"location":"api/#occwl.compound.Compound.get_triangles","title":"<code>get_triangles(triangle_face_tol=0.01, tol_relative_to_face=True, angle_tol_rads=0.1)</code>","text":"<p>Compute and get the tessellation of the entire shape</p> <p>Parameters:</p> Name Type Description Default <code>triangle_face_tol</code> <code>float</code> <p>Toelrance between triangle and surface. Defaults to 0.01.</p> <code>0.01</code> <code>tol_relative_to_face</code> <code>bool</code> <p>Whether tolerance is relative to face size</p> <code>True</code> <code>angle_tol_rads</code> <code>float</code> <p>Angle tolerance in radians. Defaults to 0.1.</p> <code>0.1</code> <p>Returns:</p> Type Description <p>2D np.ndarray (float): Vertices or None if triangulation failed</p> <p>2D np.ndarray (int): Faces or None if triangulation failed</p> Source code in <code>src/occwl/base.py</code> <pre><code>def get_triangles(\n    self,\n    triangle_face_tol=0.01,  # Tolerance between triangle and surface\n    tol_relative_to_face=True,  # The tolerance value is relative to the face size\n    angle_tol_rads=0.1,  # Angle between normals/tangents at triangle vertices\n):\n    \"\"\"\n    Compute and get the tessellation of the entire shape\n\n    Args:\n        triangle_face_tol (float, optional): Toelrance between triangle and surface. Defaults to 0.01.\n        tol_relative_to_face (bool): Whether tolerance is relative to face size\n        angle_tol_rads (float, optional): Angle tolerance in radians. Defaults to 0.1.\n\n    Returns:\n        2D np.ndarray (float): Vertices or None if triangulation failed\n        2D np.ndarray (int): Faces or None if triangulation failed\n    \"\"\"\n    ok = self.triangulate_all_faces(\n        triangle_face_tol, tol_relative_to_face, angle_tol_rads\n    )\n    if not ok:\n        # Failed to triangulate\n        return None, None\n    verts = []\n    tris = []\n    faces = self.faces()\n    last_vert_index = 0\n    for face in faces:\n        fverts, ftris = face.get_triangles()\n        verts.extend(fverts)\n        for tri in ftris:\n            new_indices = [index + last_vert_index for index in tri]\n            tris.append(new_indices)\n        last_vert_index = len(verts)\n    return np.asarray(verts, dtype=np.float32), np.asarray(tris, dtype=np.int32)\n</code></pre>"},{"location":"api/#occwl.compound.Compound.load_from_occ_native","title":"<code>load_from_occ_native(filename, verbosity=False)</code>  <code>staticmethod</code>","text":"<p>Load everything from the OCC native .brep file  format into a single occwl.compound.Compound.</p> Saving to and loading from the native file format <p>is between one and two orders of magnitude faster  than loading from STEP, so it is recommended for  large scale data processing</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str or Path</code> <p>.brep filename</p> required <code>verbosity</code> <code>bool</code> <p>Whether to print detailed information while loading</p> <code>False</code> <p>Returns:</p> Type Description <p>occwl.compound.Compound: Compound shape</p> Source code in <code>src/occwl/compound.py</code> <pre><code>@staticmethod\ndef load_from_occ_native(filename, verbosity=False):\n    \"\"\"\n    Load everything from the OCC native .brep file \n    format into a single occwl.compound.Compound.\n\n    Note:  Saving to and loading from the native file format \n           is between one and two orders of magnitude faster \n           than loading from STEP, so it is recommended for \n           large scale data processing\n\n    Args:\n        filename (str or pathlib.Path): .brep filename\n        verbosity (bool): Whether to print detailed information while loading\n\n    Returns:\n        occwl.compound.Compound: Compound shape\n    \"\"\"\n    shape_set = BRepTools_ShapeSet()\n    with open(filename, \"r\") as fp:\n        shape_set.ReadFromString(fp.read())\n    shapes = []\n    for i in range(shape_set.NbShapes()):\n        shapes.append(shape_set.Shape(i+1))\n    shp, success = list_of_shapes_to_compound(shapes)\n    assert success\n    return Compound(shp)\n</code></pre>"},{"location":"api/#occwl.compound.Compound.load_from_step","title":"<code>load_from_step(filename, verbosity=False)</code>  <code>staticmethod</code>","text":"<p>Load everything from a STEP file as a single Compound</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str or Path</code> <p>STEP filename</p> required <code>verbosity</code> <code>bool</code> <p>Whether to print detailed information while loading</p> <code>False</code> <p>Returns:</p> Type Description <p>occwl.compound.Compound: Compound shape</p> Source code in <code>src/occwl/compound.py</code> <pre><code>@staticmethod\ndef load_from_step(filename, verbosity=False):\n    \"\"\"\n    Load everything from a STEP file as a single Compound\n\n    Args:\n        filename (str or pathlib.Path): STEP filename\n        verbosity (bool): Whether to print detailed information while loading\n\n    Returns:\n        occwl.compound.Compound: Compound shape\n    \"\"\"\n    shp = read_step_file(str(filename), as_compound=True, verbosity=verbosity)\n    if not isinstance(shp, TopoDS_Compound):\n        shp, success = list_of_shapes_to_compound([shp])\n        assert success\n    return Compound(shp)\n</code></pre>"},{"location":"api/#occwl.compound.Compound.load_step_with_attributes","title":"<code>load_step_with_attributes(step_filename)</code>  <code>staticmethod</code>","text":"<p>Load shapes from a step file with the name information.   Other attributes could be retro-fitted</p> <p>Parameters:</p> Name Type Description Default <code>step_filename</code> <code>str</code> <p>Path to STEP file</p> required <p>Returns:</p> Type Description <p>occwl.Compound, dict occwl.Shape to attributes</p> Source code in <code>src/occwl/compound.py</code> <pre><code>@staticmethod\ndef load_step_with_attributes(step_filename):\n    \"\"\"Load shapes from a step file with the\n    name information.   Other attributes could be\n    retro-fitted\n\n    Args:\n        step_filename (str): Path to STEP file\n\n    Returns:\n        occwl.Compound, dict occwl.Shape to attributes \n    \"\"\"        \n    # Read the file and get the shape\n    reader = STEPControl_Reader()\n    tr = reader.WS().TransferReader()\n    reader.ReadFile(str(step_filename))\n    reader.TransferRoots()\n    shape = reader.OneShape()\n\n    occwl_shape_to_attributes = {}\n    def check_shape_type(shape_type):\n        exp = TopExp_Explorer(shape, shape_type)\n        while exp.More():\n            s = exp.Current()\n            exp.Next()\n            item = tr.EntityFromShapeResult(s, 1)\n            if item is None:\n                continue\n            item = StepRepr_RepresentationItem.DownCast(item)\n            if item is None:\n                continue\n            name = item.Name().ToCString()\n            occwl_shape = Shape.occwl_shape(s)\n            occwl_shape_to_attributes[occwl_shape] = {\n                \"name\": name\n            }\n\n    check_shape_type(TopAbs_FACE)\n    check_shape_type(TopAbs_EDGE)\n    check_shape_type(TopAbs_SHELL)\n    check_shape_type(TopAbs_SOLID)\n    check_shape_type(TopAbs_COMPOUND)\n    check_shape_type(TopAbs_COMPSOLID)\n\n    shp, success = list_of_shapes_to_compound([shape])\n    assert success, \"Failed to convert to a single compound\"\n    return Compound(shp), occwl_shape_to_attributes\n</code></pre>"},{"location":"api/#occwl.compound.Compound.moment_of_inertia","title":"<code>moment_of_inertia(point, direction, tolerance=1e-09)</code>","text":"<p>Compute the moment of inertia about an axis</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>ndarray</code> <p>3D point (origin of the axis)</p> required <code>direction</code> <code>ndarray</code> <p>3D direction of the axis</p> required <code>tolerance</code> <code>float</code> <p>Tolerance. Defaults to 1e-9.</p> <code>1e-09</code> <p>Returns:</p> Name Type Description <code>float</code> <p>Moment of inertia</p> Source code in <code>src/occwl/base.py</code> <pre><code>def moment_of_inertia(self, point, direction, tolerance=1e-9):\n    \"\"\"\n    Compute the moment of inertia about an axis\n\n    Args:\n        point (np.ndarray): 3D point (origin of the axis)\n        direction (np.ndarray): 3D direction of the axis\n        tolerance (float, optional): Tolerance. Defaults to 1e-9.\n\n    Returns:\n        float: Moment of inertia\n    \"\"\"\n    from occwl.geometry import geom_utils\n    props = GProp_GProps()\n    brepgprop_VolumeProperties(self.topods_shape(), props, tolerance)\n    axis = gp_Ax1(\n        geom_utils.numpy_to_gp(point), geom_utils.numpy_to_gp_dir(direction)\n    )\n    return props.MomentOfInertia(axis)\n</code></pre>"},{"location":"api/#occwl.compound.Compound.num_edges","title":"<code>num_edges()</code>","text":"<p>Number of edges in the Shape</p> <p>Returns:</p> Name Type Description <code>int</code> <p>Number of edges</p> Source code in <code>src/occwl/base.py</code> <pre><code>def num_edges(self):\n    \"\"\"\n    Number of edges in the Shape\n\n    Returns:\n        int: Number of edges\n    \"\"\"\n    return self._top_exp.number_of_edges()\n</code></pre>"},{"location":"api/#occwl.compound.Compound.num_faces","title":"<code>num_faces()</code>","text":"<p>Number of faces in the Shape</p> <p>Returns:</p> Name Type Description <code>int</code> <p>Number of faces</p> Source code in <code>src/occwl/base.py</code> <pre><code>def num_faces(self):\n    \"\"\"\n    Number of faces in the Shape\n\n    Returns:\n        int: Number of faces\n    \"\"\"\n    return self._top_exp.number_of_faces()\n</code></pre>"},{"location":"api/#occwl.compound.Compound.num_shells","title":"<code>num_shells()</code>","text":"<p>Number of shells in the Shape</p> <p>Returns:</p> Name Type Description <code>int</code> <p>Number of shells</p> Source code in <code>src/occwl/base.py</code> <pre><code>def num_shells(self):\n    \"\"\"\n    Number of shells in the Shape\n\n    Returns:\n        int: Number of shells\n    \"\"\"\n    return self._top_exp.number_of_shells()\n</code></pre>"},{"location":"api/#occwl.compound.Compound.num_solids","title":"<code>num_solids()</code>","text":"<p>Number of solids in the Compound</p> <p>Returns:</p> Name Type Description <code>int</code> <p>Number of solids</p> Source code in <code>src/occwl/base.py</code> <pre><code>def num_solids(self):\n    \"\"\"\n    Number of solids in the Compound\n\n    Returns:\n        int: Number of solids\n    \"\"\"\n    return self._top_exp.number_of_solids()\n</code></pre>"},{"location":"api/#occwl.compound.Compound.num_vertices","title":"<code>num_vertices()</code>","text":"<p>Number of vertices in the Shape</p> <p>Returns:</p> Name Type Description <code>int</code> <p>Number of vertices</p> Source code in <code>src/occwl/base.py</code> <pre><code>def num_vertices(self):\n    \"\"\"\n    Number of vertices in the Shape\n\n    Returns:\n        int: Number of vertices\n    \"\"\"\n    return self._top_exp.number_of_vertices()\n</code></pre>"},{"location":"api/#occwl.compound.Compound.num_wires","title":"<code>num_wires()</code>","text":"<p>Number of wires in the Shape</p> <p>Returns:</p> Name Type Description <code>int</code> <p>Number of wires</p> Source code in <code>src/occwl/base.py</code> <pre><code>def num_wires(self):\n    \"\"\"\n    Number of wires in the Shape\n\n    Returns:\n        int: Number of wires\n    \"\"\"\n    return self._top_exp.number_of_wires()\n</code></pre>"},{"location":"api/#occwl.compound.Compound.occwl_shape","title":"<code>occwl_shape(topods_shape)</code>  <code>staticmethod</code>","text":"<p>Static method to create an occwl shape of the appropriate  class from the given topods_shape Args:     topods_shape (OCC.Core.TopoDS.TopoDS_Vertex/Edge/Face/Wire/Shell/Solid): TopoDS shape</p> <p>Returns:</p> Type Description <p>One of occwl.compound.Compound occwl.solid.Solid occwl.face.Face occwl.edge.Edge occwl.vertex.Vertex occwl.wire.Wire occwl.shell.Shell</p> <p>Raises:     Exception: [description]</p> Source code in <code>src/occwl/shape.py</code> <pre><code>@staticmethod\ndef occwl_shape(topods_shape):\n    \"\"\"\n    Static method to create an occwl shape of the appropriate \n    class from the given topods_shape\n    Args:\n        topods_shape (OCC.Core.TopoDS.TopoDS_Vertex/Edge/Face/Wire/Shell/Solid): TopoDS shape\n\n    Returns:\n        One of\n            occwl.compound.Compound\n            occwl.solid.Solid\n            occwl.face.Face\n            occwl.edge.Edge\n            occwl.vertex.Vertex\n            occwl.wire.Wire\n            occwl.shell.Shell\n    Raises:\n        Exception: [description]\n    \"\"\"\n    from occwl.compound import Compound\n    from occwl.solid import Solid\n    from occwl.face import Face\n    from occwl.edge import Edge\n    from occwl.vertex import Vertex\n    from occwl.wire import Wire\n    from occwl.shell import Shell\n\n    if isinstance(topods_shape, TopoDS_Vertex):\n        return Vertex(topods_shape)\n    if isinstance(topods_shape, TopoDS_Edge):\n        return Edge(topods_shape)\n    if isinstance(topods_shape, TopoDS_Face):\n        return Face(topods_shape)\n    if isinstance(topods_shape, TopoDS_Wire):\n        return Wire(topods_shape)\n    if isinstance(topods_shape, TopoDS_Shell):\n        return Shell(topods_shape)\n    if isinstance(topods_shape, TopoDS_Solid):\n        return Solid(topods_shape)\n    if isinstance(topods_shape, (TopoDS_Compound, TopoDS_CompSolid)):\n        return Compound(topods_shape)\n    raise Exception(\n        \"Shape must be one of TopoDS_Vertex, TopoDS_Edge, TopoDS_Face, TopoDS_Shell, TopoDS_Solid, TopoDS_Compound, TopoDS_CompSolid\"\n    )\n</code></pre>"},{"location":"api/#occwl.compound.Compound.reversed","title":"<code>reversed()</code>","text":"<p>Whether this shape is reversed.</p> <ul> <li>For an edge this is whether the edge is reversed with respect to the curve geometry</li> <li>For a face this is whether the face is reversed with respect to the surface geometry</li> <li>For a vertex this is whether the vertex is at the upper or lower parameter value on the   edges curve</li> </ul> <p>Returns:</p> Name Type Description <code>bool</code> <p>If rational</p> Source code in <code>src/occwl/shape.py</code> <pre><code>def reversed(self):\n    \"\"\"\n    Whether this shape is reversed.\n\n    - For an edge this is whether the edge is reversed with respect to the curve geometry\n    - For a face this is whether the face is reversed with respect to the surface geometry\n    - For a vertex this is whether the vertex is at the upper or lower parameter value on the\n      edges curve\n\n    Returns:\n        bool: If rational\n    \"\"\"\n    return self.topods_shape().Orientation() == TopAbs_REVERSED\n</code></pre>"},{"location":"api/#occwl.compound.Compound.rotate_axis_angle","title":"<code>rotate_axis_angle(axis, angle_radians, origin=np.zeros(3, dtype=(np.float32)))</code>","text":"<p>Rotate the shape about the given axis by the given angle in radians</p> <p>Parameters:</p> Name Type Description Default <code>axis</code> <code>ndarray</code> <p>Rotation axis</p> required <code>angle_radians</code> <code>float</code> <p>Angle in radians</p> required Source code in <code>src/occwl/shape.py</code> <pre><code>def rotate_axis_angle(\n    self, axis, angle_radians, origin=np.zeros(3, dtype=np.float32)\n):\n    \"\"\"\n    Rotate the shape about the given axis by the given angle in radians\n\n    Args:\n        axis (np.ndarray): Rotation axis\n        angle_radians (float): Angle in radians\n    \"\"\"\n    self._shape = rotate_shape(\n        self._shape,\n        gp_Ax1(geom_utils.numpy_to_gp(origin), geom_utils.numpy_to_gp_dir(axis)),\n        angle_radians,\n        unite=\"rad\",\n    )\n</code></pre>"},{"location":"api/#occwl.compound.Compound.rotate_euler_angles","title":"<code>rotate_euler_angles(angles_xyz_radians)</code>","text":"<p>Rotate the shape by the given Euler angles in radians</p> <p>Parameters:</p> Name Type Description Default <code>angle_xyz_radians</code> <code>ndarray</code> <p>3D array with angles to rotate about x-axis, y-axis and z-axis respectively in radians</p> required Source code in <code>src/occwl/shape.py</code> <pre><code>def rotate_euler_angles(self, angles_xyz_radians):\n    \"\"\"\n    Rotate the shape by the given Euler angles in radians\n\n    Args:\n        angle_xyz_radians (np.ndarray): 3D array with angles to rotate about x-axis, y-axis and z-axis respectively in radians\n    \"\"\"\n    self._shape = rotate_shp_3_axis(\n        self._shape,\n        angles_xyz_radians[0],\n        angles_xyz_radians[1],\n        angles_xyz_radians[2],\n        unity=\"rad\",\n    )\n</code></pre>"},{"location":"api/#occwl.compound.Compound.save_shapes_to_occ_native","title":"<code>save_shapes_to_occ_native(filename, shapes, with_triangles=False, with_normals=False, format_version=None)</code>  <code>staticmethod</code>","text":"<p>Save this shape into a native OCC binary .brep file.</p> Saving to and loading from the native file format <p>is between one and two orders of magnitude faster  than loading from STEP, so it is recommended for  large scale data processing</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str or Path</code> <p>.brep filename</p> required <code>with_triangles</code> <code>bool</code> <p>Whether to save triangle data cached in the shape.</p> <code>False</code> <code>with_normals</code> <code>bool</code> <p>Whether to save vertex normals cached in the shape</p> <code>False</code> <code>format_version</code> <code>int</code> <p>Use None to save to the latest version 1 - first revision 2 - added storing of CurveOnSurface UV Points 3 - [OCCT 7.6] added storing of per-vertex normal information                and dropped storing of CurveOnSurface UV Points</p> <code>None</code> Source code in <code>src/occwl/shape.py</code> <pre><code>@staticmethod\ndef save_shapes_to_occ_native(\n        filename, \n        shapes,\n        with_triangles=False,\n        with_normals=False,\n        format_version=None\n    ):\n    \"\"\"\n    Save this shape into a native OCC binary .brep file.\n\n    Note:  Saving to and loading from the native file format \n            is between one and two orders of magnitude faster \n            than loading from STEP, so it is recommended for \n            large scale data processing\n\n    Args:\n        filename (str or pathlib.Path): .brep filename\n\n        with_triangles (bool): Whether to save triangle data cached in the shape.\n        with_normals (bool): Whether to save vertex normals cached in the shape\n        format_version (int):  Use None to save to the latest version\n            1 - first revision\n            2 - added storing of CurveOnSurface UV Points\n            3 - [OCCT 7.6] added storing of per-vertex normal information\n                           and dropped storing of CurveOnSurface UV Points\n    \"\"\"\n    new_api = False\n    shapes_set = BRepTools_ShapeSet(with_triangles)\n    # shapes_set.SetWithNormals(with_normals) # Not in OCC 7.5.0\n\n    for shp in shapes:\n        shapes_set.Add(shp.topods_shape())\n    if format_version is not None:\n        shapes_set.SetFormatNb(format_version)\n\n\n    with open(filename, \"w\") as fp:\n        s = shapes_set.WriteToString()\n        fp.write(s)\n</code></pre>"},{"location":"api/#occwl.compound.Compound.save_to_occ_native","title":"<code>save_to_occ_native(filename, verbosity=False, with_triangles=False, with_normals=False, format_version=None)</code>","text":"<p>Save this shape into a native OCC binary .brep file.</p> Saving to and loading from the native file format <p>is between one and two orders of magnitude faster  than loading from STEP, so it is recommended for  large scale data processing</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str or Path</code> <p>.brep filename</p> required <code>with_triangles</code> <code>bool</code> <p>Whether to save triangle data cached in the shape.</p> <code>False</code> <code>with_normals</code> <code>bool</code> <p>Whether to save vertex normals cached in the shape</p> <code>False</code> <code>format_version</code> <code>int</code> <p>Use None to save to the latest version 1 - first revision 2 - added storing of CurveOnSurface UV Points 3 - [OCCT 7.6] added storing of per-vertex normal information                and dropped storing of CurveOnSurface UV Points</p> <code>None</code> Source code in <code>src/occwl/shape.py</code> <pre><code>def save_to_occ_native(\n        self, \n        filename, \n        verbosity=False,\n        with_triangles=False,\n        with_normals=False,\n        format_version=None\n    ):\n    \"\"\"\n    Save this shape into a native OCC binary .brep file.\n\n    Note:  Saving to and loading from the native file format \n           is between one and two orders of magnitude faster \n           than loading from STEP, so it is recommended for \n           large scale data processing\n\n    Args:\n        filename (str or pathlib.Path): .brep filename\n        with_triangles (bool): Whether to save triangle data cached in the shape.\n        with_normals (bool): Whether to save vertex normals cached in the shape\n        format_version (int):  Use None to save to the latest version\n            1 - first revision\n            2 - added storing of CurveOnSurface UV Points\n            3 - [OCCT 7.6] added storing of per-vertex normal information\n                           and dropped storing of CurveOnSurface UV Points\n    \"\"\"\n    self.save_shapes_to_occ_native(\n        filename, \n        [ self ],\n        with_triangles=with_triangles,\n        with_normals=with_normals,\n        format_version=format_version\n    )\n</code></pre>"},{"location":"api/#occwl.compound.Compound.scale","title":"<code>scale(scale_vector)</code>","text":"<p>Scale the shape by the given 3D vector</p> <p>Parameters:</p> Name Type Description Default <code>scale_vector</code> <code>ndarray</code> <p>3D array with scales to resize the shape along the x-axis, y-axis and z-axis respectively</p> required Source code in <code>src/occwl/shape.py</code> <pre><code>def scale(self, scale_vector):\n    \"\"\"\n    Scale the shape by the given 3D vector\n\n    Args:\n        scale_vector (np.ndarray): 3D array with scales to resize the shape along the x-axis, y-axis and z-axis respectively\n    \"\"\"\n    self._shape = scale_shape(\n        self._shape, scale_vector[0], scale_vector[1], scale_vector[2]\n    )\n</code></pre>"},{"location":"api/#occwl.compound.Compound.scale_to_box","title":"<code>scale_to_box(box_side, copy=True)</code>","text":"<p>Translate and scale the Shape so it fits exactly  into the [-box_side, box_side]^3 box</p> <p>Returns:</p> Type Description <p>occwl..: The scaled version of this Shape</p> Source code in <code>src/occwl/base.py</code> <pre><code>def scale_to_box(self, box_side, copy=True):\n    \"\"\"\n    Translate and scale the Shape so it fits exactly \n    into the [-box_side, box_side]^3 box\n\n    Args:\n        box_side (float) The side length of the box\n        copy (bool)      True - Copy entities and apply the transform to\n                                the underlying geometry\n                         False - Apply the transform to the topods Locator\n                                 if possible \n\n    Returns:\n        occwl.*.*: The scaled version of this Shape\n    \"\"\"\n    from occwl.geometry import geom_utils\n    # Get an exact box for the Shape\n    box = self.exact_box()\n    center = box.center()\n    longest_length = box.max_box_length()\n\n    orig = gp_Pnt(0.0, 0.0, 0.0)\n    center = geom_utils.numpy_to_gp(center)\n    vec_center_to_orig = gp_Vec(center, orig)\n    move_to_center = gp_Trsf()\n    move_to_center.SetTranslation(vec_center_to_orig)\n\n    scale_trsf = gp_Trsf()\n    scale_trsf.SetScale(orig, (2.0 * box_side) / longest_length)\n    trsf_to_apply = scale_trsf.Multiplied(move_to_center)\n\n    return self._apply_transform(trsf_to_apply, copy=copy)\n</code></pre>"},{"location":"api/#occwl.compound.Compound.scale_to_unit_box","title":"<code>scale_to_unit_box(copy=True)</code>","text":"<p>Translate and scale the Shape so it fits exactly  into the [-1, 1]^3 box</p> <p>Returns:     The scaled version of this shape</p> Source code in <code>src/occwl/base.py</code> <pre><code>def scale_to_unit_box(self, copy=True):\n    \"\"\"\n    Translate and scale the Shape so it fits exactly \n    into the [-1, 1]^3 box\n\n    Args:\n        copy (bool)      True - Copy entities and apply the transform to\n                                    the underlying geometry\n                            False - Apply the transform to the topods Locator\n                                    if possible \n    Returns:\n        The scaled version of this shape\n    \"\"\"\n    return self.scale_to_box(1.0, copy=copy)\n</code></pre>"},{"location":"api/#occwl.compound.Compound.set_transform_to_identity","title":"<code>set_transform_to_identity()</code>","text":"<p>When an assembly is loaded from a STEP file the solids will be transformed relative to their local coordinate system.   i.e. they are placed in the assembly root components  coordinate system.</p> <p>When working with individual bodies you often want them to be axis aligned, in which case  you want to remove the assembly transform. This function removes it for you.</p> <p>If however you want to bake the transform into the bodies and suppress the asserts  from parts of occwl which don't cope with transforms then use the transform() function below with copy=True</p> Source code in <code>src/occwl/shape.py</code> <pre><code>def set_transform_to_identity(self):\n    \"\"\"\n    When an assembly is loaded from a STEP file\n    the solids will be transformed relative to\n    their local coordinate system.   i.e. they\n    are placed in the assembly root components \n    coordinate system.\n\n    When working with individual bodies you often\n    want them to be axis aligned, in which case \n    you want to remove the assembly transform.\n    This function removes it for you.\n\n    If however you want to bake the transform\n    into the bodies and suppress the asserts \n    from parts of occwl which don't cope with\n    transforms then use the transform() function\n    below with copy=True\n    \"\"\"\n    identity = TopLoc_Location()\n    self.topods_shape().Location(identity)\n    self._top_exp = TopologyUtils.TopologyExplorer(self.topods_shape(), True)\n    self.convert_geometric_identity_transforms_to_identity()\n</code></pre>"},{"location":"api/#occwl.compound.Compound.shells","title":"<code>shells()</code>","text":"<p>Get an iterator to go over all shells in the Shape</p> <p>Returns:</p> Type Description <p>Iterator[occwl.shell.Shell]: Shell iterator</p> Source code in <code>src/occwl/base.py</code> <pre><code>def shells(self):\n    \"\"\"\n    Get an iterator to go over all shells in the Shape\n\n    Returns:\n        Iterator[occwl.shell.Shell]: Shell iterator\n    \"\"\"\n    from occwl.shell import Shell\n    return map(Shell, self._top_exp.shells())\n</code></pre>"},{"location":"api/#occwl.compound.Compound.solids","title":"<code>solids()</code>","text":"<p>Get an iterator to go over all solids in the Compound</p> <p>Returns:</p> Type Description <p>Iterator[occwl.solid.Solid]: Solid iterator</p> Source code in <code>src/occwl/base.py</code> <pre><code>def solids(self):\n    \"\"\"\n    Get an iterator to go over all solids in the Compound\n\n    Returns:\n        Iterator[occwl.solid.Solid]: Solid iterator\n    \"\"\"\n    from occwl.solid import Solid\n    return map(Solid, self._top_exp.solids())\n</code></pre>"},{"location":"api/#occwl.compound.Compound.split_all_closed_edges","title":"<code>split_all_closed_edges(max_tol=0.01, precision=0.01, num_splits=1)</code>","text":"<p>Split all the closed edges in this shape</p> <p>Parameters:</p> Name Type Description Default <code>max_tol</code> <code>float</code> <p>Maximum tolerance allowed. Defaults to 0.01.</p> <code>0.01</code> <code>precision</code> <code>float</code> <p>Precision of the tool when splitting. Defaults to 0.01.</p> <code>0.01</code> <code>num_splits</code> <code>int</code> <p>Number of splits to perform. Each split edge will result in num_splits + 1 edges. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Type Description <p>occwl..: Shape with closed edges split</p> Source code in <code>src/occwl/base.py</code> <pre><code>def split_all_closed_edges(self, max_tol=0.01, precision=0.01, num_splits=1):\n    \"\"\"\n    Split all the closed edges in this shape\n\n    Args:\n        max_tol (float, optional): Maximum tolerance allowed. Defaults to 0.01.\n        precision (float, optional): Precision of the tool when splitting. Defaults to 0.01.\n        num_splits (int, optional): Number of splits to perform. Each split edge will result in num_splits + 1 edges. Defaults to 1.\n\n    Returns:\n        occwl.*.*: Shape with closed edges split\n    \"\"\"\n    divider = ShapeUpgrade_ShapeDivideClosedEdges(self.topods_shape())\n    divider.SetPrecision(precision)\n    divider.SetMinTolerance(0.1 * max_tol)\n    divider.SetMaxTolerance(max_tol)\n    divider.SetNbSplitPoints(num_splits)\n    ok = divider.Perform()\n    if not ok:\n        # Splitting failed or there were no closed edges to split\n        # Return the original shape\n        return self\n    return type(self)(divider.Result())\n</code></pre>"},{"location":"api/#occwl.compound.Compound.split_all_closed_faces","title":"<code>split_all_closed_faces(max_tol=0.01, precision=0.01, num_splits=1)</code>","text":"<p>Split all the closed faces in this shape</p> <p>Parameters:</p> Name Type Description Default <code>max_tol</code> <code>float</code> <p>Maximum tolerance allowed. Defaults to 0.01.</p> <code>0.01</code> <code>precision</code> <code>float</code> <p>Precision of the tool when splitting. Defaults to 0.01.</p> <code>0.01</code> <code>num_splits</code> <code>int</code> <p>Number of splits to perform. Each split face will result in num_splits + 1 faces. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Type Description <p>occwl..: Shape with closed faces split</p> Source code in <code>src/occwl/base.py</code> <pre><code>def split_all_closed_faces(self, max_tol=0.01, precision=0.01, num_splits=1):\n    \"\"\"\n    Split all the closed faces in this shape\n\n    Args:\n        max_tol (float, optional): Maximum tolerance allowed. Defaults to 0.01.\n        precision (float, optional): Precision of the tool when splitting. Defaults to 0.01.\n        num_splits (int, optional): Number of splits to perform. Each split face will result in num_splits + 1 faces. Defaults to 1.\n\n    Returns:\n        occwl.*.*: Shape with closed faces split\n    \"\"\"\n    divider = ShapeUpgrade_ShapeDivideClosed(self.topods_shape())\n    divider.SetPrecision(precision)\n    divider.SetMinTolerance(0.1 * max_tol)\n    divider.SetMaxTolerance(max_tol)\n    divider.SetNbSplitPoints(num_splits)\n    ok = divider.Perform()\n    if not ok:\n        # Splitting failed or there were no closed faces to split\n        # Return the original shape\n        return self\n    return type(self)(divider.Result())\n</code></pre>"},{"location":"api/#occwl.compound.Compound.topods_shape","title":"<code>topods_shape()</code>","text":"<p>Get the underlying OCC shape</p> <p>Returns:</p> Type Description <p>OCC.Core.TopoDS.TopoDS_Vertex/Edge/Face/Wire/Shell/Solid: OCC TopoDS_*</p> Source code in <code>src/occwl/shape.py</code> <pre><code>def topods_shape(self):\n    \"\"\"\n    Get the underlying OCC shape\n\n    Returns:\n        OCC.Core.TopoDS.TopoDS_Vertex/Edge/Face/Wire/Shell/Solid: OCC TopoDS_*\n    \"\"\"\n    return self._shape\n</code></pre>"},{"location":"api/#occwl.compound.Compound.transform","title":"<code>transform(a, copy=True)</code>","text":"<p>Apply the given 3x4 transform matrix to the solid.</p> <pre><code> copy (bool)    True - Copy entities and apply the transform to\n                       the underlying geometry\n                False - Apply the transform to the topods Locator\n                        if possible\n</code></pre> Source code in <code>src/occwl/shape.py</code> <pre><code>def transform(self, a: np.ndarray, copy=True):\n    \"\"\"\n    Apply the given 3x4 transform matrix to the solid.\n\n    Args: a (nd.array) - Homogeneous transform matrix\n                         The transform that will be applied is\n\n                         x' =  a[0,0]*x + a[0,1]*y + a[0,2]*z + a[0, 3]\n                         y' =  a[1,0]*x + a[1,1]*y + a[1,2]*z + a[1, 3]\n                         z' =  a[2,0]*x + a[2,1]*y + a[2,2]*z + a[2, 3]\n\n         copy (bool)    True - Copy entities and apply the transform to\n                               the underlying geometry\n                        False - Apply the transform to the topods Locator\n                                if possible \n    \"\"\"\n    assert (a.shape == (3, 4)), \"Transform matrix must be 3x4\"\n    a = a.astype(np.float64)\n\n    # Create an identity transform\n    trsf = gp_Trsf()\n\n    # If the matrix is an identity matrix then\n    # we don't want to set the values as this\n    # would give us a geometric identity without\n    # the identity flag set\n    if not np.allclose(a, np.eye(3, 4)):\n        trsf.SetValues(\n            a[0,0], a[0,1], a[0,2], a[0, 3],\n            a[1,0], a[1,1], a[1,2], a[1, 3],\n            a[2,0], a[2,1], a[2,2], a[2, 3]\n        )\n    return self._apply_transform(trsf, copy=copy)\n</code></pre>"},{"location":"api/#occwl.compound.Compound.translate","title":"<code>translate(offset)</code>","text":"<p>Translate the shape by an offset vector</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>ndarray</code> <p>Offset vector</p> required Source code in <code>src/occwl/shape.py</code> <pre><code>def translate(self, offset):\n    \"\"\"\n    Translate the shape by an offset vector\n\n    Args:\n        offset (np.ndarray): Offset vector\n    \"\"\"\n    self._shape = translate_shp(self._shape, geom_utils.numpy_to_gp_vec(offset))\n</code></pre>"},{"location":"api/#occwl.compound.Compound.triangulate","title":"<code>triangulate(triangle_face_tol=0.01, tol_relative_to_face=True, angle_tol_rads=0.1)</code>","text":"<p>Triangulate all the faces in the shape. You can then get the triangles  from each face separately using face.get_triangles(). If you wanted triangles for the entire shape then call shape.get_triangles() below. For more details see  https://old.opencascade.com/doc/occt-7.1.0/overview/html/occt_user_guides__modeling_algos.html#occt_modalg_11</p> <p>Parameters:</p> Name Type Description Default <code>triangle_face_tol</code> <code>float</code> <p>Tolerance between triangle and surface. Defaults to 0.01.</p> <code>0.01</code> <code>tol_relative_to_face</code> <code>bool</code> <p>Whether tolerance is relative to face size</p> <code>True</code> <code>angle_tol_rads</code> <code>float</code> <p>Angle tolerance in radians. Defaults to 0.1.</p> <code>0.1</code> <p>Returns:</p> Name Type Description <code>bool</code> <p>Is successful</p> Source code in <code>src/occwl/base.py</code> <pre><code>def triangulate(\n    self,\n    triangle_face_tol=0.01,  # Tolerance between triangle and surface\n    tol_relative_to_face=True,  # The tolerance value is relative to the face size\n    angle_tol_rads=0.1,  # Angle between normals/tangents at triangle vertices\n):\n    \"\"\"\n    Triangulate all the faces in the shape. You can then get the triangles \n    from each face separately using face.get_triangles().\n    If you wanted triangles for the entire shape then call\n    shape.get_triangles() below.\n    For more details see \n    https://old.opencascade.com/doc/occt-7.1.0/overview/html/occt_user_guides__modeling_algos.html#occt_modalg_11\n\n    Args:\n        triangle_face_tol (float, optional): Tolerance between triangle and surface. Defaults to 0.01.\n        tol_relative_to_face (bool): Whether tolerance is relative to face size\n        angle_tol_rads (float, optional): Angle tolerance in radians. Defaults to 0.1.\n\n    Returns:\n        bool: Is successful\n    \"\"\"\n    mesh = BRepMesh_IncrementalMesh(\n        self.topods_shape(),\n        triangle_face_tol,\n        tol_relative_to_face,\n        angle_tol_rads,\n        True,\n    )\n    mesh.Perform()\n    return mesh.IsDone()\n</code></pre>"},{"location":"api/#occwl.compound.Compound.valid","title":"<code>valid(return_analyzer=False)</code>","text":"<p>Check if the shape is valid</p> <p>Parameters:</p> Name Type Description Default <code>return_analyzer</code> <code>bool</code> <p>Whether to return the BRepCheck_Analyzer object for more inspection</p> <code>False</code> <p>Returns:</p> Name Type Description <code>bool</code> <p>Whether the shape is valid</p> <p>BRepCheck_Analyzer [optional]: if return_analyzer is True</p> Source code in <code>src/occwl/shape.py</code> <pre><code>def valid(self, return_analyzer=False):\n    \"\"\"\n    Check if the shape is valid\n\n    Args:\n        return_analyzer (bool): Whether to return the BRepCheck_Analyzer object for more inspection\n\n    Returns:\n        bool: Whether the shape is valid\n        BRepCheck_Analyzer [optional]: if return_analyzer is True\n    \"\"\"\n    analyzer = BRepCheck_Analyzer(self.topods_shape())\n    if return_analyzer:\n        return analyzer.IsValid(), analyzer\n    return analyzer.IsValid()\n</code></pre>"},{"location":"api/#occwl.compound.Compound.vertices","title":"<code>vertices()</code>","text":"<p>Get an iterator to go over all vertices in the Shape</p> <p>Returns:</p> Type Description <p>Iterator[occwl.vertex.Vertex]: Vertex iterator</p> Source code in <code>src/occwl/base.py</code> <pre><code>def vertices(self):\n    \"\"\"\n    Get an iterator to go over all vertices in the Shape\n\n    Returns:\n        Iterator[occwl.vertex.Vertex]: Vertex iterator\n    \"\"\"\n    from occwl.vertex import Vertex\n    return map(Vertex, self._top_exp.vertices())\n</code></pre>"},{"location":"api/#occwl.compound.Compound.vertices_from_edge","title":"<code>vertices_from_edge(edge)</code>","text":"<p>Get an iterator to go over the vertices bounding an edge</p> <p>Parameters:</p> Name Type Description Default <code>edge</code> <code>Edge</code> <p>Input edge</p> required <p>Returns:</p> Type Description <p>Iterator[occwl.vertex.Vertex]: Vertex iterator</p> Source code in <code>src/occwl/base.py</code> <pre><code>def vertices_from_edge(self, edge):\n    \"\"\"\n    Get an iterator to go over the vertices bounding an edge\n\n    Args:\n        edge (occwl.edge.Edge): Input edge\n\n    Returns:\n        Iterator[occwl.vertex.Vertex]: Vertex iterator\n    \"\"\"\n    from occwl.vertex import Vertex\n    from occwl.edge import Edge\n    assert isinstance(edge, Edge)\n    return map(Vertex, self._top_exp.vertices_from_edge(edge.topods_shape()))\n</code></pre>"},{"location":"api/#occwl.compound.Compound.vertices_from_face","title":"<code>vertices_from_face(face)</code>","text":"<p>Get an iterator to go over the vertices in a face</p> <p>Parameters:</p> Name Type Description Default <code>face</code> <code>Face</code> <p>Input face</p> required <p>Returns:</p> Type Description <p>Iterator[occwl.vertex.Vertex]: Vertex iterator</p> Source code in <code>src/occwl/base.py</code> <pre><code>def vertices_from_face(self, face):\n    \"\"\"\n    Get an iterator to go over the vertices in a face\n\n    Args:\n        face (occwl.face.Face): Input face\n\n    Returns:\n        Iterator[occwl.vertex.Vertex]: Vertex iterator\n    \"\"\"\n    from occwl.vertex import Vertex\n    from occwl.face import Face\n    assert isinstance(face, Face)\n    return map(Vertex, self._top_exp.vertices_from_face(face.topods_shape()))\n</code></pre>"},{"location":"api/#occwl.compound.Compound.volume","title":"<code>volume(tolerance=1e-09)</code>","text":"<p>Compute the volume of the Shape</p> <p>Parameters:</p> Name Type Description Default <code>tolerance</code> <code>float</code> <p>Tolerance. Defaults to 1e-9.</p> <code>1e-09</code> <p>Returns:</p> Name Type Description <code>float</code> <p>Volume</p> Source code in <code>src/occwl/base.py</code> <pre><code>def volume(self, tolerance=1e-9):\n    \"\"\"\n    Compute the volume of the Shape\n\n    Args:\n        tolerance (float, optional): Tolerance. Defaults to 1e-9.\n\n    Returns:\n        float: Volume\n    \"\"\"\n    props = GProp_GProps()\n    brepgprop_VolumeProperties(self.topods_shape(), props, tolerance)\n    return props.Mass()\n</code></pre>"},{"location":"api/#occwl.compound.Compound.wires","title":"<code>wires()</code>","text":"<p>Get an iterator to go over all wires in the Shape</p> <p>Returns:</p> Type Description <p>Iterator[occwl.wire.Wire]: Wire iterator</p> Source code in <code>src/occwl/base.py</code> <pre><code>def wires(self):\n    \"\"\"\n    Get an iterator to go over all wires in the Shape\n\n    Returns:\n        Iterator[occwl.wire.Wire]: Wire iterator\n    \"\"\"\n    from occwl.wire import Wire\n    return map(Wire, self._top_exp.wires())\n</code></pre>"},{"location":"api/#occwl.compound.Compound.wires_from_face","title":"<code>wires_from_face(face)</code>","text":"<p>Get an iterator to go over the wires bounding a face</p> <p>Parameters:</p> Name Type Description Default <code>face</code> <code>Face</code> <p>Input face</p> required <p>Returns:</p> Type Description <p>Iterator[occwl.wire.Wire]: Wire iterator</p> Source code in <code>src/occwl/base.py</code> <pre><code>def wires_from_face(self, face):\n    \"\"\"\n    Get an iterator to go over the wires bounding a face\n\n    Args:\n        face (occwl.face.Face): Input face\n\n    Returns:\n        Iterator[occwl.wire.Wire]: Wire iterator\n    \"\"\"\n    from occwl.wire import Wire\n    from occwl.face import Face\n    assert isinstance(face, Face)\n    return map(Wire, self._top_exp.wires_from_face(face.topods_shape()))\n</code></pre>"},{"location":"api/#occwl.edge","title":"<code>edge</code>","text":""},{"location":"api/#occwl.edge.Edge","title":"<code>Edge</code>","text":"<p>               Bases: <code>Shape</code>, <code>VertexContainerMixin</code>, <code>BoundingBoxMixin</code></p> <p>A topological edge in a solid model Represents a 3D curve bounded by vertices</p> Source code in <code>src/occwl/edge.py</code> <pre><code>class Edge(Shape, VertexContainerMixin, BoundingBoxMixin):\n    \"\"\"\n    A topological edge in a solid model\n    Represents a 3D curve bounded by vertices\n    \"\"\"\n\n    def __init__(self, topods_edge):\n        assert isinstance(topods_edge, TopoDS_Edge)\n        super().__init__(topods_edge)\n\n    @staticmethod\n    def make_line_from_points(start_point, end_point):\n        \"\"\"\n        Make an edge from two given points\n\n        Args:\n            start_point (np.ndarray 3D vector): Starting point\n            end_point (np.ndarray 3D vector): Ending point\n\n        Returns:\n            occwl.Edge: Edge joining the two given vertices\n            or None: if error\n        \"\"\"\n        edge_builder = BRepBuilderAPI_MakeEdge(geom_utils.to_gp_pnt(start_point), geom_utils.to_gp_pnt(end_point))\n        if not edge_builder.IsDone():\n            return None\n        return Edge(edge_builder.Edge())\n\n    @staticmethod\n    def make_line_from_vertices(start_vertex, end_vertex):\n        \"\"\"\n        Make an edge from two given vertices\n\n        Args:\n            start_vertex (occwl.vertex.Vertex): Starting vertex\n            end_vertex (occwl.vertex.Vertex): Ending vertex\n\n        Returns:\n            occwl.Edge: Edge joining the two given vertices\n            or None: if error\n        \"\"\"\n        edge_builder = BRepBuilderAPI_MakeEdge(start_vertex.topods_shape(), end_vertex.topods_shape())\n        if not edge_builder.IsDone():\n            return None\n        return Edge(edge_builder.Edge())\n\n    @staticmethod\n    def make_circle(center, radius, direction=(0, 0, 1)):\n        \"\"\"\n        Make a circular edge\n\n        Args:\n            center (np.ndarray or list or tuple with 3D point): Center of the circle\n            radius (float): Radius of the circle\n            direction (np.ndarray or list or tuple with 3D unit vector, optional): Normal of the circle's face. Defaults to (0, 0, 1).\n\n        Returns:\n            occwl.edge.Edge: Edge\n            or None: if error\n        \"\"\"\n        circle = gp_Circ(\n            gp_Ax2(geom_utils.to_gp_pnt(center), geom_utils.to_gp_dir(direction)),\n            float(radius),\n        )\n        edge_builder = BRepBuilderAPI_MakeEdge(circle)\n        if not edge_builder.IsDone():\n            return None\n        return Edge(edge_builder.Edge())\n\n    @staticmethod\n    def make_arc_of_circle(pt1, pt2, pt3):\n        \"\"\"\n        Make an arc edge\n\n        Args:\n            pt1 (np.ndarray or list or tuple with 3D point): Start point\n            pt2 (np.ndarray or list or tuple with 3D point): Mid (not necessarily at the middle) point\n            pt3 (np.ndarray or list or tuple with 3D point): End point\n\n        Returns:\n            occwl.edge.Edge: Edge\n            or None: if error\n        \"\"\"\n        arc = GC_MakeArcOfCircle(geom_utils.to_gp_pnt(pt1), geom_utils.to_gp_pnt(pt2), geom_utils.to_gp_pnt(pt3)).Value()\n        edge_builder = BRepBuilderAPI_MakeEdge(arc)\n        if not edge_builder.IsDone():\n            return None\n        return Edge(edge_builder.Edge())\n\n    def point(self, u):\n        \"\"\"\n        Evaluate the edge geometry at given parameter\n\n        Args:\n            u (float): Curve parameter\n\n        Returns:\n            np.ndarray: 3D Point\n        \"\"\"\n        if self.has_curve():\n            pt = self.curve().Value(u)\n            return geom_utils.gp_to_numpy(pt)\n        # If the edge has no curve then return a point\n        # at the origin.\n        # It would ne nice to return the location of the\n        # vertex\n        return np.array([0, 0, 0])\n\n    def start_vertex(self):\n        \"\"\"\n        Returns the starting vertex of the edge while considering the edge orientation\n\n        Returns:\n            occwl.vertex.Vertex: Start vertex\n        \"\"\"\n        return occwl.vertex.Vertex(ShapeAnalysis_Edge().FirstVertex(self.topods_shape()))\n\n    def end_vertex(self):\n        \"\"\"\n        Returns the ending vertex of the edge while considering the edge orientation\n\n        Returns:\n            occwl.vertex.Vertex: End vertex\n        \"\"\"\n        return occwl.vertex.Vertex(ShapeAnalysis_Edge().LastVertex(self.topods_shape()))\n\n    def tangent(self, u):\n        \"\"\"\n        Compute the tangent of the edge geometry at given parameter\n\n        Args:\n            u (float): Curve parameter\n\n        Returns:\n            np.ndarray: 3D unit vector\n        \"\"\"\n        if self.has_curve():\n            pt = gp_Pnt()\n            der = gp_Vec()\n            self.curve().D1(u, pt, der)\n            der.Normalize()\n            tangent = geom_utils.gp_to_numpy(der)\n            if self.reversed():\n                tangent = -tangent\n            return tangent\n        # If the edge has no curve then return\n        # a zero vector\n        return np.array([0, 0, 0])\n\n    def first_derivative(self, u):\n        \"\"\"\n        Compute the first derivative of the edge geometry at given parameter\n\n        Args:\n            u (float): Curve parameter\n\n        Returns:\n            np.ndarray: 3D vector\n        \"\"\"\n        if self.has_curve():\n            pt = gp_Pnt()\n            der = gp_Vec()\n            self.curve().D1(u, pt, der)\n            return geom_utils.gp_to_numpy(der)\n        # If the edge has no curve then return\n        # a zero vector\n        return np.array([0, 0, 0])\n\n    def length(self):\n        \"\"\"\n        Compute the length of the edge curve\n\n        Returns:\n            float: Length of the edge curve\n        \"\"\"\n        if not self.has_curve():\n            return 0.0\n        geometry_properties = GProp_GProps()\n        brepgprop_LinearProperties(self.topods_shape(), geometry_properties)\n        return geometry_properties.Mass()\n\n    def curve(self):\n        \"\"\"\n        Get the edge curve geometry\n\n        Returns:\n            OCC.Geom.Handle_Geom_Curve: Interface to all curve geometry\n        \"\"\"\n        return BRep_Tool_Curve(self.topods_shape())[0]\n\n    def specific_curve(self):\n        \"\"\"\n        Get the specific edge curve geometry\n\n        Returns:\n            OCC.Geom.Handle_Geom_*: Specific geometry type for the curve geometry\n                                    or None if the curve type is GeomAbs_OtherCurve\n        \"\"\"\n        brep_adaptor_curve = BRepAdaptor_Curve(self.topods_shape())\n        curv_type = brep_adaptor_curve.GetType()\n        if curv_type == GeomAbs_Line:\n            return brep_adaptor_curve.Line()\n        if curv_type == GeomAbs_Circle:\n            return brep_adaptor_curve.Circle()\n        if curv_type == GeomAbs_Ellipse:\n            return brep_adaptor_curve.Ellipse()\n        if curv_type == GeomAbs_Hyperbola:\n            return brep_adaptor_curve.Hyperbola()\n        if curv_type == GeomAbs_Parabola:\n            return brep_adaptor_curve.Parabola()\n        if curv_type == GeomAbs_BezierCurve:\n            return brep_adaptor_curve.Bezier()\n        if curv_type == GeomAbs_BSplineCurve:\n            return brep_adaptor_curve.BSpline()\n        if curv_type == GeomAbs_OffsetCurve:\n            return brep_adaptor_curve.OffsetCurve()\n        return None\n\n    def has_curve(self):\n        \"\"\"\n        Does this edge have a valid curve?\n        Some edges don't.  For example the edge at the pole of a sphere.\n\n        Returns:\n            bool: Whether this edge has a valid curve\n        \"\"\"\n        curve = BRepAdaptor_Curve(self.topods_shape())\n        return curve.Is3DCurve()\n\n    def u_bounds(self):\n        \"\"\"\n        Parameter domain of the curve\n\n        Returns:\n            occwl.geometry.Interval: a 1D interval [u_min, u_max]\n        \"\"\"\n        if not self.has_curve():\n            # Return an empty interval\n            return Interval()\n        _, umin, umax = BRep_Tool_Curve(self.topods_shape())\n        return Interval(umin, umax)\n\n    def reversed_edge(self):\n        \"\"\"\n        Return a copy of this edge with the orientation reversed.\n\n        Returns:\n            occwl.edge.Edge: An edge with the opposite orientation to this edge.\n        \"\"\"\n        return Edge(self.topods_shape().Reversed())\n\n    def closed_curve(self):\n        \"\"\"\n        Returns whether the 3D curve of this edge is closed.\n        i.e. the start and edge points are coincident.\n\n        Returns:\n            bool: If closed\n        \"\"\"\n        return self.curve().IsClosed()\n\n    def closed_edge(self):\n        \"\"\"\n        Returns whether the edge forms a closed ring.  i.e.\n        whether the start and end vertices are the same.\n\n        Returns:\n            bool: If closed\n        \"\"\"\n        return BRep_Tool().IsClosed(self.topods_shape())\n\n    def seam(self, face):\n        \"\"\"\n        Whether this edge is a seam\n\n        Args:\n            face (occwl.face.Face): Face where the edge lives\n\n        Returns:\n            bool: If seam\n        \"\"\"\n        return ShapeAnalysis_Edge().IsSeam(self.topods_shape(), face.topods_shape())\n\n    def has_pcurve(self, face):\n        \"\"\"\n        Whether this edge has a pcurve associated to the given face\n\n        Args:\n            face (occwl.face.Face): Face\n\n        Returns:\n            bool: If pcurve exists\n        \"\"\"\n        return ShapeAnalysis_Edge().HasPCurve(self.topods_shape(), face.topods_shape())\n\n    def periodic(self):\n        \"\"\"\n        Whether this edge is periodic\n\n        Returns:\n            bool: If periodic\n        \"\"\"\n        return BRepAdaptor_Curve(self.topods_shape()).IsPeriodic()\n\n    def rational(self):\n        \"\"\"\n        Whether this edge geometry is rational\n\n        Returns:\n            bool: If rational\n        \"\"\"\n        return BRepAdaptor_Curve(self.topods_shape()).IsRational()\n\n    def continuity(self, face1, face2):\n        \"\"\"\n        Get the order of continuity among a pair of faces\n\n        Args:\n            face1 (occwl.face.Face): First face\n            face2 (occwl.face.Face): Second face\n\n        Returns:\n            GeomAbs_Shape: enum describing the continuity order\n        \"\"\"\n        return BRep_Tool_Continuity(\n            self.topods_shape(), face1.topods_shape(), face2.topods_shape()\n        )\n\n\n    def curve_type(self):\n        \"\"\"\n        Get the type of the curve geometry\n\n        Returns:\n            str: Type of the curve geometry\n        \"\"\"\n        curv_type = BRepAdaptor_Curve(self.topods_shape()).GetType()\n        if curv_type == GeomAbs_Line:\n            return \"line\"\n        if curv_type == GeomAbs_Circle:\n            return \"circle\"\n        if curv_type == GeomAbs_Ellipse:\n            return \"ellipse\"\n        if curv_type == GeomAbs_Hyperbola:\n            return \"hyperbola\"\n        if curv_type == GeomAbs_Parabola:\n            return \"parabola\"\n        if curv_type == GeomAbs_BezierCurve:\n            return \"bezier\"\n        if curv_type == GeomAbs_BSplineCurve:\n            return \"bspline\"\n        if curv_type == GeomAbs_OffsetCurve:\n            return \"offset\"\n        if curv_type == GeomAbs_OtherCurve:\n            return \"other\"\n        return \"unknown\"\n\n    def curve_type_enum(self):\n        \"\"\"\n        Get the type of the curve geometry as an OCC.Core.GeomAbs enum\n\n        Returns:\n            OCC.Core.GeomAbs: Type of the curve geometry\n        \"\"\"\n        return BRepAdaptor_Curve(self.topods_shape()).GetType()\n\n    def tolerance(self):\n        \"\"\"\n        Get tolerance of this edge.  The 3d curve of the edge should not\n        deviate from the surfaces of adjacent faces by more than this value\n\n        Returns:\n            float The edge tolerance\n        \"\"\"\n        return BRep_Tool().Tolerance(self.topods_shape())\n\n    def find_left_and_right_faces(self, faces):\n        \"\"\"\n        Given a list of 1 or 2 faces which are adjacent to this edge,\n        we want to return the left and right face when looking from \n        outside the solid.\n\n                      Edge direction\n                            ^\n                            |   \n                  Left      |   Right \n                  face      |   face\n                            |\n\n        In the case of a cylinder the left and right face will be\n        the same.\n\n        Args:\n            faces (list(occwl.face.Face): The faces\n\n        Returns:\n            occwl.face.Face, occwl.face.Face: The left and then right face\n            or \n            None, None if the left and right faces cannot be found\n        \"\"\"\n        assert len(faces) &gt; 0\n        face1 = faces[0]\n        if len(faces) == 1:\n            face2 = faces[0]\n        else:\n            face2 = faces[1]\n\n        if face1.is_left_of(self):\n            # In some cases (like a cylinder) the left and right faces\n            # of the edge are the same face\n            if face1 != face2:\n                if face2.is_left_of(self):\n                    return None, None\n            left_face = face1\n            right_face = face2\n        else:\n            if not face2.is_left_of(self):\n                return None, None\n            left_face = face2\n            right_face = face1\n\n        return left_face, right_face\n\n    def get_polyline(self, deflection=0.0005, algorithm=\"QuasiUniformDeflection\"):\n        \"\"\"\n        Get a polyline, represented as a sequence of points, from this edge\n\n        Args:\n            deflection (float): Lower deflection results in more precision\n                                and therefore more points\n            algorithm (string): Algorithm to use, can be one of:\n                                QuasiUniformDeflection, UniformAbscissa,\n                                or UniformDeflection\n\n        Returns:\n            2D np.ndarray: Points\n        \"\"\"\n        # If we don't have a valid curve, return an empty array\n        if not self.has_curve():\n            return np.empty(shape=(0,3), dtype=np.float32)\n\n        curve_adaptor = BRepAdaptor_Curve(self.topods_shape())\n        first_param = curve_adaptor.FirstParameter()\n        last_param = curve_adaptor.LastParameter()\n\n        if algorithm == \"QuasiUniformDeflection\":\n            discretizer = GCPnts_QuasiUniformDeflection()\n        elif algorithm == \"UniformAbscissa\":\n            discretizer = GCPnts_UniformAbscissa()\n        elif algorithm == \"UniformDeflection\":\n            discretizer = GCPnts_UniformDeflection()\n        else:\n            raise Exception(\"Unknown algorithm\")\n        discretizer.Initialize(curve_adaptor, deflection, first_param, last_param)\n\n        if not discretizer.IsDone():\n            raise Exception(\"Discretizer not done.\")\n        if not discretizer.NbPoints() &gt; 0:\n            raise Exception(\"Discretizer nb points not &gt; 0.\")\n\n        points = []\n        for i in range(1, discretizer.NbPoints() + 1):\n            p = curve_adaptor.Value(discretizer.Parameter(i))\n            points.append(np.array(list(p.Coord())))\n        return np.asarray(points, dtype=np.float32)\n</code></pre>"},{"location":"api/#occwl.edge.Edge.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Equality check for the shape</p> <p>NOTE: This function only checks if the shape is the same. It doesn't check the edge orienation for example, so </p> <p>edge1 == edge2</p> <p>does not necessarily mean </p> <p>edge1.reversed() == edge2.reversed()</p> Source code in <code>src/occwl/shape.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"\n    Equality check for the shape\n\n    NOTE: This function only checks if the shape is the same.\n    It doesn't check the edge orienation for example, so \n\n    edge1 == edge2\n\n    does not necessarily mean \n\n    edge1.reversed() == edge2.reversed()\n    \"\"\"\n    return self.topods_shape().__hash__() == other.topods_shape().__hash__()\n</code></pre>"},{"location":"api/#occwl.edge.Edge.__hash__","title":"<code>__hash__()</code>","text":"<p>Hash for the shape</p> <p>Returns:</p> Name Type Description <code>int</code> <p>Hash value</p> Source code in <code>src/occwl/shape.py</code> <pre><code>def __hash__(self):\n    \"\"\"\n    Hash for the shape\n\n    Returns:\n        int: Hash value\n    \"\"\"\n    return self.topods_shape().__hash__()\n</code></pre>"},{"location":"api/#occwl.edge.Edge.box","title":"<code>box()</code>","text":"<p>Get a quick bounding box of the Shape</p> <p>Returns:</p> Name Type Description <code>Box</code> <p>Bounding box</p> Source code in <code>src/occwl/base.py</code> <pre><code>def box(self):\n    \"\"\"\n    Get a quick bounding box of the Shape\n\n    Returns:\n        Box: Bounding box\n    \"\"\"\n    from occwl.geometry import geom_utils\n    b = Bnd_Box()\n    brepbndlib_Add(self.topods_shape(), b)\n    return geom_utils.box_to_geometry(b)\n</code></pre>"},{"location":"api/#occwl.edge.Edge.closed_curve","title":"<code>closed_curve()</code>","text":"<p>Returns whether the 3D curve of this edge is closed. i.e. the start and edge points are coincident.</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>If closed</p> Source code in <code>src/occwl/edge.py</code> <pre><code>def closed_curve(self):\n    \"\"\"\n    Returns whether the 3D curve of this edge is closed.\n    i.e. the start and edge points are coincident.\n\n    Returns:\n        bool: If closed\n    \"\"\"\n    return self.curve().IsClosed()\n</code></pre>"},{"location":"api/#occwl.edge.Edge.closed_edge","title":"<code>closed_edge()</code>","text":"<p>Returns whether the edge forms a closed ring.  i.e. whether the start and end vertices are the same.</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>If closed</p> Source code in <code>src/occwl/edge.py</code> <pre><code>def closed_edge(self):\n    \"\"\"\n    Returns whether the edge forms a closed ring.  i.e.\n    whether the start and end vertices are the same.\n\n    Returns:\n        bool: If closed\n    \"\"\"\n    return BRep_Tool().IsClosed(self.topods_shape())\n</code></pre>"},{"location":"api/#occwl.edge.Edge.continuity","title":"<code>continuity(face1, face2)</code>","text":"<p>Get the order of continuity among a pair of faces</p> <p>Parameters:</p> Name Type Description Default <code>face1</code> <code>Face</code> <p>First face</p> required <code>face2</code> <code>Face</code> <p>Second face</p> required <p>Returns:</p> Name Type Description <code>GeomAbs_Shape</code> <p>enum describing the continuity order</p> Source code in <code>src/occwl/edge.py</code> <pre><code>def continuity(self, face1, face2):\n    \"\"\"\n    Get the order of continuity among a pair of faces\n\n    Args:\n        face1 (occwl.face.Face): First face\n        face2 (occwl.face.Face): Second face\n\n    Returns:\n        GeomAbs_Shape: enum describing the continuity order\n    \"\"\"\n    return BRep_Tool_Continuity(\n        self.topods_shape(), face1.topods_shape(), face2.topods_shape()\n    )\n</code></pre>"},{"location":"api/#occwl.edge.Edge.convert_geometric_identity_transforms_to_identity","title":"<code>convert_geometric_identity_transforms_to_identity()</code>","text":"<p>Open Cascade models sometimes contain transforms which are \"geometrically\" identify transforms, but the identity flag is not set.</p> <p>This function checks each transform and sets the flag if  the appropriate.</p> Source code in <code>src/occwl/shape.py</code> <pre><code>def convert_geometric_identity_transforms_to_identity(self):\n    \"\"\"\n    Open Cascade models sometimes contain transforms which\n    are \"geometrically\" identify transforms, but the identity\n    flag is not set.\n\n    This function checks each transform and sets the flag if \n    the appropriate.\n    \"\"\"\n    identity = TopLoc_Location()\n    if geom_utils.is_geometric_identity(\n        self.topods_shape().Location().Transformation()\n    ):\n        self.topods_shape().Location(identity)\n        self._top_exp = TopologyUtils.TopologyExplorer(self.topods_shape(), True)\n\n    for face in self._top_exp.faces():\n        if geom_utils.is_geometric_identity(face.Location().Transformation()):\n            face.Location(identity)\n\n    for edge in self._top_exp.edges():\n        if geom_utils.is_geometric_identity(edge.Location().Transformation()):\n            edge.Location(identity)\n\n    for vertex in self._top_exp.vertices():\n        if geom_utils.is_geometric_identity(vertex.Location().Transformation()):\n            vertex.Location(identity)\n</code></pre>"},{"location":"api/#occwl.edge.Edge.curve","title":"<code>curve()</code>","text":"<p>Get the edge curve geometry</p> <p>Returns:</p> Type Description <p>OCC.Geom.Handle_Geom_Curve: Interface to all curve geometry</p> Source code in <code>src/occwl/edge.py</code> <pre><code>def curve(self):\n    \"\"\"\n    Get the edge curve geometry\n\n    Returns:\n        OCC.Geom.Handle_Geom_Curve: Interface to all curve geometry\n    \"\"\"\n    return BRep_Tool_Curve(self.topods_shape())[0]\n</code></pre>"},{"location":"api/#occwl.edge.Edge.curve_type","title":"<code>curve_type()</code>","text":"<p>Get the type of the curve geometry</p> <p>Returns:</p> Name Type Description <code>str</code> <p>Type of the curve geometry</p> Source code in <code>src/occwl/edge.py</code> <pre><code>def curve_type(self):\n    \"\"\"\n    Get the type of the curve geometry\n\n    Returns:\n        str: Type of the curve geometry\n    \"\"\"\n    curv_type = BRepAdaptor_Curve(self.topods_shape()).GetType()\n    if curv_type == GeomAbs_Line:\n        return \"line\"\n    if curv_type == GeomAbs_Circle:\n        return \"circle\"\n    if curv_type == GeomAbs_Ellipse:\n        return \"ellipse\"\n    if curv_type == GeomAbs_Hyperbola:\n        return \"hyperbola\"\n    if curv_type == GeomAbs_Parabola:\n        return \"parabola\"\n    if curv_type == GeomAbs_BezierCurve:\n        return \"bezier\"\n    if curv_type == GeomAbs_BSplineCurve:\n        return \"bspline\"\n    if curv_type == GeomAbs_OffsetCurve:\n        return \"offset\"\n    if curv_type == GeomAbs_OtherCurve:\n        return \"other\"\n    return \"unknown\"\n</code></pre>"},{"location":"api/#occwl.edge.Edge.curve_type_enum","title":"<code>curve_type_enum()</code>","text":"<p>Get the type of the curve geometry as an OCC.Core.GeomAbs enum</p> <p>Returns:</p> Type Description <p>OCC.Core.GeomAbs: Type of the curve geometry</p> Source code in <code>src/occwl/edge.py</code> <pre><code>def curve_type_enum(self):\n    \"\"\"\n    Get the type of the curve geometry as an OCC.Core.GeomAbs enum\n\n    Returns:\n        OCC.Core.GeomAbs: Type of the curve geometry\n    \"\"\"\n    return BRepAdaptor_Curve(self.topods_shape()).GetType()\n</code></pre>"},{"location":"api/#occwl.edge.Edge.end_vertex","title":"<code>end_vertex()</code>","text":"<p>Returns the ending vertex of the edge while considering the edge orientation</p> <p>Returns:</p> Type Description <p>occwl.vertex.Vertex: End vertex</p> Source code in <code>src/occwl/edge.py</code> <pre><code>def end_vertex(self):\n    \"\"\"\n    Returns the ending vertex of the edge while considering the edge orientation\n\n    Returns:\n        occwl.vertex.Vertex: End vertex\n    \"\"\"\n    return occwl.vertex.Vertex(ShapeAnalysis_Edge().LastVertex(self.topods_shape()))\n</code></pre>"},{"location":"api/#occwl.edge.Edge.exact_box","title":"<code>exact_box(use_shapetolerance=False)</code>","text":"<p>Get a slow, but accurate box for the Shape.</p> <p>Returns:</p> Name Type Description <code>Box</code> <p>Bounding box</p> Source code in <code>src/occwl/base.py</code> <pre><code>def exact_box(self, use_shapetolerance=False):\n    \"\"\"\n    Get a slow, but accurate box for the Shape.\n\n    Args:\n        use_shapetolerance (bool, optional) Include the tolerance of edges\n                                            and vertices in the box.\n\n    Returns:\n        Box: Bounding box\n    \"\"\"\n    from occwl.geometry import geom_utils\n    b = Bnd_Box()\n    use_triangulation = True\n    brepbndlib_AddOptimal(self.topods_shape(), b, use_triangulation, use_shapetolerance)\n    return geom_utils.box_to_geometry(b)\n</code></pre>"},{"location":"api/#occwl.edge.Edge.find_closest_point_data","title":"<code>find_closest_point_data(datum)</code>","text":"<p>Find the information about the closest point on this shape</p> <p>Parameters:</p> Name Type Description Default <code>datum</code> <code>ndarray</code> <p>3D Point</p> required <p>Returns:</p> Name Type Description <code>ClosestPointData</code> <p>Data about the closest point on this shape</p> <code>None</code> <p>if error</p> Source code in <code>src/occwl/shape.py</code> <pre><code>def find_closest_point_data(self, datum):\n    \"\"\"\n    Find the information about the closest point on this shape\n\n    Args:\n        datum (np.ndarray): 3D Point\n\n    Returns:\n        ClosestPointData: Data about the closest point on this shape\n        None: if error\n    \"\"\"\n    # Folowing https://dev.opencascade.org/content/how-retrieve-nearest-face-shape-given-gppnt\n    # Create a vertex from the point\n    occ_point = geom_utils.numpy_to_gp(datum)\n    vertex_maker = BRepBuilderAPI_MakeVertex(occ_point)\n    vertex = vertex_maker.Shape()\n    dist_shape_shape = BRepExtrema_DistShapeShape(\n        vertex, self.topods_shape(), Extrema_ExtFlag_MIN\n    )\n    ok = dist_shape_shape.Perform()\n    if not ok:\n        return None\n\n    return ClosestPointData(dist_shape_shape)\n</code></pre>"},{"location":"api/#occwl.edge.Edge.find_left_and_right_faces","title":"<code>find_left_and_right_faces(faces)</code>","text":"<p>Given a list of 1 or 2 faces which are adjacent to this edge, we want to return the left and right face when looking from  outside the solid.</p> <pre><code>          Edge direction\n                ^\n                |   \n      Left      |   Right \n      face      |   face\n                |\n</code></pre> <p>In the case of a cylinder the left and right face will be the same.</p> <p>Parameters:</p> Name Type Description Default <code>faces</code> <code>list(occwl.face.Face</code> <p>The faces</p> required <p>Returns:</p> Type Description <p>occwl.face.Face, occwl.face.Face: The left and then right face</p> <p>or </p> <p>None, None if the left and right faces cannot be found</p> Source code in <code>src/occwl/edge.py</code> <pre><code>def find_left_and_right_faces(self, faces):\n    \"\"\"\n    Given a list of 1 or 2 faces which are adjacent to this edge,\n    we want to return the left and right face when looking from \n    outside the solid.\n\n                  Edge direction\n                        ^\n                        |   \n              Left      |   Right \n              face      |   face\n                        |\n\n    In the case of a cylinder the left and right face will be\n    the same.\n\n    Args:\n        faces (list(occwl.face.Face): The faces\n\n    Returns:\n        occwl.face.Face, occwl.face.Face: The left and then right face\n        or \n        None, None if the left and right faces cannot be found\n    \"\"\"\n    assert len(faces) &gt; 0\n    face1 = faces[0]\n    if len(faces) == 1:\n        face2 = faces[0]\n    else:\n        face2 = faces[1]\n\n    if face1.is_left_of(self):\n        # In some cases (like a cylinder) the left and right faces\n        # of the edge are the same face\n        if face1 != face2:\n            if face2.is_left_of(self):\n                return None, None\n        left_face = face1\n        right_face = face2\n    else:\n        if not face2.is_left_of(self):\n            return None, None\n        left_face = face2\n        right_face = face1\n\n    return left_face, right_face\n</code></pre>"},{"location":"api/#occwl.edge.Edge.first_derivative","title":"<code>first_derivative(u)</code>","text":"<p>Compute the first derivative of the edge geometry at given parameter</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>float</code> <p>Curve parameter</p> required <p>Returns:</p> Type Description <p>np.ndarray: 3D vector</p> Source code in <code>src/occwl/edge.py</code> <pre><code>def first_derivative(self, u):\n    \"\"\"\n    Compute the first derivative of the edge geometry at given parameter\n\n    Args:\n        u (float): Curve parameter\n\n    Returns:\n        np.ndarray: 3D vector\n    \"\"\"\n    if self.has_curve():\n        pt = gp_Pnt()\n        der = gp_Vec()\n        self.curve().D1(u, pt, der)\n        return geom_utils.gp_to_numpy(der)\n    # If the edge has no curve then return\n    # a zero vector\n    return np.array([0, 0, 0])\n</code></pre>"},{"location":"api/#occwl.edge.Edge.get_polyline","title":"<code>get_polyline(deflection=0.0005, algorithm='QuasiUniformDeflection')</code>","text":"<p>Get a polyline, represented as a sequence of points, from this edge</p> <p>Parameters:</p> Name Type Description Default <code>deflection</code> <code>float</code> <p>Lower deflection results in more precision                 and therefore more points</p> <code>0.0005</code> <code>algorithm</code> <code>string</code> <p>Algorithm to use, can be one of:                 QuasiUniformDeflection, UniformAbscissa,                 or UniformDeflection</p> <code>'QuasiUniformDeflection'</code> <p>Returns:</p> Type Description <p>2D np.ndarray: Points</p> Source code in <code>src/occwl/edge.py</code> <pre><code>def get_polyline(self, deflection=0.0005, algorithm=\"QuasiUniformDeflection\"):\n    \"\"\"\n    Get a polyline, represented as a sequence of points, from this edge\n\n    Args:\n        deflection (float): Lower deflection results in more precision\n                            and therefore more points\n        algorithm (string): Algorithm to use, can be one of:\n                            QuasiUniformDeflection, UniformAbscissa,\n                            or UniformDeflection\n\n    Returns:\n        2D np.ndarray: Points\n    \"\"\"\n    # If we don't have a valid curve, return an empty array\n    if not self.has_curve():\n        return np.empty(shape=(0,3), dtype=np.float32)\n\n    curve_adaptor = BRepAdaptor_Curve(self.topods_shape())\n    first_param = curve_adaptor.FirstParameter()\n    last_param = curve_adaptor.LastParameter()\n\n    if algorithm == \"QuasiUniformDeflection\":\n        discretizer = GCPnts_QuasiUniformDeflection()\n    elif algorithm == \"UniformAbscissa\":\n        discretizer = GCPnts_UniformAbscissa()\n    elif algorithm == \"UniformDeflection\":\n        discretizer = GCPnts_UniformDeflection()\n    else:\n        raise Exception(\"Unknown algorithm\")\n    discretizer.Initialize(curve_adaptor, deflection, first_param, last_param)\n\n    if not discretizer.IsDone():\n        raise Exception(\"Discretizer not done.\")\n    if not discretizer.NbPoints() &gt; 0:\n        raise Exception(\"Discretizer nb points not &gt; 0.\")\n\n    points = []\n    for i in range(1, discretizer.NbPoints() + 1):\n        p = curve_adaptor.Value(discretizer.Parameter(i))\n        points.append(np.array(list(p.Coord())))\n    return np.asarray(points, dtype=np.float32)\n</code></pre>"},{"location":"api/#occwl.edge.Edge.has_curve","title":"<code>has_curve()</code>","text":"<p>Does this edge have a valid curve? Some edges don't.  For example the edge at the pole of a sphere.</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>Whether this edge has a valid curve</p> Source code in <code>src/occwl/edge.py</code> <pre><code>def has_curve(self):\n    \"\"\"\n    Does this edge have a valid curve?\n    Some edges don't.  For example the edge at the pole of a sphere.\n\n    Returns:\n        bool: Whether this edge has a valid curve\n    \"\"\"\n    curve = BRepAdaptor_Curve(self.topods_shape())\n    return curve.Is3DCurve()\n</code></pre>"},{"location":"api/#occwl.edge.Edge.has_pcurve","title":"<code>has_pcurve(face)</code>","text":"<p>Whether this edge has a pcurve associated to the given face</p> <p>Parameters:</p> Name Type Description Default <code>face</code> <code>Face</code> <p>Face</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>If pcurve exists</p> Source code in <code>src/occwl/edge.py</code> <pre><code>def has_pcurve(self, face):\n    \"\"\"\n    Whether this edge has a pcurve associated to the given face\n\n    Args:\n        face (occwl.face.Face): Face\n\n    Returns:\n        bool: If pcurve exists\n    \"\"\"\n    return ShapeAnalysis_Edge().HasPCurve(self.topods_shape(), face.topods_shape())\n</code></pre>"},{"location":"api/#occwl.edge.Edge.length","title":"<code>length()</code>","text":"<p>Compute the length of the edge curve</p> <p>Returns:</p> Name Type Description <code>float</code> <p>Length of the edge curve</p> Source code in <code>src/occwl/edge.py</code> <pre><code>def length(self):\n    \"\"\"\n    Compute the length of the edge curve\n\n    Returns:\n        float: Length of the edge curve\n    \"\"\"\n    if not self.has_curve():\n        return 0.0\n    geometry_properties = GProp_GProps()\n    brepgprop_LinearProperties(self.topods_shape(), geometry_properties)\n    return geometry_properties.Mass()\n</code></pre>"},{"location":"api/#occwl.edge.Edge.make_arc_of_circle","title":"<code>make_arc_of_circle(pt1, pt2, pt3)</code>  <code>staticmethod</code>","text":"<p>Make an arc edge</p> <p>Parameters:</p> Name Type Description Default <code>pt1</code> <code>np.ndarray or list or tuple with 3D point</code> <p>Start point</p> required <code>pt2</code> <code>np.ndarray or list or tuple with 3D point</code> <p>Mid (not necessarily at the middle) point</p> required <code>pt3</code> <code>np.ndarray or list or tuple with 3D point</code> <p>End point</p> required <p>Returns:</p> Type Description <p>occwl.edge.Edge: Edge</p> <p>or None: if error</p> Source code in <code>src/occwl/edge.py</code> <pre><code>@staticmethod\ndef make_arc_of_circle(pt1, pt2, pt3):\n    \"\"\"\n    Make an arc edge\n\n    Args:\n        pt1 (np.ndarray or list or tuple with 3D point): Start point\n        pt2 (np.ndarray or list or tuple with 3D point): Mid (not necessarily at the middle) point\n        pt3 (np.ndarray or list or tuple with 3D point): End point\n\n    Returns:\n        occwl.edge.Edge: Edge\n        or None: if error\n    \"\"\"\n    arc = GC_MakeArcOfCircle(geom_utils.to_gp_pnt(pt1), geom_utils.to_gp_pnt(pt2), geom_utils.to_gp_pnt(pt3)).Value()\n    edge_builder = BRepBuilderAPI_MakeEdge(arc)\n    if not edge_builder.IsDone():\n        return None\n    return Edge(edge_builder.Edge())\n</code></pre>"},{"location":"api/#occwl.edge.Edge.make_circle","title":"<code>make_circle(center, radius, direction=(0, 0, 1))</code>  <code>staticmethod</code>","text":"<p>Make a circular edge</p> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>np.ndarray or list or tuple with 3D point</code> <p>Center of the circle</p> required <code>radius</code> <code>float</code> <p>Radius of the circle</p> required <code>direction</code> <code>np.ndarray or list or tuple with 3D unit vector</code> <p>Normal of the circle's face. Defaults to (0, 0, 1).</p> <code>(0, 0, 1)</code> <p>Returns:</p> Type Description <p>occwl.edge.Edge: Edge</p> <p>or None: if error</p> Source code in <code>src/occwl/edge.py</code> <pre><code>@staticmethod\ndef make_circle(center, radius, direction=(0, 0, 1)):\n    \"\"\"\n    Make a circular edge\n\n    Args:\n        center (np.ndarray or list or tuple with 3D point): Center of the circle\n        radius (float): Radius of the circle\n        direction (np.ndarray or list or tuple with 3D unit vector, optional): Normal of the circle's face. Defaults to (0, 0, 1).\n\n    Returns:\n        occwl.edge.Edge: Edge\n        or None: if error\n    \"\"\"\n    circle = gp_Circ(\n        gp_Ax2(geom_utils.to_gp_pnt(center), geom_utils.to_gp_dir(direction)),\n        float(radius),\n    )\n    edge_builder = BRepBuilderAPI_MakeEdge(circle)\n    if not edge_builder.IsDone():\n        return None\n    return Edge(edge_builder.Edge())\n</code></pre>"},{"location":"api/#occwl.edge.Edge.make_line_from_points","title":"<code>make_line_from_points(start_point, end_point)</code>  <code>staticmethod</code>","text":"<p>Make an edge from two given points</p> <p>Parameters:</p> Name Type Description Default <code>start_point</code> <code>np.ndarray 3D vector</code> <p>Starting point</p> required <code>end_point</code> <code>np.ndarray 3D vector</code> <p>Ending point</p> required <p>Returns:</p> Type Description <p>occwl.Edge: Edge joining the two given vertices</p> <p>or None: if error</p> Source code in <code>src/occwl/edge.py</code> <pre><code>@staticmethod\ndef make_line_from_points(start_point, end_point):\n    \"\"\"\n    Make an edge from two given points\n\n    Args:\n        start_point (np.ndarray 3D vector): Starting point\n        end_point (np.ndarray 3D vector): Ending point\n\n    Returns:\n        occwl.Edge: Edge joining the two given vertices\n        or None: if error\n    \"\"\"\n    edge_builder = BRepBuilderAPI_MakeEdge(geom_utils.to_gp_pnt(start_point), geom_utils.to_gp_pnt(end_point))\n    if not edge_builder.IsDone():\n        return None\n    return Edge(edge_builder.Edge())\n</code></pre>"},{"location":"api/#occwl.edge.Edge.make_line_from_vertices","title":"<code>make_line_from_vertices(start_vertex, end_vertex)</code>  <code>staticmethod</code>","text":"<p>Make an edge from two given vertices</p> <p>Parameters:</p> Name Type Description Default <code>start_vertex</code> <code>Vertex</code> <p>Starting vertex</p> required <code>end_vertex</code> <code>Vertex</code> <p>Ending vertex</p> required <p>Returns:</p> Type Description <p>occwl.Edge: Edge joining the two given vertices</p> <p>or None: if error</p> Source code in <code>src/occwl/edge.py</code> <pre><code>@staticmethod\ndef make_line_from_vertices(start_vertex, end_vertex):\n    \"\"\"\n    Make an edge from two given vertices\n\n    Args:\n        start_vertex (occwl.vertex.Vertex): Starting vertex\n        end_vertex (occwl.vertex.Vertex): Ending vertex\n\n    Returns:\n        occwl.Edge: Edge joining the two given vertices\n        or None: if error\n    \"\"\"\n    edge_builder = BRepBuilderAPI_MakeEdge(start_vertex.topods_shape(), end_vertex.topods_shape())\n    if not edge_builder.IsDone():\n        return None\n    return Edge(edge_builder.Edge())\n</code></pre>"},{"location":"api/#occwl.edge.Edge.num_vertices","title":"<code>num_vertices()</code>","text":"<p>Number of vertices in the Shape</p> <p>Returns:</p> Name Type Description <code>int</code> <p>Number of vertices</p> Source code in <code>src/occwl/base.py</code> <pre><code>def num_vertices(self):\n    \"\"\"\n    Number of vertices in the Shape\n\n    Returns:\n        int: Number of vertices\n    \"\"\"\n    return self._top_exp.number_of_vertices()\n</code></pre>"},{"location":"api/#occwl.edge.Edge.occwl_shape","title":"<code>occwl_shape(topods_shape)</code>  <code>staticmethod</code>","text":"<p>Static method to create an occwl shape of the appropriate  class from the given topods_shape Args:     topods_shape (OCC.Core.TopoDS.TopoDS_Vertex/Edge/Face/Wire/Shell/Solid): TopoDS shape</p> <p>Returns:</p> Type Description <p>One of occwl.compound.Compound occwl.solid.Solid occwl.face.Face occwl.edge.Edge occwl.vertex.Vertex occwl.wire.Wire occwl.shell.Shell</p> <p>Raises:     Exception: [description]</p> Source code in <code>src/occwl/shape.py</code> <pre><code>@staticmethod\ndef occwl_shape(topods_shape):\n    \"\"\"\n    Static method to create an occwl shape of the appropriate \n    class from the given topods_shape\n    Args:\n        topods_shape (OCC.Core.TopoDS.TopoDS_Vertex/Edge/Face/Wire/Shell/Solid): TopoDS shape\n\n    Returns:\n        One of\n            occwl.compound.Compound\n            occwl.solid.Solid\n            occwl.face.Face\n            occwl.edge.Edge\n            occwl.vertex.Vertex\n            occwl.wire.Wire\n            occwl.shell.Shell\n    Raises:\n        Exception: [description]\n    \"\"\"\n    from occwl.compound import Compound\n    from occwl.solid import Solid\n    from occwl.face import Face\n    from occwl.edge import Edge\n    from occwl.vertex import Vertex\n    from occwl.wire import Wire\n    from occwl.shell import Shell\n\n    if isinstance(topods_shape, TopoDS_Vertex):\n        return Vertex(topods_shape)\n    if isinstance(topods_shape, TopoDS_Edge):\n        return Edge(topods_shape)\n    if isinstance(topods_shape, TopoDS_Face):\n        return Face(topods_shape)\n    if isinstance(topods_shape, TopoDS_Wire):\n        return Wire(topods_shape)\n    if isinstance(topods_shape, TopoDS_Shell):\n        return Shell(topods_shape)\n    if isinstance(topods_shape, TopoDS_Solid):\n        return Solid(topods_shape)\n    if isinstance(topods_shape, (TopoDS_Compound, TopoDS_CompSolid)):\n        return Compound(topods_shape)\n    raise Exception(\n        \"Shape must be one of TopoDS_Vertex, TopoDS_Edge, TopoDS_Face, TopoDS_Shell, TopoDS_Solid, TopoDS_Compound, TopoDS_CompSolid\"\n    )\n</code></pre>"},{"location":"api/#occwl.edge.Edge.periodic","title":"<code>periodic()</code>","text":"<p>Whether this edge is periodic</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>If periodic</p> Source code in <code>src/occwl/edge.py</code> <pre><code>def periodic(self):\n    \"\"\"\n    Whether this edge is periodic\n\n    Returns:\n        bool: If periodic\n    \"\"\"\n    return BRepAdaptor_Curve(self.topods_shape()).IsPeriodic()\n</code></pre>"},{"location":"api/#occwl.edge.Edge.point","title":"<code>point(u)</code>","text":"<p>Evaluate the edge geometry at given parameter</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>float</code> <p>Curve parameter</p> required <p>Returns:</p> Type Description <p>np.ndarray: 3D Point</p> Source code in <code>src/occwl/edge.py</code> <pre><code>def point(self, u):\n    \"\"\"\n    Evaluate the edge geometry at given parameter\n\n    Args:\n        u (float): Curve parameter\n\n    Returns:\n        np.ndarray: 3D Point\n    \"\"\"\n    if self.has_curve():\n        pt = self.curve().Value(u)\n        return geom_utils.gp_to_numpy(pt)\n    # If the edge has no curve then return a point\n    # at the origin.\n    # It would ne nice to return the location of the\n    # vertex\n    return np.array([0, 0, 0])\n</code></pre>"},{"location":"api/#occwl.edge.Edge.rational","title":"<code>rational()</code>","text":"<p>Whether this edge geometry is rational</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>If rational</p> Source code in <code>src/occwl/edge.py</code> <pre><code>def rational(self):\n    \"\"\"\n    Whether this edge geometry is rational\n\n    Returns:\n        bool: If rational\n    \"\"\"\n    return BRepAdaptor_Curve(self.topods_shape()).IsRational()\n</code></pre>"},{"location":"api/#occwl.edge.Edge.reversed","title":"<code>reversed()</code>","text":"<p>Whether this shape is reversed.</p> <ul> <li>For an edge this is whether the edge is reversed with respect to the curve geometry</li> <li>For a face this is whether the face is reversed with respect to the surface geometry</li> <li>For a vertex this is whether the vertex is at the upper or lower parameter value on the   edges curve</li> </ul> <p>Returns:</p> Name Type Description <code>bool</code> <p>If rational</p> Source code in <code>src/occwl/shape.py</code> <pre><code>def reversed(self):\n    \"\"\"\n    Whether this shape is reversed.\n\n    - For an edge this is whether the edge is reversed with respect to the curve geometry\n    - For a face this is whether the face is reversed with respect to the surface geometry\n    - For a vertex this is whether the vertex is at the upper or lower parameter value on the\n      edges curve\n\n    Returns:\n        bool: If rational\n    \"\"\"\n    return self.topods_shape().Orientation() == TopAbs_REVERSED\n</code></pre>"},{"location":"api/#occwl.edge.Edge.reversed_edge","title":"<code>reversed_edge()</code>","text":"<p>Return a copy of this edge with the orientation reversed.</p> <p>Returns:</p> Type Description <p>occwl.edge.Edge: An edge with the opposite orientation to this edge.</p> Source code in <code>src/occwl/edge.py</code> <pre><code>def reversed_edge(self):\n    \"\"\"\n    Return a copy of this edge with the orientation reversed.\n\n    Returns:\n        occwl.edge.Edge: An edge with the opposite orientation to this edge.\n    \"\"\"\n    return Edge(self.topods_shape().Reversed())\n</code></pre>"},{"location":"api/#occwl.edge.Edge.rotate_axis_angle","title":"<code>rotate_axis_angle(axis, angle_radians, origin=np.zeros(3, dtype=(np.float32)))</code>","text":"<p>Rotate the shape about the given axis by the given angle in radians</p> <p>Parameters:</p> Name Type Description Default <code>axis</code> <code>ndarray</code> <p>Rotation axis</p> required <code>angle_radians</code> <code>float</code> <p>Angle in radians</p> required Source code in <code>src/occwl/shape.py</code> <pre><code>def rotate_axis_angle(\n    self, axis, angle_radians, origin=np.zeros(3, dtype=np.float32)\n):\n    \"\"\"\n    Rotate the shape about the given axis by the given angle in radians\n\n    Args:\n        axis (np.ndarray): Rotation axis\n        angle_radians (float): Angle in radians\n    \"\"\"\n    self._shape = rotate_shape(\n        self._shape,\n        gp_Ax1(geom_utils.numpy_to_gp(origin), geom_utils.numpy_to_gp_dir(axis)),\n        angle_radians,\n        unite=\"rad\",\n    )\n</code></pre>"},{"location":"api/#occwl.edge.Edge.rotate_euler_angles","title":"<code>rotate_euler_angles(angles_xyz_radians)</code>","text":"<p>Rotate the shape by the given Euler angles in radians</p> <p>Parameters:</p> Name Type Description Default <code>angle_xyz_radians</code> <code>ndarray</code> <p>3D array with angles to rotate about x-axis, y-axis and z-axis respectively in radians</p> required Source code in <code>src/occwl/shape.py</code> <pre><code>def rotate_euler_angles(self, angles_xyz_radians):\n    \"\"\"\n    Rotate the shape by the given Euler angles in radians\n\n    Args:\n        angle_xyz_radians (np.ndarray): 3D array with angles to rotate about x-axis, y-axis and z-axis respectively in radians\n    \"\"\"\n    self._shape = rotate_shp_3_axis(\n        self._shape,\n        angles_xyz_radians[0],\n        angles_xyz_radians[1],\n        angles_xyz_radians[2],\n        unity=\"rad\",\n    )\n</code></pre>"},{"location":"api/#occwl.edge.Edge.save_shapes_to_occ_native","title":"<code>save_shapes_to_occ_native(filename, shapes, with_triangles=False, with_normals=False, format_version=None)</code>  <code>staticmethod</code>","text":"<p>Save this shape into a native OCC binary .brep file.</p> Saving to and loading from the native file format <p>is between one and two orders of magnitude faster  than loading from STEP, so it is recommended for  large scale data processing</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str or Path</code> <p>.brep filename</p> required <code>with_triangles</code> <code>bool</code> <p>Whether to save triangle data cached in the shape.</p> <code>False</code> <code>with_normals</code> <code>bool</code> <p>Whether to save vertex normals cached in the shape</p> <code>False</code> <code>format_version</code> <code>int</code> <p>Use None to save to the latest version 1 - first revision 2 - added storing of CurveOnSurface UV Points 3 - [OCCT 7.6] added storing of per-vertex normal information                and dropped storing of CurveOnSurface UV Points</p> <code>None</code> Source code in <code>src/occwl/shape.py</code> <pre><code>@staticmethod\ndef save_shapes_to_occ_native(\n        filename, \n        shapes,\n        with_triangles=False,\n        with_normals=False,\n        format_version=None\n    ):\n    \"\"\"\n    Save this shape into a native OCC binary .brep file.\n\n    Note:  Saving to and loading from the native file format \n            is between one and two orders of magnitude faster \n            than loading from STEP, so it is recommended for \n            large scale data processing\n\n    Args:\n        filename (str or pathlib.Path): .brep filename\n\n        with_triangles (bool): Whether to save triangle data cached in the shape.\n        with_normals (bool): Whether to save vertex normals cached in the shape\n        format_version (int):  Use None to save to the latest version\n            1 - first revision\n            2 - added storing of CurveOnSurface UV Points\n            3 - [OCCT 7.6] added storing of per-vertex normal information\n                           and dropped storing of CurveOnSurface UV Points\n    \"\"\"\n    new_api = False\n    shapes_set = BRepTools_ShapeSet(with_triangles)\n    # shapes_set.SetWithNormals(with_normals) # Not in OCC 7.5.0\n\n    for shp in shapes:\n        shapes_set.Add(shp.topods_shape())\n    if format_version is not None:\n        shapes_set.SetFormatNb(format_version)\n\n\n    with open(filename, \"w\") as fp:\n        s = shapes_set.WriteToString()\n        fp.write(s)\n</code></pre>"},{"location":"api/#occwl.edge.Edge.save_to_occ_native","title":"<code>save_to_occ_native(filename, verbosity=False, with_triangles=False, with_normals=False, format_version=None)</code>","text":"<p>Save this shape into a native OCC binary .brep file.</p> Saving to and loading from the native file format <p>is between one and two orders of magnitude faster  than loading from STEP, so it is recommended for  large scale data processing</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str or Path</code> <p>.brep filename</p> required <code>with_triangles</code> <code>bool</code> <p>Whether to save triangle data cached in the shape.</p> <code>False</code> <code>with_normals</code> <code>bool</code> <p>Whether to save vertex normals cached in the shape</p> <code>False</code> <code>format_version</code> <code>int</code> <p>Use None to save to the latest version 1 - first revision 2 - added storing of CurveOnSurface UV Points 3 - [OCCT 7.6] added storing of per-vertex normal information                and dropped storing of CurveOnSurface UV Points</p> <code>None</code> Source code in <code>src/occwl/shape.py</code> <pre><code>def save_to_occ_native(\n        self, \n        filename, \n        verbosity=False,\n        with_triangles=False,\n        with_normals=False,\n        format_version=None\n    ):\n    \"\"\"\n    Save this shape into a native OCC binary .brep file.\n\n    Note:  Saving to and loading from the native file format \n           is between one and two orders of magnitude faster \n           than loading from STEP, so it is recommended for \n           large scale data processing\n\n    Args:\n        filename (str or pathlib.Path): .brep filename\n        with_triangles (bool): Whether to save triangle data cached in the shape.\n        with_normals (bool): Whether to save vertex normals cached in the shape\n        format_version (int):  Use None to save to the latest version\n            1 - first revision\n            2 - added storing of CurveOnSurface UV Points\n            3 - [OCCT 7.6] added storing of per-vertex normal information\n                           and dropped storing of CurveOnSurface UV Points\n    \"\"\"\n    self.save_shapes_to_occ_native(\n        filename, \n        [ self ],\n        with_triangles=with_triangles,\n        with_normals=with_normals,\n        format_version=format_version\n    )\n</code></pre>"},{"location":"api/#occwl.edge.Edge.scale","title":"<code>scale(scale_vector)</code>","text":"<p>Scale the shape by the given 3D vector</p> <p>Parameters:</p> Name Type Description Default <code>scale_vector</code> <code>ndarray</code> <p>3D array with scales to resize the shape along the x-axis, y-axis and z-axis respectively</p> required Source code in <code>src/occwl/shape.py</code> <pre><code>def scale(self, scale_vector):\n    \"\"\"\n    Scale the shape by the given 3D vector\n\n    Args:\n        scale_vector (np.ndarray): 3D array with scales to resize the shape along the x-axis, y-axis and z-axis respectively\n    \"\"\"\n    self._shape = scale_shape(\n        self._shape, scale_vector[0], scale_vector[1], scale_vector[2]\n    )\n</code></pre>"},{"location":"api/#occwl.edge.Edge.scale_to_box","title":"<code>scale_to_box(box_side, copy=True)</code>","text":"<p>Translate and scale the Shape so it fits exactly  into the [-box_side, box_side]^3 box</p> <p>Returns:</p> Type Description <p>occwl..: The scaled version of this Shape</p> Source code in <code>src/occwl/base.py</code> <pre><code>def scale_to_box(self, box_side, copy=True):\n    \"\"\"\n    Translate and scale the Shape so it fits exactly \n    into the [-box_side, box_side]^3 box\n\n    Args:\n        box_side (float) The side length of the box\n        copy (bool)      True - Copy entities and apply the transform to\n                                the underlying geometry\n                         False - Apply the transform to the topods Locator\n                                 if possible \n\n    Returns:\n        occwl.*.*: The scaled version of this Shape\n    \"\"\"\n    from occwl.geometry import geom_utils\n    # Get an exact box for the Shape\n    box = self.exact_box()\n    center = box.center()\n    longest_length = box.max_box_length()\n\n    orig = gp_Pnt(0.0, 0.0, 0.0)\n    center = geom_utils.numpy_to_gp(center)\n    vec_center_to_orig = gp_Vec(center, orig)\n    move_to_center = gp_Trsf()\n    move_to_center.SetTranslation(vec_center_to_orig)\n\n    scale_trsf = gp_Trsf()\n    scale_trsf.SetScale(orig, (2.0 * box_side) / longest_length)\n    trsf_to_apply = scale_trsf.Multiplied(move_to_center)\n\n    return self._apply_transform(trsf_to_apply, copy=copy)\n</code></pre>"},{"location":"api/#occwl.edge.Edge.scale_to_unit_box","title":"<code>scale_to_unit_box(copy=True)</code>","text":"<p>Translate and scale the Shape so it fits exactly  into the [-1, 1]^3 box</p> <p>Returns:     The scaled version of this shape</p> Source code in <code>src/occwl/base.py</code> <pre><code>def scale_to_unit_box(self, copy=True):\n    \"\"\"\n    Translate and scale the Shape so it fits exactly \n    into the [-1, 1]^3 box\n\n    Args:\n        copy (bool)      True - Copy entities and apply the transform to\n                                    the underlying geometry\n                            False - Apply the transform to the topods Locator\n                                    if possible \n    Returns:\n        The scaled version of this shape\n    \"\"\"\n    return self.scale_to_box(1.0, copy=copy)\n</code></pre>"},{"location":"api/#occwl.edge.Edge.seam","title":"<code>seam(face)</code>","text":"<p>Whether this edge is a seam</p> <p>Parameters:</p> Name Type Description Default <code>face</code> <code>Face</code> <p>Face where the edge lives</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>If seam</p> Source code in <code>src/occwl/edge.py</code> <pre><code>def seam(self, face):\n    \"\"\"\n    Whether this edge is a seam\n\n    Args:\n        face (occwl.face.Face): Face where the edge lives\n\n    Returns:\n        bool: If seam\n    \"\"\"\n    return ShapeAnalysis_Edge().IsSeam(self.topods_shape(), face.topods_shape())\n</code></pre>"},{"location":"api/#occwl.edge.Edge.set_transform_to_identity","title":"<code>set_transform_to_identity()</code>","text":"<p>When an assembly is loaded from a STEP file the solids will be transformed relative to their local coordinate system.   i.e. they are placed in the assembly root components  coordinate system.</p> <p>When working with individual bodies you often want them to be axis aligned, in which case  you want to remove the assembly transform. This function removes it for you.</p> <p>If however you want to bake the transform into the bodies and suppress the asserts  from parts of occwl which don't cope with transforms then use the transform() function below with copy=True</p> Source code in <code>src/occwl/shape.py</code> <pre><code>def set_transform_to_identity(self):\n    \"\"\"\n    When an assembly is loaded from a STEP file\n    the solids will be transformed relative to\n    their local coordinate system.   i.e. they\n    are placed in the assembly root components \n    coordinate system.\n\n    When working with individual bodies you often\n    want them to be axis aligned, in which case \n    you want to remove the assembly transform.\n    This function removes it for you.\n\n    If however you want to bake the transform\n    into the bodies and suppress the asserts \n    from parts of occwl which don't cope with\n    transforms then use the transform() function\n    below with copy=True\n    \"\"\"\n    identity = TopLoc_Location()\n    self.topods_shape().Location(identity)\n    self._top_exp = TopologyUtils.TopologyExplorer(self.topods_shape(), True)\n    self.convert_geometric_identity_transforms_to_identity()\n</code></pre>"},{"location":"api/#occwl.edge.Edge.specific_curve","title":"<code>specific_curve()</code>","text":"<p>Get the specific edge curve geometry</p> <p>Returns:</p> Type Description <p>OCC.Geom.Handle_Geom_*: Specific geometry type for the curve geometry                     or None if the curve type is GeomAbs_OtherCurve</p> Source code in <code>src/occwl/edge.py</code> <pre><code>def specific_curve(self):\n    \"\"\"\n    Get the specific edge curve geometry\n\n    Returns:\n        OCC.Geom.Handle_Geom_*: Specific geometry type for the curve geometry\n                                or None if the curve type is GeomAbs_OtherCurve\n    \"\"\"\n    brep_adaptor_curve = BRepAdaptor_Curve(self.topods_shape())\n    curv_type = brep_adaptor_curve.GetType()\n    if curv_type == GeomAbs_Line:\n        return brep_adaptor_curve.Line()\n    if curv_type == GeomAbs_Circle:\n        return brep_adaptor_curve.Circle()\n    if curv_type == GeomAbs_Ellipse:\n        return brep_adaptor_curve.Ellipse()\n    if curv_type == GeomAbs_Hyperbola:\n        return brep_adaptor_curve.Hyperbola()\n    if curv_type == GeomAbs_Parabola:\n        return brep_adaptor_curve.Parabola()\n    if curv_type == GeomAbs_BezierCurve:\n        return brep_adaptor_curve.Bezier()\n    if curv_type == GeomAbs_BSplineCurve:\n        return brep_adaptor_curve.BSpline()\n    if curv_type == GeomAbs_OffsetCurve:\n        return brep_adaptor_curve.OffsetCurve()\n    return None\n</code></pre>"},{"location":"api/#occwl.edge.Edge.start_vertex","title":"<code>start_vertex()</code>","text":"<p>Returns the starting vertex of the edge while considering the edge orientation</p> <p>Returns:</p> Type Description <p>occwl.vertex.Vertex: Start vertex</p> Source code in <code>src/occwl/edge.py</code> <pre><code>def start_vertex(self):\n    \"\"\"\n    Returns the starting vertex of the edge while considering the edge orientation\n\n    Returns:\n        occwl.vertex.Vertex: Start vertex\n    \"\"\"\n    return occwl.vertex.Vertex(ShapeAnalysis_Edge().FirstVertex(self.topods_shape()))\n</code></pre>"},{"location":"api/#occwl.edge.Edge.tangent","title":"<code>tangent(u)</code>","text":"<p>Compute the tangent of the edge geometry at given parameter</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>float</code> <p>Curve parameter</p> required <p>Returns:</p> Type Description <p>np.ndarray: 3D unit vector</p> Source code in <code>src/occwl/edge.py</code> <pre><code>def tangent(self, u):\n    \"\"\"\n    Compute the tangent of the edge geometry at given parameter\n\n    Args:\n        u (float): Curve parameter\n\n    Returns:\n        np.ndarray: 3D unit vector\n    \"\"\"\n    if self.has_curve():\n        pt = gp_Pnt()\n        der = gp_Vec()\n        self.curve().D1(u, pt, der)\n        der.Normalize()\n        tangent = geom_utils.gp_to_numpy(der)\n        if self.reversed():\n            tangent = -tangent\n        return tangent\n    # If the edge has no curve then return\n    # a zero vector\n    return np.array([0, 0, 0])\n</code></pre>"},{"location":"api/#occwl.edge.Edge.tolerance","title":"<code>tolerance()</code>","text":"<p>Get tolerance of this edge.  The 3d curve of the edge should not deviate from the surfaces of adjacent faces by more than this value</p> <p>Returns:</p> Type Description <p>float The edge tolerance</p> Source code in <code>src/occwl/edge.py</code> <pre><code>def tolerance(self):\n    \"\"\"\n    Get tolerance of this edge.  The 3d curve of the edge should not\n    deviate from the surfaces of adjacent faces by more than this value\n\n    Returns:\n        float The edge tolerance\n    \"\"\"\n    return BRep_Tool().Tolerance(self.topods_shape())\n</code></pre>"},{"location":"api/#occwl.edge.Edge.topods_shape","title":"<code>topods_shape()</code>","text":"<p>Get the underlying OCC shape</p> <p>Returns:</p> Type Description <p>OCC.Core.TopoDS.TopoDS_Vertex/Edge/Face/Wire/Shell/Solid: OCC TopoDS_*</p> Source code in <code>src/occwl/shape.py</code> <pre><code>def topods_shape(self):\n    \"\"\"\n    Get the underlying OCC shape\n\n    Returns:\n        OCC.Core.TopoDS.TopoDS_Vertex/Edge/Face/Wire/Shell/Solid: OCC TopoDS_*\n    \"\"\"\n    return self._shape\n</code></pre>"},{"location":"api/#occwl.edge.Edge.transform","title":"<code>transform(a, copy=True)</code>","text":"<p>Apply the given 3x4 transform matrix to the solid.</p> <pre><code> copy (bool)    True - Copy entities and apply the transform to\n                       the underlying geometry\n                False - Apply the transform to the topods Locator\n                        if possible\n</code></pre> Source code in <code>src/occwl/shape.py</code> <pre><code>def transform(self, a: np.ndarray, copy=True):\n    \"\"\"\n    Apply the given 3x4 transform matrix to the solid.\n\n    Args: a (nd.array) - Homogeneous transform matrix\n                         The transform that will be applied is\n\n                         x' =  a[0,0]*x + a[0,1]*y + a[0,2]*z + a[0, 3]\n                         y' =  a[1,0]*x + a[1,1]*y + a[1,2]*z + a[1, 3]\n                         z' =  a[2,0]*x + a[2,1]*y + a[2,2]*z + a[2, 3]\n\n         copy (bool)    True - Copy entities and apply the transform to\n                               the underlying geometry\n                        False - Apply the transform to the topods Locator\n                                if possible \n    \"\"\"\n    assert (a.shape == (3, 4)), \"Transform matrix must be 3x4\"\n    a = a.astype(np.float64)\n\n    # Create an identity transform\n    trsf = gp_Trsf()\n\n    # If the matrix is an identity matrix then\n    # we don't want to set the values as this\n    # would give us a geometric identity without\n    # the identity flag set\n    if not np.allclose(a, np.eye(3, 4)):\n        trsf.SetValues(\n            a[0,0], a[0,1], a[0,2], a[0, 3],\n            a[1,0], a[1,1], a[1,2], a[1, 3],\n            a[2,0], a[2,1], a[2,2], a[2, 3]\n        )\n    return self._apply_transform(trsf, copy=copy)\n</code></pre>"},{"location":"api/#occwl.edge.Edge.translate","title":"<code>translate(offset)</code>","text":"<p>Translate the shape by an offset vector</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>ndarray</code> <p>Offset vector</p> required Source code in <code>src/occwl/shape.py</code> <pre><code>def translate(self, offset):\n    \"\"\"\n    Translate the shape by an offset vector\n\n    Args:\n        offset (np.ndarray): Offset vector\n    \"\"\"\n    self._shape = translate_shp(self._shape, geom_utils.numpy_to_gp_vec(offset))\n</code></pre>"},{"location":"api/#occwl.edge.Edge.u_bounds","title":"<code>u_bounds()</code>","text":"<p>Parameter domain of the curve</p> <p>Returns:</p> Type Description <p>occwl.geometry.Interval: a 1D interval [u_min, u_max]</p> Source code in <code>src/occwl/edge.py</code> <pre><code>def u_bounds(self):\n    \"\"\"\n    Parameter domain of the curve\n\n    Returns:\n        occwl.geometry.Interval: a 1D interval [u_min, u_max]\n    \"\"\"\n    if not self.has_curve():\n        # Return an empty interval\n        return Interval()\n    _, umin, umax = BRep_Tool_Curve(self.topods_shape())\n    return Interval(umin, umax)\n</code></pre>"},{"location":"api/#occwl.edge.Edge.valid","title":"<code>valid(return_analyzer=False)</code>","text":"<p>Check if the shape is valid</p> <p>Parameters:</p> Name Type Description Default <code>return_analyzer</code> <code>bool</code> <p>Whether to return the BRepCheck_Analyzer object for more inspection</p> <code>False</code> <p>Returns:</p> Name Type Description <code>bool</code> <p>Whether the shape is valid</p> <p>BRepCheck_Analyzer [optional]: if return_analyzer is True</p> Source code in <code>src/occwl/shape.py</code> <pre><code>def valid(self, return_analyzer=False):\n    \"\"\"\n    Check if the shape is valid\n\n    Args:\n        return_analyzer (bool): Whether to return the BRepCheck_Analyzer object for more inspection\n\n    Returns:\n        bool: Whether the shape is valid\n        BRepCheck_Analyzer [optional]: if return_analyzer is True\n    \"\"\"\n    analyzer = BRepCheck_Analyzer(self.topods_shape())\n    if return_analyzer:\n        return analyzer.IsValid(), analyzer\n    return analyzer.IsValid()\n</code></pre>"},{"location":"api/#occwl.edge.Edge.vertices","title":"<code>vertices()</code>","text":"<p>Get an iterator to go over all vertices in the Shape</p> <p>Returns:</p> Type Description <p>Iterator[occwl.vertex.Vertex]: Vertex iterator</p> Source code in <code>src/occwl/base.py</code> <pre><code>def vertices(self):\n    \"\"\"\n    Get an iterator to go over all vertices in the Shape\n\n    Returns:\n        Iterator[occwl.vertex.Vertex]: Vertex iterator\n    \"\"\"\n    from occwl.vertex import Vertex\n    return map(Vertex, self._top_exp.vertices())\n</code></pre>"},{"location":"api/#occwl.edge_data_extractor","title":"<code>edge_data_extractor</code>","text":"<p>A class to extract points and normals from the two faces adjacent to an edge. This can then be used to compute the edges convexity.</p>"},{"location":"api/#occwl.edge_data_extractor.EdgeDataExtractor","title":"<code>EdgeDataExtractor</code>","text":"Source code in <code>src/occwl/edge_data_extractor.py</code> <pre><code>class EdgeDataExtractor:\n    def __init__(self, edge, faces, num_samples=10, use_arclength_params=True):\n        \"\"\"\n        Compute point and normal data for an oriented edge of the model.\n        The arrays of points, tangents and normals are all oriented based\n        on the orientation flag of the edge.\n\n        You can access the data from the member numpy arrays\n\n            EdgeDataExtractor.points\n            EdgeDataExtractor.tangests\n            EdgeDataExtractor.left_normals\n            EdgeDataExtractor.right_normals\n\n        If a problem was detected during the calculation then \n        EdgeDataExtractor.good == false\n        \"\"\"\n        assert num_samples &gt; 0, \"num_samples must be bigger than 0\"\n        assert edge is not None\n        assert len(faces) &gt; 0, \"Expect 1 or 2 faces adjacent to an edge\"\n\n        self.num_samples = num_samples\n        self.good = True\n        self.left_face, self.right_face = edge.find_left_and_right_faces(faces)\n        if self.left_face is None or self.right_face is None:\n            # Cope with case where the left and right face cannot be found\n            self.good = False\n            return\n\n        self.edge = edge\n        self.curve3d = edge.curve()\n        self.left_pcurve = BRepAdaptor_Curve2d(\n            edge.topods_shape(), self.left_face.topods_shape()\n        )\n        self.right_pcurve = BRepAdaptor_Curve2d(\n            edge.topods_shape(), self.right_face.topods_shape()\n        )\n\n        # Find the parameters to evaluate.   These will be\n        # ordered based on the reverse flag of the edge\n        if use_arclength_params:\n            self.u_params = self._find_arclength_parameters()\n        else:\n            self.u_params = self._find_uniform_parameters()\n        if not self.good:\n            return\n        self.left_uvs = self._find_uvs(self.left_pcurve)\n        self.right_uvs = self._find_uvs(self.right_pcurve)\n\n        # Find 3d points and tangents.\n        # These will be ordered and oriented based on the\n        # direction of the edge.  i.e. we will apply the reverse\n        # flag\n        self.points = self._evaluate_3d_points()\n        self.tangents = self._evaluate_curve_tangents()\n\n        # Generate the normals.  These will be ordered\n        # based on the direction of the edge and the\n        # normals will be reversed based on the orientation\n        # of the faces\n        self.left_normals = self._evaluate_surface_normals(\n            self.left_uvs, self.left_face\n        )\n        self.right_normals = self._evaluate_surface_normals(\n            self.right_uvs, self.right_face\n        )\n\n    def edge_convexity(self, angle_tol_rads):\n        \"\"\"\n        Compute the convexity of the edge\n        \"\"\"\n        assert self.good\n        is_smooth = self._check_smooth(angle_tol_rads)\n        if is_smooth:\n            return EdgeConvexity.SMOOTH\n\n        cross_prod_of_normals = np.cross(self.left_normals, self.right_normals, axis=1)\n        dot_product_with_tangents = np.multiply(\n            cross_prod_of_normals, self.tangents\n        ).sum(1)\n\n        if dot_product_with_tangents.sum() &gt; 0.0:\n            return EdgeConvexity.CONVEX\n        return EdgeConvexity.CONCAVE\n\n    def sanity_check_uvs(self, uvs, edge_tolerance):\n        \"\"\"\n        Assert that the points we get by evaluating uvs on both sides of the edge \n        are within the specified tolerance.\n\n        This function is intended for testing/debugging\n        \"\"\"\n        for u, left_uv, right_uv in zip(self.u_params, self.left_uvs, self.right_uvs):\n            point = self.edge.point(u)\n            point1 = self.left_face.point(left_uv)\n            point2 = self.right_face.point(right_uv)\n            assert np.linalg.norm(point - point1) &lt; edge_tolerance\n            assert np.linalg.norm(point - point2) &lt; edge_tolerance\n\n    \"\"\"\n    Private member functions\n    \"\"\"\n\n    def _check_smooth(self, angle_tol_rads):\n        dot_prod = np.multiply(self.left_normals, self.right_normals).sum(1)\n        average_dot_product = dot_prod.mean()\n        return average_dot_product &gt; np.cos(angle_tol_rads)\n\n    def _find_uniform_parameters(self):\n        interval = self.edge.u_bounds()\n        if interval.invalid():\n            self.good = False\n            return\n        params = []\n        for i in range(self.num_samples):\n            t = i / (self.num_samples - 1)\n            params.append(interval.interpolate(t))\n        # Now we need to check the orientation of the edge and\n        # reverse the array is necessary\n        if self.edge.reversed():\n            params.reverse()\n        return params\n\n    def _find_arclength_parameters(self):\n        arc_length_finder = ArcLengthParamFinder(edge=self.edge)\n        if not arc_length_finder.good:\n            self.good = False\n            return\n        arc_length_params = arc_length_finder.find_arc_length_parameters(\n            self.num_samples\n        )\n        # Now we need to check the orientation of the edge and\n        # reverse the array is necessary\n        if self.edge.reversed():\n            arc_length_params.reverse()\n        return arc_length_params\n\n    def _find_uvs(self, pcurve):\n        uvs = []\n        for u in self.u_params:\n            uv = gp_Pnt2d()\n            pcurve.D0(u, uv)\n            uv = np.array([uv.X(), uv.Y()])\n            uvs.append(uv)\n        return uvs\n\n    def _evaluate_3d_points(self):\n        points = []\n        for u in self.u_params:\n            point = self.edge.point(u)\n            points.append(point)\n        return np.stack(points)\n\n    def _evaluate_curve_tangents(self):\n        tangents = []\n        for u in self.u_params:\n            tangent = self.edge.tangent(u)\n            tangents.append(tangent)\n        return np.stack(tangents)\n\n    def _evaluate_surface_normals(self, uvs, face):\n        normals = []\n        for uv in uvs:\n            normal = face.normal(uv)\n            normals.append(normal)\n        return np.stack(normals)\n</code></pre>"},{"location":"api/#occwl.edge_data_extractor.EdgeDataExtractor.__init__","title":"<code>__init__(edge, faces, num_samples=10, use_arclength_params=True)</code>","text":"<p>Compute point and normal data for an oriented edge of the model. The arrays of points, tangents and normals are all oriented based on the orientation flag of the edge.</p> <p>You can access the data from the member numpy arrays</p> <pre><code>EdgeDataExtractor.points\nEdgeDataExtractor.tangests\nEdgeDataExtractor.left_normals\nEdgeDataExtractor.right_normals\n</code></pre> <p>If a problem was detected during the calculation then  EdgeDataExtractor.good == false</p> Source code in <code>src/occwl/edge_data_extractor.py</code> <pre><code>def __init__(self, edge, faces, num_samples=10, use_arclength_params=True):\n    \"\"\"\n    Compute point and normal data for an oriented edge of the model.\n    The arrays of points, tangents and normals are all oriented based\n    on the orientation flag of the edge.\n\n    You can access the data from the member numpy arrays\n\n        EdgeDataExtractor.points\n        EdgeDataExtractor.tangests\n        EdgeDataExtractor.left_normals\n        EdgeDataExtractor.right_normals\n\n    If a problem was detected during the calculation then \n    EdgeDataExtractor.good == false\n    \"\"\"\n    assert num_samples &gt; 0, \"num_samples must be bigger than 0\"\n    assert edge is not None\n    assert len(faces) &gt; 0, \"Expect 1 or 2 faces adjacent to an edge\"\n\n    self.num_samples = num_samples\n    self.good = True\n    self.left_face, self.right_face = edge.find_left_and_right_faces(faces)\n    if self.left_face is None or self.right_face is None:\n        # Cope with case where the left and right face cannot be found\n        self.good = False\n        return\n\n    self.edge = edge\n    self.curve3d = edge.curve()\n    self.left_pcurve = BRepAdaptor_Curve2d(\n        edge.topods_shape(), self.left_face.topods_shape()\n    )\n    self.right_pcurve = BRepAdaptor_Curve2d(\n        edge.topods_shape(), self.right_face.topods_shape()\n    )\n\n    # Find the parameters to evaluate.   These will be\n    # ordered based on the reverse flag of the edge\n    if use_arclength_params:\n        self.u_params = self._find_arclength_parameters()\n    else:\n        self.u_params = self._find_uniform_parameters()\n    if not self.good:\n        return\n    self.left_uvs = self._find_uvs(self.left_pcurve)\n    self.right_uvs = self._find_uvs(self.right_pcurve)\n\n    # Find 3d points and tangents.\n    # These will be ordered and oriented based on the\n    # direction of the edge.  i.e. we will apply the reverse\n    # flag\n    self.points = self._evaluate_3d_points()\n    self.tangents = self._evaluate_curve_tangents()\n\n    # Generate the normals.  These will be ordered\n    # based on the direction of the edge and the\n    # normals will be reversed based on the orientation\n    # of the faces\n    self.left_normals = self._evaluate_surface_normals(\n        self.left_uvs, self.left_face\n    )\n    self.right_normals = self._evaluate_surface_normals(\n        self.right_uvs, self.right_face\n    )\n</code></pre>"},{"location":"api/#occwl.edge_data_extractor.EdgeDataExtractor.edge_convexity","title":"<code>edge_convexity(angle_tol_rads)</code>","text":"<p>Compute the convexity of the edge</p> Source code in <code>src/occwl/edge_data_extractor.py</code> <pre><code>def edge_convexity(self, angle_tol_rads):\n    \"\"\"\n    Compute the convexity of the edge\n    \"\"\"\n    assert self.good\n    is_smooth = self._check_smooth(angle_tol_rads)\n    if is_smooth:\n        return EdgeConvexity.SMOOTH\n\n    cross_prod_of_normals = np.cross(self.left_normals, self.right_normals, axis=1)\n    dot_product_with_tangents = np.multiply(\n        cross_prod_of_normals, self.tangents\n    ).sum(1)\n\n    if dot_product_with_tangents.sum() &gt; 0.0:\n        return EdgeConvexity.CONVEX\n    return EdgeConvexity.CONCAVE\n</code></pre>"},{"location":"api/#occwl.edge_data_extractor.EdgeDataExtractor.sanity_check_uvs","title":"<code>sanity_check_uvs(uvs, edge_tolerance)</code>","text":"<p>Assert that the points we get by evaluating uvs on both sides of the edge  are within the specified tolerance.</p> <p>This function is intended for testing/debugging</p> Source code in <code>src/occwl/edge_data_extractor.py</code> <pre><code>def sanity_check_uvs(self, uvs, edge_tolerance):\n    \"\"\"\n    Assert that the points we get by evaluating uvs on both sides of the edge \n    are within the specified tolerance.\n\n    This function is intended for testing/debugging\n    \"\"\"\n    for u, left_uv, right_uv in zip(self.u_params, self.left_uvs, self.right_uvs):\n        point = self.edge.point(u)\n        point1 = self.left_face.point(left_uv)\n        point2 = self.right_face.point(right_uv)\n        assert np.linalg.norm(point - point1) &lt; edge_tolerance\n        assert np.linalg.norm(point - point2) &lt; edge_tolerance\n</code></pre>"},{"location":"api/#occwl.entity_mapper","title":"<code>entity_mapper</code>","text":"<p>The entity mapper allows you to map between occwl entities and integer identifiers which can be used as indices into arrays of feature vectors or the rows and columns of incidence matrices. </p> <p>NOTE:  </p> <pre><code>Only oriented edges which are used by wires are included in the oriented \nedge map.  In the case of edges which are open (i.e. they are adjacent\nto a hole in the solid), only one oriented edge is present. Use the function\n\nEntityMapper.oriented_edge_exists(oriented_edge)\n\nto check if an oriented edge is used by a wire and known to the entity mapper.\n</code></pre>"},{"location":"api/#occwl.entity_mapper.EntityMapper","title":"<code>EntityMapper</code>","text":"<p>This class allows us to map between occwl entities and integer identifiers which can be used as indices into arrays of feature vectors or the rows and columns of incidence matrices.</p> Source code in <code>src/occwl/entity_mapper.py</code> <pre><code>class EntityMapper:\n    \"\"\"\n    This class allows us to map between occwl entities and integer\n    identifiers which can be used as indices into arrays of feature vectors\n    or the rows and columns of incidence matrices. \n    \"\"\"\n\n    def __init__(self, solid):\n        \"\"\"\n        Create a mapper object for solid\n\n        Args:\n\n            solid (occwl.solid.Solid): A single solid\n        \"\"\"\n\n        # Create the dictionaries which will map the\n        # objects hash values to the indices.\n        self.face_map = dict()\n        self.wire_map = dict()\n        self.edge_map = dict()\n        self.oriented_edge_map = dict()\n        self.vertex_map = dict()\n\n        # Build the index lookup tables\n        self._append_faces(solid)\n        self._append_wires(solid)\n        self._append_edges(solid)\n        self._append_oriented_edges(solid)\n        self._append_vertices(solid)\n\n    # The following functions are the interface for\n    # users of the class to access the indices\n    # which will reptresent the Open Cascade entities\n\n    def get_num_edges(self):\n        return len(self.edge_map.keys())\n\n    def get_num_faces(self):\n        return len(self.face_map.keys())\n\n    def face_index(self, face):\n        \"\"\"\n        Find the index of a face\n        \"\"\"\n        h = self._get_hash(face)\n        return self.face_map[h]\n\n    def wire_index(self, wire):\n        \"\"\"\n        Find the index of a wire\n        \"\"\"\n        h = self._get_hash(wire)\n        return self.wire_map[h]\n\n    def edge_index(self, edge):\n        \"\"\"\n        Find the index of an edge\n        \"\"\"\n        h = self._get_hash(edge)\n        return self.edge_map[h]\n\n    def oriented_edge_index(self, oriented_edge):\n        \"\"\"\n        Find the index of a oriented edge.  i.e. a coedge\n        \"\"\"\n        h = self._get_hash(oriented_edge)\n        is_reversed = oriented_edge.reversed()\n        tup = (h, is_reversed)\n        return self.oriented_edge_map[tup]\n\n    def oriented_edge_exists(self, oriented_edge):\n        h = self._get_hash(oriented_edge)\n        is_reversed = oriented_edge.reversed()\n        tup = (h, is_reversed)\n        return tup in self.oriented_edge_map\n\n    def vertex_index(self, vertex):\n        \"\"\"\n        Find the index of a vertex\n        \"\"\"\n        h = self._get_hash(vertex)\n        return self.vertex_map[h]\n\n    # These functions are used internally to build the map\n\n    def _get_hash(self, ent):\n        return ent.__hash__()\n\n    def _append_faces(self, solid):\n        faces = solid.faces()\n        for face in faces:\n            self._append_face(face)\n\n    def _append_face(self, face):\n        h = self._get_hash(face)\n        index = len(self.face_map)\n        assert not h in self.face_map\n        self.face_map[h] = index\n\n    def _append_wires(self, solid):\n        wires = solid.wires()\n        for wire in wires:\n            self._append_wire(wire)\n\n    def _append_wire(self, wire):\n        h = self._get_hash(wire)\n        index = len(self.wire_map)\n        assert not h in self.wire_map\n        self.wire_map[h] = index\n\n    def _append_edges(self, solid):\n        edges = solid.edges()\n        for edge in edges:\n            self._append_edge(edge)\n\n    def _append_edge(self, edge):\n        h = self._get_hash(edge)\n        index = len(self.edge_map)\n        assert not h in self.edge_map\n        self.edge_map[h] = index\n\n    def _append_oriented_edges(self, solid):\n        wires = solid.wires()\n        for wire in wires:\n            oriented_edges = wire.ordered_edges()\n            for oriented_edge in oriented_edges:\n                self._append_oriented_edge(oriented_edge)\n\n    def _append_oriented_edge(self, oriented_edge):\n        h = self._get_hash(oriented_edge)\n        is_reversed = oriented_edge.reversed()\n        tup = (h, is_reversed)\n        index = len(self.oriented_edge_map)\n        if tup in self.oriented_edge_map:\n            print(\"Warning! - The same oriented edge appears twice in the same solid\")\n        if not tup in self.oriented_edge_map:\n            self.oriented_edge_map[tup] = index\n\n    def _append_vertices(self, solid):\n        vertices = solid.vertices()\n        for vertex in vertices:\n            self._append_vertex(vertex)\n\n    def _append_vertex(self, vertex):\n        h = self._get_hash(vertex)\n        index = len(self.vertex_map)\n        assert not h in self.vertex_map\n        self.vertex_map[h] = index\n</code></pre>"},{"location":"api/#occwl.entity_mapper.EntityMapper.__init__","title":"<code>__init__(solid)</code>","text":"<p>Create a mapper object for solid</p> <p>Args:</p> <pre><code>solid (occwl.solid.Solid): A single solid\n</code></pre> Source code in <code>src/occwl/entity_mapper.py</code> <pre><code>def __init__(self, solid):\n    \"\"\"\n    Create a mapper object for solid\n\n    Args:\n\n        solid (occwl.solid.Solid): A single solid\n    \"\"\"\n\n    # Create the dictionaries which will map the\n    # objects hash values to the indices.\n    self.face_map = dict()\n    self.wire_map = dict()\n    self.edge_map = dict()\n    self.oriented_edge_map = dict()\n    self.vertex_map = dict()\n\n    # Build the index lookup tables\n    self._append_faces(solid)\n    self._append_wires(solid)\n    self._append_edges(solid)\n    self._append_oriented_edges(solid)\n    self._append_vertices(solid)\n</code></pre>"},{"location":"api/#occwl.entity_mapper.EntityMapper.edge_index","title":"<code>edge_index(edge)</code>","text":"<p>Find the index of an edge</p> Source code in <code>src/occwl/entity_mapper.py</code> <pre><code>def edge_index(self, edge):\n    \"\"\"\n    Find the index of an edge\n    \"\"\"\n    h = self._get_hash(edge)\n    return self.edge_map[h]\n</code></pre>"},{"location":"api/#occwl.entity_mapper.EntityMapper.face_index","title":"<code>face_index(face)</code>","text":"<p>Find the index of a face</p> Source code in <code>src/occwl/entity_mapper.py</code> <pre><code>def face_index(self, face):\n    \"\"\"\n    Find the index of a face\n    \"\"\"\n    h = self._get_hash(face)\n    return self.face_map[h]\n</code></pre>"},{"location":"api/#occwl.entity_mapper.EntityMapper.oriented_edge_index","title":"<code>oriented_edge_index(oriented_edge)</code>","text":"<p>Find the index of a oriented edge.  i.e. a coedge</p> Source code in <code>src/occwl/entity_mapper.py</code> <pre><code>def oriented_edge_index(self, oriented_edge):\n    \"\"\"\n    Find the index of a oriented edge.  i.e. a coedge\n    \"\"\"\n    h = self._get_hash(oriented_edge)\n    is_reversed = oriented_edge.reversed()\n    tup = (h, is_reversed)\n    return self.oriented_edge_map[tup]\n</code></pre>"},{"location":"api/#occwl.entity_mapper.EntityMapper.vertex_index","title":"<code>vertex_index(vertex)</code>","text":"<p>Find the index of a vertex</p> Source code in <code>src/occwl/entity_mapper.py</code> <pre><code>def vertex_index(self, vertex):\n    \"\"\"\n    Find the index of a vertex\n    \"\"\"\n    h = self._get_hash(vertex)\n    return self.vertex_map[h]\n</code></pre>"},{"location":"api/#occwl.entity_mapper.EntityMapper.wire_index","title":"<code>wire_index(wire)</code>","text":"<p>Find the index of a wire</p> Source code in <code>src/occwl/entity_mapper.py</code> <pre><code>def wire_index(self, wire):\n    \"\"\"\n    Find the index of a wire\n    \"\"\"\n    h = self._get_hash(wire)\n    return self.wire_map[h]\n</code></pre>"},{"location":"api/#occwl.face","title":"<code>face</code>","text":""},{"location":"api/#occwl.face.Face","title":"<code>Face</code>","text":"<p>               Bases: <code>Shape</code>, <code>BoundingBoxMixin</code>, <code>TriangulatorMixin</code>, <code>WireContainerMixin</code>, <code>EdgeContainerMixin</code>, <code>VertexContainerMixin</code>, <code>SurfacePropertiesMixin</code></p> <p>A topological face in a solid model Represents a 3D surface bounded by a Wire</p> Source code in <code>src/occwl/face.py</code> <pre><code>class Face(Shape, BoundingBoxMixin, TriangulatorMixin, WireContainerMixin, \\\n    EdgeContainerMixin, VertexContainerMixin, SurfacePropertiesMixin):\n    \"\"\"\n    A topological face in a solid model\n    Represents a 3D surface bounded by a Wire\n    \"\"\"\n\n    def __init__(self, topods_face):\n        assert isinstance(topods_face, TopoDS_Face)\n        super().__init__(topods_face)\n        self._trimmed = BRepTopAdaptor_FClass2d(self.topods_shape(), 1e-9)\n\n    @staticmethod\n    def make_prism(profile_edge, vector, return_first_last_shapes=False):\n        \"\"\"\n        Make a face from a profile edge by sweeping/extrusion\n\n        Args:\n            profile_edge (occwl.edge.Edge): Edge\n            vector (np.ndarray): Direction and length of extrusion\n            return_first_last_shapes (bool, optional): Whether to return the base and top shapes of the result. Defaults to False.\n\n        Returns:\n            occwl.Face: Face created by sweeping the edge\n            or None: if error\n            occwl.Edge, occwl.Edge (optional): Returns the base and top edges of return_first_last_shapes is True.\n        \"\"\"\n        assert isinstance(profile_edge, Edge)\n        gp_vector = geom_utils.numpy_to_gp_vec(vector)\n        prism = BRepPrimAPI_MakePrism(profile_edge.topods_shape(), gp_vector)\n        if not prism.IsDone():\n            return None\n        if return_first_last_shapes:\n            return (\n                Face(prism.Shape()),\n                Edge(prism.FirstShape()),\n                Edge(prism.LastShape()),\n            )\n        return Face(prism.Shape())\n\n    @staticmethod\n    def make_nsided(edges, continuity=\"C0\", points=None):\n        \"\"\"\n        Make an n-sided fill-in face with the given edges, their continuities, and optionally a\n        set of punctual points\n\n        Args:\n            edges (List[occwl.edge.Edge]): A list of edges for creating the fill-in face\n            continuity (str or List[str]): A single string or a list of strings, one for each given edge.\n                                           Must be one of \"C0\", \"C1\", \"G1\", \"C2\", \"G2\", \"C3\"\n            points (np.ndarray, optional): Set of points to constrain the fill-in surface. Defaults to None.\n\n        Returns:\n            occwl.face.Face: Filled-in face\n        \"\"\"\n        fill = BRepFill_Filling()\n\n        # A helper function to convert strings to Geom_Abs_ enums\n        def str_to_continuity(string):\n            if string == \"C0\":\n                return GeomAbs_C0\n            elif string == \"C1\":\n                return GeomAbs_C1\n            elif string == \"G1\":\n                return GeomAbs_G1\n            elif string == \"C2\":\n                return GeomAbs_C2\n            elif string == \"G2\":\n                return GeomAbs_G2\n            elif string == \"C3\":\n                return GeomAbs_C3\n\n        if isinstance(continuity, str):\n            assert continuity in (\"C0\", \"C1\", \"C2\")\n            occ_continuity = str_to_continuity(continuity)\n            for edg in edges:\n                fill.Add(edg.topods_shape(), occ_continuity)\n        elif isinstance(continuity, list):\n            assert len(edges) == len(continuity), \"Continuity should be provided for each edge\"\n            for edg, cont in zip(edges, continuity):\n                occ_cont = str_to_continuity(cont)\n                fill.Add(edg.topods_shape(), occ_cont)\n\n        # Add points to contrain shape if provided\n        if points:\n            for pt in points:\n                fill.Add(geom_utils.to_gp_pnt(pt))\n        fill.Build()\n        face = fill.Face()\n        return Face(face)\n\n    @staticmethod\n    def make_from_wires(wires):\n        \"\"\"\n        Make a face from PLANAR wires\n\n        Args:\n            wires (List[occwl.wire.Wire]): List of wires\n\n        Returns:\n            occwl.face.Face or None: Returns a Face or None if the operation failed\n        \"\"\"\n        face_builder = BRepBuilderAPI_MakeFace()\n        for wire in wires:\n            face_builder.Add(wire.topods_shape())\n        face_builder.Build()\n        if not face_builder.IsDone():\n            return None\n        return Face(face_builder.Face())\n\n    def inside(self, uv):\n        \"\"\"\n        Check if the uv-coordinate is inside the visible region of the face (excludes points that lie on the boundary)\n\n        Args:\n            uv (np.ndarray or tuple): Surface parameter\n\n        Returns:\n            bool: Is inside\n        \"\"\"\n        result = self._trimmed.Perform(gp_Pnt2d(uv[0], uv[1]))\n        return result == TopAbs_IN\n\n    def visibility_status(self, uv):\n        \"\"\"\n        Check if the uv-coordinate in on the visible region of the face\n\n        Args:\n            uv (np.ndarray or tuple): Surface parameter\n\n        Returns:\n            int (TopAbs_STATE enum): 0: TopAbs_IN, 1: TopAbs_OUT, 2: TopAbs_ON, 3: TopAbs_UNKNOWN\n        \"\"\"\n        result = self._trimmed.Perform(gp_Pnt2d(uv[0], uv[1]))\n        return int(result)\n\n    def surface(self):\n        \"\"\"\n        Get the face surface geometry\n\n        Returns:\n            OCC.Geom.Handle_Geom_Surface: Interface to all surface geometry\n        \"\"\"\n        loc = TopLoc_Location()\n        surf = BRep_Tool_Surface(self.topods_shape(), loc)\n        if not loc.IsIdentity():\n            tsf = loc.Transformation()\n            np_tsf = geom_utils.to_numpy(tsf)\n            assert np.allclose(np_tsf, np.eye(4)), \\\n                \"Requesting surface for transformed face. /n\\\n                Call solid.set_transform_to_identity() to remove the transform \\\n                or compound.Transform(np.eye(4)) to bake in the assembly transform\"\n        return surf\n\n    def reversed_face(self):\n        \"\"\"\n        Return a copy of this face with the orientation reversed.\n\n        Returns:\n            occwl.face.Face: A face with the opposite orientation to this face.\n        \"\"\"\n        return Face(self.topods_shape().Reversed())\n\n    def specific_surface(self):\n        \"\"\"\n        Get the specific face surface geometry\n\n        Returns:\n            OCC.Geom.Handle_Geom_*: Specific geometry type for the surface geometry\n        \"\"\"\n        if not self.topods_shape().Location().IsIdentity():\n            tsf = self.topods_shape().Location().Transformation()\n            np_tsf = geom_utils.to_numpy(tsf)\n            assert np.allclose(np_tsf, np.eye(4)), \\\n                \"Requesting surface for transformed face. /n\\\n                Call solid.set_transform_to_identity() to remove the transform /n\\\n                or compound.transform(np.eye(4)) to bake in the assembly transform\"\n        srf = BRepAdaptor_Surface(self.topods_shape())\n        surf_type = self.surface_type()\n        if surf_type == \"plane\":\n            return srf.Plane()\n        if surf_type == \"cylinder\":\n            return srf.Cylinder()\n        if surf_type == \"cone\":\n            return srf.Cone()\n        if surf_type == \"sphere\":\n            return srf.Sphere()\n        if surf_type == \"torus\":\n            return srf.Torus()\n        if surf_type == \"bezier\":\n            return srf.Bezier()\n        if surf_type == \"bspline\":\n            return srf.BSpline()\n        raise ValueError(\"Unknown surface type: \", surf_type)\n\n\n    def point(self, uv):\n        \"\"\"\n        Evaluate the face geometry at given parameter\n\n        Args:\n            uv (np.ndarray or tuple): Surface parameter\n\n        Returns:\n            np.ndarray: 3D Point\n        \"\"\"\n        loc = TopLoc_Location()\n        surf = BRep_Tool_Surface(self.topods_shape(), loc)\n        pt = surf.Value(uv[0], uv[1])\n        pt = pt.Transformed(loc.Transformation())\n        return geom_utils.gp_to_numpy(pt)\n\n    def tangent(self, uv):\n        \"\"\"\n        Compute the tangents of the surface geometry at given parameter\n\n        Args:\n            uv (np.ndarray or tuple): Surface parameter\n\n        Returns:\n            Pair of np.ndarray or None: 3D unit vectors\n        \"\"\"\n        loc = TopLoc_Location()\n        surf = BRep_Tool_Surface(self.topods_shape(), loc)\n        dU, dV = gp_Dir(), gp_Dir()\n        res = GeomLProp_SLProps(surf, uv[0], uv[1], 1, 1e-9)\n        if res.IsTangentUDefined() and res.IsTangentVDefined():\n            res.TangentU(dU), res.TangentV(dV)\n            dU.Transformed(loc.Transformation())\n            dV.Transformed(loc.Transformation())\n            return (geom_utils.gp_to_numpy(dU)), (geom_utils.gp_to_numpy(dV))\n        return None, None\n\n    def normal(self, uv):\n        \"\"\"\n        Compute the normal of the surface geometry at given parameter\n\n        Args:\n            uv (np.ndarray or tuple): Surface parameter\n\n        Returns:\n            np.ndarray: 3D unit normal vector\n        \"\"\"\n        loc = TopLoc_Location()\n        surf = BRep_Tool_Surface(self.topods_shape(), loc)\n        res = GeomLProp_SLProps(surf, uv[0], uv[1], 1, 1e-9)\n        if not res.IsNormalDefined():\n            return (0, 0, 0)\n        gp_normal = res.Normal()\n        gp_normal.Transformed(loc.Transformation())\n        normal = geom_utils.gp_to_numpy(gp_normal)\n        if self.reversed():\n            normal = -normal\n        return normal\n\n    def is_left_of(self, edge):\n        \"\"\"\n        Is this face on the left hand side of the given edge.   We take the \n        orientation of the edge into account here\n\n                     Edge direction\n                            ^\n                            |   \n                  Left      |   Right \n                  face      |   face\n                            |\n        Args:\n            edge (occwl.edge.Edge): Edge\n\n        Returns:\n            bool: True if the face is to the left of the edge\n        \"\"\"\n        found_edge = False\n        for wire in self.wires():\n            for edge_from_face in wire.ordered_edges():\n                if edge == edge_from_face:\n                    if edge.reversed() == edge_from_face.reversed():\n                        return True\n                    else:\n                        # We found the edge, but so far we only found an edge\n                        # with orientation such that the face is on the right\n                        found_edge = True\n\n        # If we didn't find the edge at all then this function was used incorrectly.\n        # To use it you need to pass in a edge around the given face.  Assert and warn \n        # the user\n        assert found_edge, \"Edge doesn't belong to face\"\n\n        # We found an edge for which this face was on the right hand side,\n        # but not one of the left hand side\n        return False\n\n    def gaussian_curvature(self, uv):\n        \"\"\"\n        Compute the gaussian curvature of the surface geometry at given parameter\n\n        Args:\n            uv (np.ndarray or tuple): Surface parameter\n\n        Returns:\n            float: Gaussian curvature\n        \"\"\"\n        return GeomLProp_SLProps(\n            self.surface(), uv[0], uv[1], 2, 1e-9\n        ).GaussianCurvature()\n\n    def min_curvature(self, uv):\n        \"\"\"\n        Compute the minimum curvature of the surface geometry at given parameter\n\n        Args:\n            uv (np.ndarray or tuple): Surface parameter\n\n        Returns:\n            float: Min. curvature\n        \"\"\"\n        min_curv = GeomLProp_SLProps(\n            self.surface(), uv[0], uv[1], 2, 1e-9\n        ).MinCurvature()\n        if self.reversed():\n            min_curv *= -1\n        return min_curv\n\n    def mean_curvature(self, uv):\n        \"\"\"\n        Compute the mean curvature of the surface geometry at given parameter\n\n        Args:\n            uv (np.ndarray or tuple): Surface parameter\n\n        Returns:\n            float: Mean curvature\n        \"\"\"\n        mean_curv = GeomLProp_SLProps(\n            self.surface(), uv[0], uv[1], 2, 1e-9\n        ).MeanCurvature()\n        if self.reversed():\n            mean_curv *= -1\n        return mean_curv\n\n    def max_curvature(self, uv):\n        \"\"\"\n        Compute the maximum curvature of the surface geometry at given parameter\n\n        Args:\n            uv (np.ndarray or tuple): Surface parameter\n\n        Returns:\n            float: Max. curvature\n        \"\"\"\n        max_curv = GeomLProp_SLProps(\n            self.surface(), uv[0], uv[1], 2, 1e-9\n        ).MaxCurvature()\n        if self.reversed():\n            max_curv *= -1\n        return max_curv\n\n    def pcurve(self, edge):\n        \"\"\"\n        Get the given edge's curve geometry as a 2D parametric curve\n        on this face\n\n        Args:\n            edge (occwl.edge.Edge): Edge\n\n        Returns:\n            Geom2d_Curve: 2D curve\n            Interval: domain of the parametric curve\n        \"\"\"\n        crv, umin, umax = BRep_Tool().CurveOnSurface(\n            edge.topods_shape(), self.topods_shape()\n        )\n        return crv, Interval(umin, umax)\n\n    def uv_bounds(self):\n        \"\"\"\n        Get the UV-domain bounds of this face's surface geometry\n\n        Returns:\n            Box: UV-domain bounds\n        \"\"\"\n        umin, umax, vmin, vmax = breptools_UVBounds(self.topods_shape())\n        bounds = Box(np.array([umin, vmin]))\n        bounds.encompass_point(np.array([umax, vmax]))\n        return bounds\n\n    def point_to_parameter(self, pt):\n        \"\"\"\n        Get the UV parameter by projecting the point on this face\n\n        Args:\n            pt (np.ndarray): 3D point\n\n        Returns:\n            np.ndarray: UV-coordinate\n        \"\"\"\n        loc = TopLoc_Location()\n        surf = BRep_Tool_Surface(self.topods_shape(), loc)\n        gp_pt = gp_Pnt(pt[0], pt[1], pt[2])\n        inv = loc.Transformation().Inverted()\n        gp_pt.Transformed(inv)\n        uv = ShapeAnalysis_Surface(surf).ValueOfUV(\n            gp_pt, 1e-9\n        )\n        return np.array(uv.Coord())\n\n    def surface_type(self):\n        \"\"\"\n        Get the type of the surface geometry\n\n        Returns:\n            str: Type of the surface geometry\n        \"\"\"\n        surf_type = BRepAdaptor_Surface(self.topods_shape()).GetType()\n        if surf_type == GeomAbs_Plane:\n            return \"plane\"\n        if surf_type == GeomAbs_Cylinder:\n            return \"cylinder\"\n        if surf_type == GeomAbs_Cone:\n            return \"cone\"\n        if surf_type == GeomAbs_Sphere:\n            return \"sphere\"\n        if surf_type == GeomAbs_Torus:\n            return \"torus\"\n        if surf_type == GeomAbs_BezierSurface:\n            return \"bezier\"\n        if surf_type == GeomAbs_BSplineSurface:\n            return \"bspline\"\n        if surf_type == GeomAbs_SurfaceOfRevolution:\n            return \"revolution\"\n        if surf_type == GeomAbs_SurfaceOfExtrusion:\n            return \"extrusion\"\n        if surf_type == GeomAbs_OffsetSurface:\n            return \"offset\"\n        if surf_type == GeomAbs_OtherSurface:\n            return \"other\"\n        return \"unknown\"\n\n    def surface_type_enum(self):\n        \"\"\"\n        Get the type of the surface geometry as an OCC.Core.GeomAbs enum\n\n        Returns:\n            OCC.Core.GeomAbs: Type of the surface geometry\n        \"\"\"\n        return BRepAdaptor_Surface(self.topods_shape()).GetType()\n\n    def closed_u(self):\n        \"\"\"\n        Whether the surface is closed along the U-direction\n\n        Returns:\n            bool: Is closed along U\n        \"\"\"\n        sa = ShapeAnalysis_Surface(self.surface())\n        return sa.IsUClosed()\n\n    def closed_v(self):\n        \"\"\"\n        Whether the surface is closed along the V-direction\n\n        Returns:\n            bool: Is closed along V\n        \"\"\"\n        sa = ShapeAnalysis_Surface(self.surface())\n        return sa.IsVClosed()\n\n    def periodic_u(self):\n        \"\"\"\n        Whether the surface is periodic along the U-direction\n\n        Returns:\n            bool: Is periodic along U\n        \"\"\"\n        adaptor = BRepAdaptor_Surface(self.topods_shape())\n        return adaptor.IsUPeriodic()\n\n    def periodic_v(self):\n        \"\"\"\n        Whether the surface is periodic along the V-direction\n\n        Returns:\n            bool: Is periodic along V\n        \"\"\"\n        adaptor = BRepAdaptor_Surface(self.topods_shape())\n        return adaptor.IsVPeriodic()\n\n    def get_triangles(self, return_normals=False):\n        \"\"\"\n        Get the tessellation of this face as a triangle mesh\n        NOTE: First you must call shape.triangulate_all_faces()\n        Then call this method to get the triangles for the\n        face.\n\n        Args:\n            return_normals (bool): Return vertex normals\n\n        Returns:\n            2D np.ndarray: Vertices\n            2D np.ndarray: Faces\n            2D np.ndarray: Vertex Normals (when return_normals is True)\n        \"\"\"\n        location = TopLoc_Location()\n        bt = BRep_Tool()\n        facing = bt.Triangulation(self.topods_shape(), location)\n        if facing == None:\n            if return_normals:\n                return (\n                    np.empty(shape=(0,3), dtype=np.float32),\n                    np.empty(shape=(0,3), dtype=np.int32),\n                    np.empty(shape=(0,3), dtype=np.float32)\n                )\n            else:\n                return (\n                    np.empty(shape=(0,3), dtype=np.float32),\n                    np.empty(shape=(0,3), dtype=np.int32)\n                )\n\n        vert_nodes = facing.Nodes()\n        tri = facing.Triangles()\n        uv_nodes = facing.UVNodes()\n        verts = []\n        normals = []\n        for i in range(1, facing.NbNodes() + 1):\n            vert = vert_nodes.Value(i).Transformed(location.Transformation())\n            verts.append(np.array(list(vert.Coord())))\n            if return_normals:\n                uv = uv_nodes.Value(i).Coord()\n                normal = self.normal(uv)\n                normals.append(normal)\n\n        tris = []\n        reversed = self.reversed()\n        for i in range(1, facing.NbTriangles() + 1):\n            # OCC triangle normals point in the surface normal\n            # direction\n            if reversed:\n                index1, index3, index2 = tri.Value(i).Get()\n            else:\n                index1, index2, index3 = tri.Value(i).Get()\n\n            tris.append([index1 - 1, index2 - 1, index3 - 1])\n\n        np_verts = np.asarray(verts, dtype=np.float32)\n        np_tris = np.asarray(tris, dtype=np.int32)\n\n        if return_normals:\n            np_normals = np.asarray(normals, dtype=np.float32)\n            return np_verts, np_tris, np_normals\n        else:\n            return np_verts, np_tris\n</code></pre>"},{"location":"api/#occwl.face.Face.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Equality check for the shape</p> <p>NOTE: This function only checks if the shape is the same. It doesn't check the edge orienation for example, so </p> <p>edge1 == edge2</p> <p>does not necessarily mean </p> <p>edge1.reversed() == edge2.reversed()</p> Source code in <code>src/occwl/shape.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"\n    Equality check for the shape\n\n    NOTE: This function only checks if the shape is the same.\n    It doesn't check the edge orienation for example, so \n\n    edge1 == edge2\n\n    does not necessarily mean \n\n    edge1.reversed() == edge2.reversed()\n    \"\"\"\n    return self.topods_shape().__hash__() == other.topods_shape().__hash__()\n</code></pre>"},{"location":"api/#occwl.face.Face.__hash__","title":"<code>__hash__()</code>","text":"<p>Hash for the shape</p> <p>Returns:</p> Name Type Description <code>int</code> <p>Hash value</p> Source code in <code>src/occwl/shape.py</code> <pre><code>def __hash__(self):\n    \"\"\"\n    Hash for the shape\n\n    Returns:\n        int: Hash value\n    \"\"\"\n    return self.topods_shape().__hash__()\n</code></pre>"},{"location":"api/#occwl.face.Face.area","title":"<code>area()</code>","text":"<p>Compute the area of the Shape</p> <p>Returns:</p> Name Type Description <code>float</code> <p>Area</p> Source code in <code>src/occwl/base.py</code> <pre><code>def area(self):\n    \"\"\"\n    Compute the area of the Shape\n\n    Returns:\n        float: Area\n    \"\"\"\n    geometry_properties = GProp_GProps()\n    brepgprop_SurfaceProperties(self.topods_shape(), geometry_properties)\n    return geometry_properties.Mass()\n</code></pre>"},{"location":"api/#occwl.face.Face.box","title":"<code>box()</code>","text":"<p>Get a quick bounding box of the Shape</p> <p>Returns:</p> Name Type Description <code>Box</code> <p>Bounding box</p> Source code in <code>src/occwl/base.py</code> <pre><code>def box(self):\n    \"\"\"\n    Get a quick bounding box of the Shape\n\n    Returns:\n        Box: Bounding box\n    \"\"\"\n    from occwl.geometry import geom_utils\n    b = Bnd_Box()\n    brepbndlib_Add(self.topods_shape(), b)\n    return geom_utils.box_to_geometry(b)\n</code></pre>"},{"location":"api/#occwl.face.Face.closed_u","title":"<code>closed_u()</code>","text":"<p>Whether the surface is closed along the U-direction</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>Is closed along U</p> Source code in <code>src/occwl/face.py</code> <pre><code>def closed_u(self):\n    \"\"\"\n    Whether the surface is closed along the U-direction\n\n    Returns:\n        bool: Is closed along U\n    \"\"\"\n    sa = ShapeAnalysis_Surface(self.surface())\n    return sa.IsUClosed()\n</code></pre>"},{"location":"api/#occwl.face.Face.closed_v","title":"<code>closed_v()</code>","text":"<p>Whether the surface is closed along the V-direction</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>Is closed along V</p> Source code in <code>src/occwl/face.py</code> <pre><code>def closed_v(self):\n    \"\"\"\n    Whether the surface is closed along the V-direction\n\n    Returns:\n        bool: Is closed along V\n    \"\"\"\n    sa = ShapeAnalysis_Surface(self.surface())\n    return sa.IsVClosed()\n</code></pre>"},{"location":"api/#occwl.face.Face.convert_geometric_identity_transforms_to_identity","title":"<code>convert_geometric_identity_transforms_to_identity()</code>","text":"<p>Open Cascade models sometimes contain transforms which are \"geometrically\" identify transforms, but the identity flag is not set.</p> <p>This function checks each transform and sets the flag if  the appropriate.</p> Source code in <code>src/occwl/shape.py</code> <pre><code>def convert_geometric_identity_transforms_to_identity(self):\n    \"\"\"\n    Open Cascade models sometimes contain transforms which\n    are \"geometrically\" identify transforms, but the identity\n    flag is not set.\n\n    This function checks each transform and sets the flag if \n    the appropriate.\n    \"\"\"\n    identity = TopLoc_Location()\n    if geom_utils.is_geometric_identity(\n        self.topods_shape().Location().Transformation()\n    ):\n        self.topods_shape().Location(identity)\n        self._top_exp = TopologyUtils.TopologyExplorer(self.topods_shape(), True)\n\n    for face in self._top_exp.faces():\n        if geom_utils.is_geometric_identity(face.Location().Transformation()):\n            face.Location(identity)\n\n    for edge in self._top_exp.edges():\n        if geom_utils.is_geometric_identity(edge.Location().Transformation()):\n            edge.Location(identity)\n\n    for vertex in self._top_exp.vertices():\n        if geom_utils.is_geometric_identity(vertex.Location().Transformation()):\n            vertex.Location(identity)\n</code></pre>"},{"location":"api/#occwl.face.Face.edges","title":"<code>edges()</code>","text":"<p>Get an iterator to go over all edges in the Shape</p> <p>Returns:</p> Type Description <p>Iterator[occwl.edge.Edge]: Edge iterator</p> Source code in <code>src/occwl/base.py</code> <pre><code>def edges(self):\n    \"\"\"\n    Get an iterator to go over all edges in the Shape\n\n    Returns:\n        Iterator[occwl.edge.Edge]: Edge iterator\n    \"\"\"\n    from occwl.edge import Edge\n    return map(Edge, self._top_exp.edges())\n</code></pre>"},{"location":"api/#occwl.face.Face.exact_box","title":"<code>exact_box(use_shapetolerance=False)</code>","text":"<p>Get a slow, but accurate box for the Shape.</p> <p>Returns:</p> Name Type Description <code>Box</code> <p>Bounding box</p> Source code in <code>src/occwl/base.py</code> <pre><code>def exact_box(self, use_shapetolerance=False):\n    \"\"\"\n    Get a slow, but accurate box for the Shape.\n\n    Args:\n        use_shapetolerance (bool, optional) Include the tolerance of edges\n                                            and vertices in the box.\n\n    Returns:\n        Box: Bounding box\n    \"\"\"\n    from occwl.geometry import geom_utils\n    b = Bnd_Box()\n    use_triangulation = True\n    brepbndlib_AddOptimal(self.topods_shape(), b, use_triangulation, use_shapetolerance)\n    return geom_utils.box_to_geometry(b)\n</code></pre>"},{"location":"api/#occwl.face.Face.find_closest_edge_slow","title":"<code>find_closest_edge_slow(datum)</code>","text":"<p>Find the closest edge to the given datum point. The function is for testing only.  It will be slow  as it loops over all edges in the Shape. A quick way to find the closest entity is to call Shape.find_closest_point_data(), but then you may get a face, edge or vertex back.</p> <p>Parameters:</p> Name Type Description Default <code>datum</code> <code>ndarray or tuple</code> <p>3D datum point</p> required <p>Returns:</p> Name Type Description <code>Face</code> <p>The closest face in the Shape</p> Source code in <code>src/occwl/base.py</code> <pre><code>def find_closest_edge_slow(self, datum):\n    \"\"\"\n    Find the closest edge to the given datum point.\n    The function is for testing only.  It will be slow \n    as it loops over all edges in the Shape.\n    A quick way to find the closest entity is to call\n    Shape.find_closest_point_data(), but then you\n    may get a face, edge or vertex back.\n\n    Args:\n        datum (np.ndarray or tuple): 3D datum point\n\n    Returns:\n        Face: The closest face in the Shape\n    \"\"\"\n    return _find_closest_shape_in_list(self.edges(), datum)\n</code></pre>"},{"location":"api/#occwl.face.Face.find_closest_point_data","title":"<code>find_closest_point_data(datum)</code>","text":"<p>Find the information about the closest point on this shape</p> <p>Parameters:</p> Name Type Description Default <code>datum</code> <code>ndarray</code> <p>3D Point</p> required <p>Returns:</p> Name Type Description <code>ClosestPointData</code> <p>Data about the closest point on this shape</p> <code>None</code> <p>if error</p> Source code in <code>src/occwl/shape.py</code> <pre><code>def find_closest_point_data(self, datum):\n    \"\"\"\n    Find the information about the closest point on this shape\n\n    Args:\n        datum (np.ndarray): 3D Point\n\n    Returns:\n        ClosestPointData: Data about the closest point on this shape\n        None: if error\n    \"\"\"\n    # Folowing https://dev.opencascade.org/content/how-retrieve-nearest-face-shape-given-gppnt\n    # Create a vertex from the point\n    occ_point = geom_utils.numpy_to_gp(datum)\n    vertex_maker = BRepBuilderAPI_MakeVertex(occ_point)\n    vertex = vertex_maker.Shape()\n    dist_shape_shape = BRepExtrema_DistShapeShape(\n        vertex, self.topods_shape(), Extrema_ExtFlag_MIN\n    )\n    ok = dist_shape_shape.Perform()\n    if not ok:\n        return None\n\n    return ClosestPointData(dist_shape_shape)\n</code></pre>"},{"location":"api/#occwl.face.Face.gaussian_curvature","title":"<code>gaussian_curvature(uv)</code>","text":"<p>Compute the gaussian curvature of the surface geometry at given parameter</p> <p>Parameters:</p> Name Type Description Default <code>uv</code> <code>ndarray or tuple</code> <p>Surface parameter</p> required <p>Returns:</p> Name Type Description <code>float</code> <p>Gaussian curvature</p> Source code in <code>src/occwl/face.py</code> <pre><code>def gaussian_curvature(self, uv):\n    \"\"\"\n    Compute the gaussian curvature of the surface geometry at given parameter\n\n    Args:\n        uv (np.ndarray or tuple): Surface parameter\n\n    Returns:\n        float: Gaussian curvature\n    \"\"\"\n    return GeomLProp_SLProps(\n        self.surface(), uv[0], uv[1], 2, 1e-9\n    ).GaussianCurvature()\n</code></pre>"},{"location":"api/#occwl.face.Face.get_triangles","title":"<code>get_triangles(return_normals=False)</code>","text":"<p>Get the tessellation of this face as a triangle mesh NOTE: First you must call shape.triangulate_all_faces() Then call this method to get the triangles for the face.</p> <p>Parameters:</p> Name Type Description Default <code>return_normals</code> <code>bool</code> <p>Return vertex normals</p> <code>False</code> <p>Returns:</p> Type Description <p>2D np.ndarray: Vertices</p> <p>2D np.ndarray: Faces</p> <p>2D np.ndarray: Vertex Normals (when return_normals is True)</p> Source code in <code>src/occwl/face.py</code> <pre><code>def get_triangles(self, return_normals=False):\n    \"\"\"\n    Get the tessellation of this face as a triangle mesh\n    NOTE: First you must call shape.triangulate_all_faces()\n    Then call this method to get the triangles for the\n    face.\n\n    Args:\n        return_normals (bool): Return vertex normals\n\n    Returns:\n        2D np.ndarray: Vertices\n        2D np.ndarray: Faces\n        2D np.ndarray: Vertex Normals (when return_normals is True)\n    \"\"\"\n    location = TopLoc_Location()\n    bt = BRep_Tool()\n    facing = bt.Triangulation(self.topods_shape(), location)\n    if facing == None:\n        if return_normals:\n            return (\n                np.empty(shape=(0,3), dtype=np.float32),\n                np.empty(shape=(0,3), dtype=np.int32),\n                np.empty(shape=(0,3), dtype=np.float32)\n            )\n        else:\n            return (\n                np.empty(shape=(0,3), dtype=np.float32),\n                np.empty(shape=(0,3), dtype=np.int32)\n            )\n\n    vert_nodes = facing.Nodes()\n    tri = facing.Triangles()\n    uv_nodes = facing.UVNodes()\n    verts = []\n    normals = []\n    for i in range(1, facing.NbNodes() + 1):\n        vert = vert_nodes.Value(i).Transformed(location.Transformation())\n        verts.append(np.array(list(vert.Coord())))\n        if return_normals:\n            uv = uv_nodes.Value(i).Coord()\n            normal = self.normal(uv)\n            normals.append(normal)\n\n    tris = []\n    reversed = self.reversed()\n    for i in range(1, facing.NbTriangles() + 1):\n        # OCC triangle normals point in the surface normal\n        # direction\n        if reversed:\n            index1, index3, index2 = tri.Value(i).Get()\n        else:\n            index1, index2, index3 = tri.Value(i).Get()\n\n        tris.append([index1 - 1, index2 - 1, index3 - 1])\n\n    np_verts = np.asarray(verts, dtype=np.float32)\n    np_tris = np.asarray(tris, dtype=np.int32)\n\n    if return_normals:\n        np_normals = np.asarray(normals, dtype=np.float32)\n        return np_verts, np_tris, np_normals\n    else:\n        return np_verts, np_tris\n</code></pre>"},{"location":"api/#occwl.face.Face.inside","title":"<code>inside(uv)</code>","text":"<p>Check if the uv-coordinate is inside the visible region of the face (excludes points that lie on the boundary)</p> <p>Parameters:</p> Name Type Description Default <code>uv</code> <code>ndarray or tuple</code> <p>Surface parameter</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>Is inside</p> Source code in <code>src/occwl/face.py</code> <pre><code>def inside(self, uv):\n    \"\"\"\n    Check if the uv-coordinate is inside the visible region of the face (excludes points that lie on the boundary)\n\n    Args:\n        uv (np.ndarray or tuple): Surface parameter\n\n    Returns:\n        bool: Is inside\n    \"\"\"\n    result = self._trimmed.Perform(gp_Pnt2d(uv[0], uv[1]))\n    return result == TopAbs_IN\n</code></pre>"},{"location":"api/#occwl.face.Face.is_left_of","title":"<code>is_left_of(edge)</code>","text":"<p>Is this face on the left hand side of the given edge.   We take the  orientation of the edge into account here</p> <pre><code>         Edge direction\n                ^\n                |   \n      Left      |   Right \n      face      |   face\n                |\n</code></pre> <p>Args:     edge (occwl.edge.Edge): Edge</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>True if the face is to the left of the edge</p> Source code in <code>src/occwl/face.py</code> <pre><code>def is_left_of(self, edge):\n    \"\"\"\n    Is this face on the left hand side of the given edge.   We take the \n    orientation of the edge into account here\n\n                 Edge direction\n                        ^\n                        |   \n              Left      |   Right \n              face      |   face\n                        |\n    Args:\n        edge (occwl.edge.Edge): Edge\n\n    Returns:\n        bool: True if the face is to the left of the edge\n    \"\"\"\n    found_edge = False\n    for wire in self.wires():\n        for edge_from_face in wire.ordered_edges():\n            if edge == edge_from_face:\n                if edge.reversed() == edge_from_face.reversed():\n                    return True\n                else:\n                    # We found the edge, but so far we only found an edge\n                    # with orientation such that the face is on the right\n                    found_edge = True\n\n    # If we didn't find the edge at all then this function was used incorrectly.\n    # To use it you need to pass in a edge around the given face.  Assert and warn \n    # the user\n    assert found_edge, \"Edge doesn't belong to face\"\n\n    # We found an edge for which this face was on the right hand side,\n    # but not one of the left hand side\n    return False\n</code></pre>"},{"location":"api/#occwl.face.Face.make_from_wires","title":"<code>make_from_wires(wires)</code>  <code>staticmethod</code>","text":"<p>Make a face from PLANAR wires</p> <p>Parameters:</p> Name Type Description Default <code>wires</code> <code>List[Wire]</code> <p>List of wires</p> required <p>Returns:</p> Type Description <p>occwl.face.Face or None: Returns a Face or None if the operation failed</p> Source code in <code>src/occwl/face.py</code> <pre><code>@staticmethod\ndef make_from_wires(wires):\n    \"\"\"\n    Make a face from PLANAR wires\n\n    Args:\n        wires (List[occwl.wire.Wire]): List of wires\n\n    Returns:\n        occwl.face.Face or None: Returns a Face or None if the operation failed\n    \"\"\"\n    face_builder = BRepBuilderAPI_MakeFace()\n    for wire in wires:\n        face_builder.Add(wire.topods_shape())\n    face_builder.Build()\n    if not face_builder.IsDone():\n        return None\n    return Face(face_builder.Face())\n</code></pre>"},{"location":"api/#occwl.face.Face.make_nsided","title":"<code>make_nsided(edges, continuity='C0', points=None)</code>  <code>staticmethod</code>","text":"<p>Make an n-sided fill-in face with the given edges, their continuities, and optionally a set of punctual points</p> <p>Parameters:</p> Name Type Description Default <code>edges</code> <code>List[Edge]</code> <p>A list of edges for creating the fill-in face</p> required <code>continuity</code> <code>str or List[str]</code> <p>A single string or a list of strings, one for each given edge.                            Must be one of \"C0\", \"C1\", \"G1\", \"C2\", \"G2\", \"C3\"</p> <code>'C0'</code> <code>points</code> <code>ndarray</code> <p>Set of points to constrain the fill-in surface. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <p>occwl.face.Face: Filled-in face</p> Source code in <code>src/occwl/face.py</code> <pre><code>@staticmethod\ndef make_nsided(edges, continuity=\"C0\", points=None):\n    \"\"\"\n    Make an n-sided fill-in face with the given edges, their continuities, and optionally a\n    set of punctual points\n\n    Args:\n        edges (List[occwl.edge.Edge]): A list of edges for creating the fill-in face\n        continuity (str or List[str]): A single string or a list of strings, one for each given edge.\n                                       Must be one of \"C0\", \"C1\", \"G1\", \"C2\", \"G2\", \"C3\"\n        points (np.ndarray, optional): Set of points to constrain the fill-in surface. Defaults to None.\n\n    Returns:\n        occwl.face.Face: Filled-in face\n    \"\"\"\n    fill = BRepFill_Filling()\n\n    # A helper function to convert strings to Geom_Abs_ enums\n    def str_to_continuity(string):\n        if string == \"C0\":\n            return GeomAbs_C0\n        elif string == \"C1\":\n            return GeomAbs_C1\n        elif string == \"G1\":\n            return GeomAbs_G1\n        elif string == \"C2\":\n            return GeomAbs_C2\n        elif string == \"G2\":\n            return GeomAbs_G2\n        elif string == \"C3\":\n            return GeomAbs_C3\n\n    if isinstance(continuity, str):\n        assert continuity in (\"C0\", \"C1\", \"C2\")\n        occ_continuity = str_to_continuity(continuity)\n        for edg in edges:\n            fill.Add(edg.topods_shape(), occ_continuity)\n    elif isinstance(continuity, list):\n        assert len(edges) == len(continuity), \"Continuity should be provided for each edge\"\n        for edg, cont in zip(edges, continuity):\n            occ_cont = str_to_continuity(cont)\n            fill.Add(edg.topods_shape(), occ_cont)\n\n    # Add points to contrain shape if provided\n    if points:\n        for pt in points:\n            fill.Add(geom_utils.to_gp_pnt(pt))\n    fill.Build()\n    face = fill.Face()\n    return Face(face)\n</code></pre>"},{"location":"api/#occwl.face.Face.make_prism","title":"<code>make_prism(profile_edge, vector, return_first_last_shapes=False)</code>  <code>staticmethod</code>","text":"<p>Make a face from a profile edge by sweeping/extrusion</p> <p>Parameters:</p> Name Type Description Default <code>profile_edge</code> <code>Edge</code> <p>Edge</p> required <code>vector</code> <code>ndarray</code> <p>Direction and length of extrusion</p> required <code>return_first_last_shapes</code> <code>bool</code> <p>Whether to return the base and top shapes of the result. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <p>occwl.Face: Face created by sweeping the edge</p> <p>or None: if error</p> <p>occwl.Edge, occwl.Edge (optional): Returns the base and top edges of return_first_last_shapes is True.</p> Source code in <code>src/occwl/face.py</code> <pre><code>@staticmethod\ndef make_prism(profile_edge, vector, return_first_last_shapes=False):\n    \"\"\"\n    Make a face from a profile edge by sweeping/extrusion\n\n    Args:\n        profile_edge (occwl.edge.Edge): Edge\n        vector (np.ndarray): Direction and length of extrusion\n        return_first_last_shapes (bool, optional): Whether to return the base and top shapes of the result. Defaults to False.\n\n    Returns:\n        occwl.Face: Face created by sweeping the edge\n        or None: if error\n        occwl.Edge, occwl.Edge (optional): Returns the base and top edges of return_first_last_shapes is True.\n    \"\"\"\n    assert isinstance(profile_edge, Edge)\n    gp_vector = geom_utils.numpy_to_gp_vec(vector)\n    prism = BRepPrimAPI_MakePrism(profile_edge.topods_shape(), gp_vector)\n    if not prism.IsDone():\n        return None\n    if return_first_last_shapes:\n        return (\n            Face(prism.Shape()),\n            Edge(prism.FirstShape()),\n            Edge(prism.LastShape()),\n        )\n    return Face(prism.Shape())\n</code></pre>"},{"location":"api/#occwl.face.Face.max_curvature","title":"<code>max_curvature(uv)</code>","text":"<p>Compute the maximum curvature of the surface geometry at given parameter</p> <p>Parameters:</p> Name Type Description Default <code>uv</code> <code>ndarray or tuple</code> <p>Surface parameter</p> required <p>Returns:</p> Name Type Description <code>float</code> <p>Max. curvature</p> Source code in <code>src/occwl/face.py</code> <pre><code>def max_curvature(self, uv):\n    \"\"\"\n    Compute the maximum curvature of the surface geometry at given parameter\n\n    Args:\n        uv (np.ndarray or tuple): Surface parameter\n\n    Returns:\n        float: Max. curvature\n    \"\"\"\n    max_curv = GeomLProp_SLProps(\n        self.surface(), uv[0], uv[1], 2, 1e-9\n    ).MaxCurvature()\n    if self.reversed():\n        max_curv *= -1\n    return max_curv\n</code></pre>"},{"location":"api/#occwl.face.Face.mean_curvature","title":"<code>mean_curvature(uv)</code>","text":"<p>Compute the mean curvature of the surface geometry at given parameter</p> <p>Parameters:</p> Name Type Description Default <code>uv</code> <code>ndarray or tuple</code> <p>Surface parameter</p> required <p>Returns:</p> Name Type Description <code>float</code> <p>Mean curvature</p> Source code in <code>src/occwl/face.py</code> <pre><code>def mean_curvature(self, uv):\n    \"\"\"\n    Compute the mean curvature of the surface geometry at given parameter\n\n    Args:\n        uv (np.ndarray or tuple): Surface parameter\n\n    Returns:\n        float: Mean curvature\n    \"\"\"\n    mean_curv = GeomLProp_SLProps(\n        self.surface(), uv[0], uv[1], 2, 1e-9\n    ).MeanCurvature()\n    if self.reversed():\n        mean_curv *= -1\n    return mean_curv\n</code></pre>"},{"location":"api/#occwl.face.Face.min_curvature","title":"<code>min_curvature(uv)</code>","text":"<p>Compute the minimum curvature of the surface geometry at given parameter</p> <p>Parameters:</p> Name Type Description Default <code>uv</code> <code>ndarray or tuple</code> <p>Surface parameter</p> required <p>Returns:</p> Name Type Description <code>float</code> <p>Min. curvature</p> Source code in <code>src/occwl/face.py</code> <pre><code>def min_curvature(self, uv):\n    \"\"\"\n    Compute the minimum curvature of the surface geometry at given parameter\n\n    Args:\n        uv (np.ndarray or tuple): Surface parameter\n\n    Returns:\n        float: Min. curvature\n    \"\"\"\n    min_curv = GeomLProp_SLProps(\n        self.surface(), uv[0], uv[1], 2, 1e-9\n    ).MinCurvature()\n    if self.reversed():\n        min_curv *= -1\n    return min_curv\n</code></pre>"},{"location":"api/#occwl.face.Face.normal","title":"<code>normal(uv)</code>","text":"<p>Compute the normal of the surface geometry at given parameter</p> <p>Parameters:</p> Name Type Description Default <code>uv</code> <code>ndarray or tuple</code> <p>Surface parameter</p> required <p>Returns:</p> Type Description <p>np.ndarray: 3D unit normal vector</p> Source code in <code>src/occwl/face.py</code> <pre><code>def normal(self, uv):\n    \"\"\"\n    Compute the normal of the surface geometry at given parameter\n\n    Args:\n        uv (np.ndarray or tuple): Surface parameter\n\n    Returns:\n        np.ndarray: 3D unit normal vector\n    \"\"\"\n    loc = TopLoc_Location()\n    surf = BRep_Tool_Surface(self.topods_shape(), loc)\n    res = GeomLProp_SLProps(surf, uv[0], uv[1], 1, 1e-9)\n    if not res.IsNormalDefined():\n        return (0, 0, 0)\n    gp_normal = res.Normal()\n    gp_normal.Transformed(loc.Transformation())\n    normal = geom_utils.gp_to_numpy(gp_normal)\n    if self.reversed():\n        normal = -normal\n    return normal\n</code></pre>"},{"location":"api/#occwl.face.Face.num_edges","title":"<code>num_edges()</code>","text":"<p>Number of edges in the Shape</p> <p>Returns:</p> Name Type Description <code>int</code> <p>Number of edges</p> Source code in <code>src/occwl/base.py</code> <pre><code>def num_edges(self):\n    \"\"\"\n    Number of edges in the Shape\n\n    Returns:\n        int: Number of edges\n    \"\"\"\n    return self._top_exp.number_of_edges()\n</code></pre>"},{"location":"api/#occwl.face.Face.num_vertices","title":"<code>num_vertices()</code>","text":"<p>Number of vertices in the Shape</p> <p>Returns:</p> Name Type Description <code>int</code> <p>Number of vertices</p> Source code in <code>src/occwl/base.py</code> <pre><code>def num_vertices(self):\n    \"\"\"\n    Number of vertices in the Shape\n\n    Returns:\n        int: Number of vertices\n    \"\"\"\n    return self._top_exp.number_of_vertices()\n</code></pre>"},{"location":"api/#occwl.face.Face.num_wires","title":"<code>num_wires()</code>","text":"<p>Number of wires in the Shape</p> <p>Returns:</p> Name Type Description <code>int</code> <p>Number of wires</p> Source code in <code>src/occwl/base.py</code> <pre><code>def num_wires(self):\n    \"\"\"\n    Number of wires in the Shape\n\n    Returns:\n        int: Number of wires\n    \"\"\"\n    return self._top_exp.number_of_wires()\n</code></pre>"},{"location":"api/#occwl.face.Face.occwl_shape","title":"<code>occwl_shape(topods_shape)</code>  <code>staticmethod</code>","text":"<p>Static method to create an occwl shape of the appropriate  class from the given topods_shape Args:     topods_shape (OCC.Core.TopoDS.TopoDS_Vertex/Edge/Face/Wire/Shell/Solid): TopoDS shape</p> <p>Returns:</p> Type Description <p>One of occwl.compound.Compound occwl.solid.Solid occwl.face.Face occwl.edge.Edge occwl.vertex.Vertex occwl.wire.Wire occwl.shell.Shell</p> <p>Raises:     Exception: [description]</p> Source code in <code>src/occwl/shape.py</code> <pre><code>@staticmethod\ndef occwl_shape(topods_shape):\n    \"\"\"\n    Static method to create an occwl shape of the appropriate \n    class from the given topods_shape\n    Args:\n        topods_shape (OCC.Core.TopoDS.TopoDS_Vertex/Edge/Face/Wire/Shell/Solid): TopoDS shape\n\n    Returns:\n        One of\n            occwl.compound.Compound\n            occwl.solid.Solid\n            occwl.face.Face\n            occwl.edge.Edge\n            occwl.vertex.Vertex\n            occwl.wire.Wire\n            occwl.shell.Shell\n    Raises:\n        Exception: [description]\n    \"\"\"\n    from occwl.compound import Compound\n    from occwl.solid import Solid\n    from occwl.face import Face\n    from occwl.edge import Edge\n    from occwl.vertex import Vertex\n    from occwl.wire import Wire\n    from occwl.shell import Shell\n\n    if isinstance(topods_shape, TopoDS_Vertex):\n        return Vertex(topods_shape)\n    if isinstance(topods_shape, TopoDS_Edge):\n        return Edge(topods_shape)\n    if isinstance(topods_shape, TopoDS_Face):\n        return Face(topods_shape)\n    if isinstance(topods_shape, TopoDS_Wire):\n        return Wire(topods_shape)\n    if isinstance(topods_shape, TopoDS_Shell):\n        return Shell(topods_shape)\n    if isinstance(topods_shape, TopoDS_Solid):\n        return Solid(topods_shape)\n    if isinstance(topods_shape, (TopoDS_Compound, TopoDS_CompSolid)):\n        return Compound(topods_shape)\n    raise Exception(\n        \"Shape must be one of TopoDS_Vertex, TopoDS_Edge, TopoDS_Face, TopoDS_Shell, TopoDS_Solid, TopoDS_Compound, TopoDS_CompSolid\"\n    )\n</code></pre>"},{"location":"api/#occwl.face.Face.pcurve","title":"<code>pcurve(edge)</code>","text":"<p>Get the given edge's curve geometry as a 2D parametric curve on this face</p> <p>Parameters:</p> Name Type Description Default <code>edge</code> <code>Edge</code> <p>Edge</p> required <p>Returns:</p> Name Type Description <code>Geom2d_Curve</code> <p>2D curve</p> <code>Interval</code> <p>domain of the parametric curve</p> Source code in <code>src/occwl/face.py</code> <pre><code>def pcurve(self, edge):\n    \"\"\"\n    Get the given edge's curve geometry as a 2D parametric curve\n    on this face\n\n    Args:\n        edge (occwl.edge.Edge): Edge\n\n    Returns:\n        Geom2d_Curve: 2D curve\n        Interval: domain of the parametric curve\n    \"\"\"\n    crv, umin, umax = BRep_Tool().CurveOnSurface(\n        edge.topods_shape(), self.topods_shape()\n    )\n    return crv, Interval(umin, umax)\n</code></pre>"},{"location":"api/#occwl.face.Face.periodic_u","title":"<code>periodic_u()</code>","text":"<p>Whether the surface is periodic along the U-direction</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>Is periodic along U</p> Source code in <code>src/occwl/face.py</code> <pre><code>def periodic_u(self):\n    \"\"\"\n    Whether the surface is periodic along the U-direction\n\n    Returns:\n        bool: Is periodic along U\n    \"\"\"\n    adaptor = BRepAdaptor_Surface(self.topods_shape())\n    return adaptor.IsUPeriodic()\n</code></pre>"},{"location":"api/#occwl.face.Face.periodic_v","title":"<code>periodic_v()</code>","text":"<p>Whether the surface is periodic along the V-direction</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>Is periodic along V</p> Source code in <code>src/occwl/face.py</code> <pre><code>def periodic_v(self):\n    \"\"\"\n    Whether the surface is periodic along the V-direction\n\n    Returns:\n        bool: Is periodic along V\n    \"\"\"\n    adaptor = BRepAdaptor_Surface(self.topods_shape())\n    return adaptor.IsVPeriodic()\n</code></pre>"},{"location":"api/#occwl.face.Face.point","title":"<code>point(uv)</code>","text":"<p>Evaluate the face geometry at given parameter</p> <p>Parameters:</p> Name Type Description Default <code>uv</code> <code>ndarray or tuple</code> <p>Surface parameter</p> required <p>Returns:</p> Type Description <p>np.ndarray: 3D Point</p> Source code in <code>src/occwl/face.py</code> <pre><code>def point(self, uv):\n    \"\"\"\n    Evaluate the face geometry at given parameter\n\n    Args:\n        uv (np.ndarray or tuple): Surface parameter\n\n    Returns:\n        np.ndarray: 3D Point\n    \"\"\"\n    loc = TopLoc_Location()\n    surf = BRep_Tool_Surface(self.topods_shape(), loc)\n    pt = surf.Value(uv[0], uv[1])\n    pt = pt.Transformed(loc.Transformation())\n    return geom_utils.gp_to_numpy(pt)\n</code></pre>"},{"location":"api/#occwl.face.Face.point_to_parameter","title":"<code>point_to_parameter(pt)</code>","text":"<p>Get the UV parameter by projecting the point on this face</p> <p>Parameters:</p> Name Type Description Default <code>pt</code> <code>ndarray</code> <p>3D point</p> required <p>Returns:</p> Type Description <p>np.ndarray: UV-coordinate</p> Source code in <code>src/occwl/face.py</code> <pre><code>def point_to_parameter(self, pt):\n    \"\"\"\n    Get the UV parameter by projecting the point on this face\n\n    Args:\n        pt (np.ndarray): 3D point\n\n    Returns:\n        np.ndarray: UV-coordinate\n    \"\"\"\n    loc = TopLoc_Location()\n    surf = BRep_Tool_Surface(self.topods_shape(), loc)\n    gp_pt = gp_Pnt(pt[0], pt[1], pt[2])\n    inv = loc.Transformation().Inverted()\n    gp_pt.Transformed(inv)\n    uv = ShapeAnalysis_Surface(surf).ValueOfUV(\n        gp_pt, 1e-9\n    )\n    return np.array(uv.Coord())\n</code></pre>"},{"location":"api/#occwl.face.Face.reversed","title":"<code>reversed()</code>","text":"<p>Whether this shape is reversed.</p> <ul> <li>For an edge this is whether the edge is reversed with respect to the curve geometry</li> <li>For a face this is whether the face is reversed with respect to the surface geometry</li> <li>For a vertex this is whether the vertex is at the upper or lower parameter value on the   edges curve</li> </ul> <p>Returns:</p> Name Type Description <code>bool</code> <p>If rational</p> Source code in <code>src/occwl/shape.py</code> <pre><code>def reversed(self):\n    \"\"\"\n    Whether this shape is reversed.\n\n    - For an edge this is whether the edge is reversed with respect to the curve geometry\n    - For a face this is whether the face is reversed with respect to the surface geometry\n    - For a vertex this is whether the vertex is at the upper or lower parameter value on the\n      edges curve\n\n    Returns:\n        bool: If rational\n    \"\"\"\n    return self.topods_shape().Orientation() == TopAbs_REVERSED\n</code></pre>"},{"location":"api/#occwl.face.Face.reversed_face","title":"<code>reversed_face()</code>","text":"<p>Return a copy of this face with the orientation reversed.</p> <p>Returns:</p> Type Description <p>occwl.face.Face: A face with the opposite orientation to this face.</p> Source code in <code>src/occwl/face.py</code> <pre><code>def reversed_face(self):\n    \"\"\"\n    Return a copy of this face with the orientation reversed.\n\n    Returns:\n        occwl.face.Face: A face with the opposite orientation to this face.\n    \"\"\"\n    return Face(self.topods_shape().Reversed())\n</code></pre>"},{"location":"api/#occwl.face.Face.rotate_axis_angle","title":"<code>rotate_axis_angle(axis, angle_radians, origin=np.zeros(3, dtype=(np.float32)))</code>","text":"<p>Rotate the shape about the given axis by the given angle in radians</p> <p>Parameters:</p> Name Type Description Default <code>axis</code> <code>ndarray</code> <p>Rotation axis</p> required <code>angle_radians</code> <code>float</code> <p>Angle in radians</p> required Source code in <code>src/occwl/shape.py</code> <pre><code>def rotate_axis_angle(\n    self, axis, angle_radians, origin=np.zeros(3, dtype=np.float32)\n):\n    \"\"\"\n    Rotate the shape about the given axis by the given angle in radians\n\n    Args:\n        axis (np.ndarray): Rotation axis\n        angle_radians (float): Angle in radians\n    \"\"\"\n    self._shape = rotate_shape(\n        self._shape,\n        gp_Ax1(geom_utils.numpy_to_gp(origin), geom_utils.numpy_to_gp_dir(axis)),\n        angle_radians,\n        unite=\"rad\",\n    )\n</code></pre>"},{"location":"api/#occwl.face.Face.rotate_euler_angles","title":"<code>rotate_euler_angles(angles_xyz_radians)</code>","text":"<p>Rotate the shape by the given Euler angles in radians</p> <p>Parameters:</p> Name Type Description Default <code>angle_xyz_radians</code> <code>ndarray</code> <p>3D array with angles to rotate about x-axis, y-axis and z-axis respectively in radians</p> required Source code in <code>src/occwl/shape.py</code> <pre><code>def rotate_euler_angles(self, angles_xyz_radians):\n    \"\"\"\n    Rotate the shape by the given Euler angles in radians\n\n    Args:\n        angle_xyz_radians (np.ndarray): 3D array with angles to rotate about x-axis, y-axis and z-axis respectively in radians\n    \"\"\"\n    self._shape = rotate_shp_3_axis(\n        self._shape,\n        angles_xyz_radians[0],\n        angles_xyz_radians[1],\n        angles_xyz_radians[2],\n        unity=\"rad\",\n    )\n</code></pre>"},{"location":"api/#occwl.face.Face.save_shapes_to_occ_native","title":"<code>save_shapes_to_occ_native(filename, shapes, with_triangles=False, with_normals=False, format_version=None)</code>  <code>staticmethod</code>","text":"<p>Save this shape into a native OCC binary .brep file.</p> Saving to and loading from the native file format <p>is between one and two orders of magnitude faster  than loading from STEP, so it is recommended for  large scale data processing</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str or Path</code> <p>.brep filename</p> required <code>with_triangles</code> <code>bool</code> <p>Whether to save triangle data cached in the shape.</p> <code>False</code> <code>with_normals</code> <code>bool</code> <p>Whether to save vertex normals cached in the shape</p> <code>False</code> <code>format_version</code> <code>int</code> <p>Use None to save to the latest version 1 - first revision 2 - added storing of CurveOnSurface UV Points 3 - [OCCT 7.6] added storing of per-vertex normal information                and dropped storing of CurveOnSurface UV Points</p> <code>None</code> Source code in <code>src/occwl/shape.py</code> <pre><code>@staticmethod\ndef save_shapes_to_occ_native(\n        filename, \n        shapes,\n        with_triangles=False,\n        with_normals=False,\n        format_version=None\n    ):\n    \"\"\"\n    Save this shape into a native OCC binary .brep file.\n\n    Note:  Saving to and loading from the native file format \n            is between one and two orders of magnitude faster \n            than loading from STEP, so it is recommended for \n            large scale data processing\n\n    Args:\n        filename (str or pathlib.Path): .brep filename\n\n        with_triangles (bool): Whether to save triangle data cached in the shape.\n        with_normals (bool): Whether to save vertex normals cached in the shape\n        format_version (int):  Use None to save to the latest version\n            1 - first revision\n            2 - added storing of CurveOnSurface UV Points\n            3 - [OCCT 7.6] added storing of per-vertex normal information\n                           and dropped storing of CurveOnSurface UV Points\n    \"\"\"\n    new_api = False\n    shapes_set = BRepTools_ShapeSet(with_triangles)\n    # shapes_set.SetWithNormals(with_normals) # Not in OCC 7.5.0\n\n    for shp in shapes:\n        shapes_set.Add(shp.topods_shape())\n    if format_version is not None:\n        shapes_set.SetFormatNb(format_version)\n\n\n    with open(filename, \"w\") as fp:\n        s = shapes_set.WriteToString()\n        fp.write(s)\n</code></pre>"},{"location":"api/#occwl.face.Face.save_to_occ_native","title":"<code>save_to_occ_native(filename, verbosity=False, with_triangles=False, with_normals=False, format_version=None)</code>","text":"<p>Save this shape into a native OCC binary .brep file.</p> Saving to and loading from the native file format <p>is between one and two orders of magnitude faster  than loading from STEP, so it is recommended for  large scale data processing</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str or Path</code> <p>.brep filename</p> required <code>with_triangles</code> <code>bool</code> <p>Whether to save triangle data cached in the shape.</p> <code>False</code> <code>with_normals</code> <code>bool</code> <p>Whether to save vertex normals cached in the shape</p> <code>False</code> <code>format_version</code> <code>int</code> <p>Use None to save to the latest version 1 - first revision 2 - added storing of CurveOnSurface UV Points 3 - [OCCT 7.6] added storing of per-vertex normal information                and dropped storing of CurveOnSurface UV Points</p> <code>None</code> Source code in <code>src/occwl/shape.py</code> <pre><code>def save_to_occ_native(\n        self, \n        filename, \n        verbosity=False,\n        with_triangles=False,\n        with_normals=False,\n        format_version=None\n    ):\n    \"\"\"\n    Save this shape into a native OCC binary .brep file.\n\n    Note:  Saving to and loading from the native file format \n           is between one and two orders of magnitude faster \n           than loading from STEP, so it is recommended for \n           large scale data processing\n\n    Args:\n        filename (str or pathlib.Path): .brep filename\n        with_triangles (bool): Whether to save triangle data cached in the shape.\n        with_normals (bool): Whether to save vertex normals cached in the shape\n        format_version (int):  Use None to save to the latest version\n            1 - first revision\n            2 - added storing of CurveOnSurface UV Points\n            3 - [OCCT 7.6] added storing of per-vertex normal information\n                           and dropped storing of CurveOnSurface UV Points\n    \"\"\"\n    self.save_shapes_to_occ_native(\n        filename, \n        [ self ],\n        with_triangles=with_triangles,\n        with_normals=with_normals,\n        format_version=format_version\n    )\n</code></pre>"},{"location":"api/#occwl.face.Face.scale","title":"<code>scale(scale_vector)</code>","text":"<p>Scale the shape by the given 3D vector</p> <p>Parameters:</p> Name Type Description Default <code>scale_vector</code> <code>ndarray</code> <p>3D array with scales to resize the shape along the x-axis, y-axis and z-axis respectively</p> required Source code in <code>src/occwl/shape.py</code> <pre><code>def scale(self, scale_vector):\n    \"\"\"\n    Scale the shape by the given 3D vector\n\n    Args:\n        scale_vector (np.ndarray): 3D array with scales to resize the shape along the x-axis, y-axis and z-axis respectively\n    \"\"\"\n    self._shape = scale_shape(\n        self._shape, scale_vector[0], scale_vector[1], scale_vector[2]\n    )\n</code></pre>"},{"location":"api/#occwl.face.Face.scale_to_box","title":"<code>scale_to_box(box_side, copy=True)</code>","text":"<p>Translate and scale the Shape so it fits exactly  into the [-box_side, box_side]^3 box</p> <p>Returns:</p> Type Description <p>occwl..: The scaled version of this Shape</p> Source code in <code>src/occwl/base.py</code> <pre><code>def scale_to_box(self, box_side, copy=True):\n    \"\"\"\n    Translate and scale the Shape so it fits exactly \n    into the [-box_side, box_side]^3 box\n\n    Args:\n        box_side (float) The side length of the box\n        copy (bool)      True - Copy entities and apply the transform to\n                                the underlying geometry\n                         False - Apply the transform to the topods Locator\n                                 if possible \n\n    Returns:\n        occwl.*.*: The scaled version of this Shape\n    \"\"\"\n    from occwl.geometry import geom_utils\n    # Get an exact box for the Shape\n    box = self.exact_box()\n    center = box.center()\n    longest_length = box.max_box_length()\n\n    orig = gp_Pnt(0.0, 0.0, 0.0)\n    center = geom_utils.numpy_to_gp(center)\n    vec_center_to_orig = gp_Vec(center, orig)\n    move_to_center = gp_Trsf()\n    move_to_center.SetTranslation(vec_center_to_orig)\n\n    scale_trsf = gp_Trsf()\n    scale_trsf.SetScale(orig, (2.0 * box_side) / longest_length)\n    trsf_to_apply = scale_trsf.Multiplied(move_to_center)\n\n    return self._apply_transform(trsf_to_apply, copy=copy)\n</code></pre>"},{"location":"api/#occwl.face.Face.scale_to_unit_box","title":"<code>scale_to_unit_box(copy=True)</code>","text":"<p>Translate and scale the Shape so it fits exactly  into the [-1, 1]^3 box</p> <p>Returns:     The scaled version of this shape</p> Source code in <code>src/occwl/base.py</code> <pre><code>def scale_to_unit_box(self, copy=True):\n    \"\"\"\n    Translate and scale the Shape so it fits exactly \n    into the [-1, 1]^3 box\n\n    Args:\n        copy (bool)      True - Copy entities and apply the transform to\n                                    the underlying geometry\n                            False - Apply the transform to the topods Locator\n                                    if possible \n    Returns:\n        The scaled version of this shape\n    \"\"\"\n    return self.scale_to_box(1.0, copy=copy)\n</code></pre>"},{"location":"api/#occwl.face.Face.set_transform_to_identity","title":"<code>set_transform_to_identity()</code>","text":"<p>When an assembly is loaded from a STEP file the solids will be transformed relative to their local coordinate system.   i.e. they are placed in the assembly root components  coordinate system.</p> <p>When working with individual bodies you often want them to be axis aligned, in which case  you want to remove the assembly transform. This function removes it for you.</p> <p>If however you want to bake the transform into the bodies and suppress the asserts  from parts of occwl which don't cope with transforms then use the transform() function below with copy=True</p> Source code in <code>src/occwl/shape.py</code> <pre><code>def set_transform_to_identity(self):\n    \"\"\"\n    When an assembly is loaded from a STEP file\n    the solids will be transformed relative to\n    their local coordinate system.   i.e. they\n    are placed in the assembly root components \n    coordinate system.\n\n    When working with individual bodies you often\n    want them to be axis aligned, in which case \n    you want to remove the assembly transform.\n    This function removes it for you.\n\n    If however you want to bake the transform\n    into the bodies and suppress the asserts \n    from parts of occwl which don't cope with\n    transforms then use the transform() function\n    below with copy=True\n    \"\"\"\n    identity = TopLoc_Location()\n    self.topods_shape().Location(identity)\n    self._top_exp = TopologyUtils.TopologyExplorer(self.topods_shape(), True)\n    self.convert_geometric_identity_transforms_to_identity()\n</code></pre>"},{"location":"api/#occwl.face.Face.specific_surface","title":"<code>specific_surface()</code>","text":"<p>Get the specific face surface geometry</p> <p>Returns:</p> Type Description <p>OCC.Geom.Handle_Geom_*: Specific geometry type for the surface geometry</p> Source code in <code>src/occwl/face.py</code> <pre><code>def specific_surface(self):\n    \"\"\"\n    Get the specific face surface geometry\n\n    Returns:\n        OCC.Geom.Handle_Geom_*: Specific geometry type for the surface geometry\n    \"\"\"\n    if not self.topods_shape().Location().IsIdentity():\n        tsf = self.topods_shape().Location().Transformation()\n        np_tsf = geom_utils.to_numpy(tsf)\n        assert np.allclose(np_tsf, np.eye(4)), \\\n            \"Requesting surface for transformed face. /n\\\n            Call solid.set_transform_to_identity() to remove the transform /n\\\n            or compound.transform(np.eye(4)) to bake in the assembly transform\"\n    srf = BRepAdaptor_Surface(self.topods_shape())\n    surf_type = self.surface_type()\n    if surf_type == \"plane\":\n        return srf.Plane()\n    if surf_type == \"cylinder\":\n        return srf.Cylinder()\n    if surf_type == \"cone\":\n        return srf.Cone()\n    if surf_type == \"sphere\":\n        return srf.Sphere()\n    if surf_type == \"torus\":\n        return srf.Torus()\n    if surf_type == \"bezier\":\n        return srf.Bezier()\n    if surf_type == \"bspline\":\n        return srf.BSpline()\n    raise ValueError(\"Unknown surface type: \", surf_type)\n</code></pre>"},{"location":"api/#occwl.face.Face.split_all_closed_edges","title":"<code>split_all_closed_edges(max_tol=0.01, precision=0.01, num_splits=1)</code>","text":"<p>Split all the closed edges in this shape</p> <p>Parameters:</p> Name Type Description Default <code>max_tol</code> <code>float</code> <p>Maximum tolerance allowed. Defaults to 0.01.</p> <code>0.01</code> <code>precision</code> <code>float</code> <p>Precision of the tool when splitting. Defaults to 0.01.</p> <code>0.01</code> <code>num_splits</code> <code>int</code> <p>Number of splits to perform. Each split edge will result in num_splits + 1 edges. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Type Description <p>occwl..: Shape with closed edges split</p> Source code in <code>src/occwl/base.py</code> <pre><code>def split_all_closed_edges(self, max_tol=0.01, precision=0.01, num_splits=1):\n    \"\"\"\n    Split all the closed edges in this shape\n\n    Args:\n        max_tol (float, optional): Maximum tolerance allowed. Defaults to 0.01.\n        precision (float, optional): Precision of the tool when splitting. Defaults to 0.01.\n        num_splits (int, optional): Number of splits to perform. Each split edge will result in num_splits + 1 edges. Defaults to 1.\n\n    Returns:\n        occwl.*.*: Shape with closed edges split\n    \"\"\"\n    divider = ShapeUpgrade_ShapeDivideClosedEdges(self.topods_shape())\n    divider.SetPrecision(precision)\n    divider.SetMinTolerance(0.1 * max_tol)\n    divider.SetMaxTolerance(max_tol)\n    divider.SetNbSplitPoints(num_splits)\n    ok = divider.Perform()\n    if not ok:\n        # Splitting failed or there were no closed edges to split\n        # Return the original shape\n        return self\n    return type(self)(divider.Result())\n</code></pre>"},{"location":"api/#occwl.face.Face.surface","title":"<code>surface()</code>","text":"<p>Get the face surface geometry</p> <p>Returns:</p> Type Description <p>OCC.Geom.Handle_Geom_Surface: Interface to all surface geometry</p> Source code in <code>src/occwl/face.py</code> <pre><code>def surface(self):\n    \"\"\"\n    Get the face surface geometry\n\n    Returns:\n        OCC.Geom.Handle_Geom_Surface: Interface to all surface geometry\n    \"\"\"\n    loc = TopLoc_Location()\n    surf = BRep_Tool_Surface(self.topods_shape(), loc)\n    if not loc.IsIdentity():\n        tsf = loc.Transformation()\n        np_tsf = geom_utils.to_numpy(tsf)\n        assert np.allclose(np_tsf, np.eye(4)), \\\n            \"Requesting surface for transformed face. /n\\\n            Call solid.set_transform_to_identity() to remove the transform \\\n            or compound.Transform(np.eye(4)) to bake in the assembly transform\"\n    return surf\n</code></pre>"},{"location":"api/#occwl.face.Face.surface_type","title":"<code>surface_type()</code>","text":"<p>Get the type of the surface geometry</p> <p>Returns:</p> Name Type Description <code>str</code> <p>Type of the surface geometry</p> Source code in <code>src/occwl/face.py</code> <pre><code>def surface_type(self):\n    \"\"\"\n    Get the type of the surface geometry\n\n    Returns:\n        str: Type of the surface geometry\n    \"\"\"\n    surf_type = BRepAdaptor_Surface(self.topods_shape()).GetType()\n    if surf_type == GeomAbs_Plane:\n        return \"plane\"\n    if surf_type == GeomAbs_Cylinder:\n        return \"cylinder\"\n    if surf_type == GeomAbs_Cone:\n        return \"cone\"\n    if surf_type == GeomAbs_Sphere:\n        return \"sphere\"\n    if surf_type == GeomAbs_Torus:\n        return \"torus\"\n    if surf_type == GeomAbs_BezierSurface:\n        return \"bezier\"\n    if surf_type == GeomAbs_BSplineSurface:\n        return \"bspline\"\n    if surf_type == GeomAbs_SurfaceOfRevolution:\n        return \"revolution\"\n    if surf_type == GeomAbs_SurfaceOfExtrusion:\n        return \"extrusion\"\n    if surf_type == GeomAbs_OffsetSurface:\n        return \"offset\"\n    if surf_type == GeomAbs_OtherSurface:\n        return \"other\"\n    return \"unknown\"\n</code></pre>"},{"location":"api/#occwl.face.Face.surface_type_enum","title":"<code>surface_type_enum()</code>","text":"<p>Get the type of the surface geometry as an OCC.Core.GeomAbs enum</p> <p>Returns:</p> Type Description <p>OCC.Core.GeomAbs: Type of the surface geometry</p> Source code in <code>src/occwl/face.py</code> <pre><code>def surface_type_enum(self):\n    \"\"\"\n    Get the type of the surface geometry as an OCC.Core.GeomAbs enum\n\n    Returns:\n        OCC.Core.GeomAbs: Type of the surface geometry\n    \"\"\"\n    return BRepAdaptor_Surface(self.topods_shape()).GetType()\n</code></pre>"},{"location":"api/#occwl.face.Face.tangent","title":"<code>tangent(uv)</code>","text":"<p>Compute the tangents of the surface geometry at given parameter</p> <p>Parameters:</p> Name Type Description Default <code>uv</code> <code>ndarray or tuple</code> <p>Surface parameter</p> required <p>Returns:</p> Type Description <p>Pair of np.ndarray or None: 3D unit vectors</p> Source code in <code>src/occwl/face.py</code> <pre><code>def tangent(self, uv):\n    \"\"\"\n    Compute the tangents of the surface geometry at given parameter\n\n    Args:\n        uv (np.ndarray or tuple): Surface parameter\n\n    Returns:\n        Pair of np.ndarray or None: 3D unit vectors\n    \"\"\"\n    loc = TopLoc_Location()\n    surf = BRep_Tool_Surface(self.topods_shape(), loc)\n    dU, dV = gp_Dir(), gp_Dir()\n    res = GeomLProp_SLProps(surf, uv[0], uv[1], 1, 1e-9)\n    if res.IsTangentUDefined() and res.IsTangentVDefined():\n        res.TangentU(dU), res.TangentV(dV)\n        dU.Transformed(loc.Transformation())\n        dV.Transformed(loc.Transformation())\n        return (geom_utils.gp_to_numpy(dU)), (geom_utils.gp_to_numpy(dV))\n    return None, None\n</code></pre>"},{"location":"api/#occwl.face.Face.topods_shape","title":"<code>topods_shape()</code>","text":"<p>Get the underlying OCC shape</p> <p>Returns:</p> Type Description <p>OCC.Core.TopoDS.TopoDS_Vertex/Edge/Face/Wire/Shell/Solid: OCC TopoDS_*</p> Source code in <code>src/occwl/shape.py</code> <pre><code>def topods_shape(self):\n    \"\"\"\n    Get the underlying OCC shape\n\n    Returns:\n        OCC.Core.TopoDS.TopoDS_Vertex/Edge/Face/Wire/Shell/Solid: OCC TopoDS_*\n    \"\"\"\n    return self._shape\n</code></pre>"},{"location":"api/#occwl.face.Face.transform","title":"<code>transform(a, copy=True)</code>","text":"<p>Apply the given 3x4 transform matrix to the solid.</p> <pre><code> copy (bool)    True - Copy entities and apply the transform to\n                       the underlying geometry\n                False - Apply the transform to the topods Locator\n                        if possible\n</code></pre> Source code in <code>src/occwl/shape.py</code> <pre><code>def transform(self, a: np.ndarray, copy=True):\n    \"\"\"\n    Apply the given 3x4 transform matrix to the solid.\n\n    Args: a (nd.array) - Homogeneous transform matrix\n                         The transform that will be applied is\n\n                         x' =  a[0,0]*x + a[0,1]*y + a[0,2]*z + a[0, 3]\n                         y' =  a[1,0]*x + a[1,1]*y + a[1,2]*z + a[1, 3]\n                         z' =  a[2,0]*x + a[2,1]*y + a[2,2]*z + a[2, 3]\n\n         copy (bool)    True - Copy entities and apply the transform to\n                               the underlying geometry\n                        False - Apply the transform to the topods Locator\n                                if possible \n    \"\"\"\n    assert (a.shape == (3, 4)), \"Transform matrix must be 3x4\"\n    a = a.astype(np.float64)\n\n    # Create an identity transform\n    trsf = gp_Trsf()\n\n    # If the matrix is an identity matrix then\n    # we don't want to set the values as this\n    # would give us a geometric identity without\n    # the identity flag set\n    if not np.allclose(a, np.eye(3, 4)):\n        trsf.SetValues(\n            a[0,0], a[0,1], a[0,2], a[0, 3],\n            a[1,0], a[1,1], a[1,2], a[1, 3],\n            a[2,0], a[2,1], a[2,2], a[2, 3]\n        )\n    return self._apply_transform(trsf, copy=copy)\n</code></pre>"},{"location":"api/#occwl.face.Face.translate","title":"<code>translate(offset)</code>","text":"<p>Translate the shape by an offset vector</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>ndarray</code> <p>Offset vector</p> required Source code in <code>src/occwl/shape.py</code> <pre><code>def translate(self, offset):\n    \"\"\"\n    Translate the shape by an offset vector\n\n    Args:\n        offset (np.ndarray): Offset vector\n    \"\"\"\n    self._shape = translate_shp(self._shape, geom_utils.numpy_to_gp_vec(offset))\n</code></pre>"},{"location":"api/#occwl.face.Face.triangulate","title":"<code>triangulate(triangle_face_tol=0.01, tol_relative_to_face=True, angle_tol_rads=0.1)</code>","text":"<p>Triangulate all the faces in the shape. You can then get the triangles  from each face separately using face.get_triangles(). If you wanted triangles for the entire shape then call shape.get_triangles() below. For more details see  https://old.opencascade.com/doc/occt-7.1.0/overview/html/occt_user_guides__modeling_algos.html#occt_modalg_11</p> <p>Parameters:</p> Name Type Description Default <code>triangle_face_tol</code> <code>float</code> <p>Tolerance between triangle and surface. Defaults to 0.01.</p> <code>0.01</code> <code>tol_relative_to_face</code> <code>bool</code> <p>Whether tolerance is relative to face size</p> <code>True</code> <code>angle_tol_rads</code> <code>float</code> <p>Angle tolerance in radians. Defaults to 0.1.</p> <code>0.1</code> <p>Returns:</p> Name Type Description <code>bool</code> <p>Is successful</p> Source code in <code>src/occwl/base.py</code> <pre><code>def triangulate(\n    self,\n    triangle_face_tol=0.01,  # Tolerance between triangle and surface\n    tol_relative_to_face=True,  # The tolerance value is relative to the face size\n    angle_tol_rads=0.1,  # Angle between normals/tangents at triangle vertices\n):\n    \"\"\"\n    Triangulate all the faces in the shape. You can then get the triangles \n    from each face separately using face.get_triangles().\n    If you wanted triangles for the entire shape then call\n    shape.get_triangles() below.\n    For more details see \n    https://old.opencascade.com/doc/occt-7.1.0/overview/html/occt_user_guides__modeling_algos.html#occt_modalg_11\n\n    Args:\n        triangle_face_tol (float, optional): Tolerance between triangle and surface. Defaults to 0.01.\n        tol_relative_to_face (bool): Whether tolerance is relative to face size\n        angle_tol_rads (float, optional): Angle tolerance in radians. Defaults to 0.1.\n\n    Returns:\n        bool: Is successful\n    \"\"\"\n    mesh = BRepMesh_IncrementalMesh(\n        self.topods_shape(),\n        triangle_face_tol,\n        tol_relative_to_face,\n        angle_tol_rads,\n        True,\n    )\n    mesh.Perform()\n    return mesh.IsDone()\n</code></pre>"},{"location":"api/#occwl.face.Face.uv_bounds","title":"<code>uv_bounds()</code>","text":"<p>Get the UV-domain bounds of this face's surface geometry</p> <p>Returns:</p> Name Type Description <code>Box</code> <p>UV-domain bounds</p> Source code in <code>src/occwl/face.py</code> <pre><code>def uv_bounds(self):\n    \"\"\"\n    Get the UV-domain bounds of this face's surface geometry\n\n    Returns:\n        Box: UV-domain bounds\n    \"\"\"\n    umin, umax, vmin, vmax = breptools_UVBounds(self.topods_shape())\n    bounds = Box(np.array([umin, vmin]))\n    bounds.encompass_point(np.array([umax, vmax]))\n    return bounds\n</code></pre>"},{"location":"api/#occwl.face.Face.valid","title":"<code>valid(return_analyzer=False)</code>","text":"<p>Check if the shape is valid</p> <p>Parameters:</p> Name Type Description Default <code>return_analyzer</code> <code>bool</code> <p>Whether to return the BRepCheck_Analyzer object for more inspection</p> <code>False</code> <p>Returns:</p> Name Type Description <code>bool</code> <p>Whether the shape is valid</p> <p>BRepCheck_Analyzer [optional]: if return_analyzer is True</p> Source code in <code>src/occwl/shape.py</code> <pre><code>def valid(self, return_analyzer=False):\n    \"\"\"\n    Check if the shape is valid\n\n    Args:\n        return_analyzer (bool): Whether to return the BRepCheck_Analyzer object for more inspection\n\n    Returns:\n        bool: Whether the shape is valid\n        BRepCheck_Analyzer [optional]: if return_analyzer is True\n    \"\"\"\n    analyzer = BRepCheck_Analyzer(self.topods_shape())\n    if return_analyzer:\n        return analyzer.IsValid(), analyzer\n    return analyzer.IsValid()\n</code></pre>"},{"location":"api/#occwl.face.Face.vertices","title":"<code>vertices()</code>","text":"<p>Get an iterator to go over all vertices in the Shape</p> <p>Returns:</p> Type Description <p>Iterator[occwl.vertex.Vertex]: Vertex iterator</p> Source code in <code>src/occwl/base.py</code> <pre><code>def vertices(self):\n    \"\"\"\n    Get an iterator to go over all vertices in the Shape\n\n    Returns:\n        Iterator[occwl.vertex.Vertex]: Vertex iterator\n    \"\"\"\n    from occwl.vertex import Vertex\n    return map(Vertex, self._top_exp.vertices())\n</code></pre>"},{"location":"api/#occwl.face.Face.vertices_from_edge","title":"<code>vertices_from_edge(edge)</code>","text":"<p>Get an iterator to go over the vertices bounding an edge</p> <p>Parameters:</p> Name Type Description Default <code>edge</code> <code>Edge</code> <p>Input edge</p> required <p>Returns:</p> Type Description <p>Iterator[occwl.vertex.Vertex]: Vertex iterator</p> Source code in <code>src/occwl/base.py</code> <pre><code>def vertices_from_edge(self, edge):\n    \"\"\"\n    Get an iterator to go over the vertices bounding an edge\n\n    Args:\n        edge (occwl.edge.Edge): Input edge\n\n    Returns:\n        Iterator[occwl.vertex.Vertex]: Vertex iterator\n    \"\"\"\n    from occwl.vertex import Vertex\n    from occwl.edge import Edge\n    assert isinstance(edge, Edge)\n    return map(Vertex, self._top_exp.vertices_from_edge(edge.topods_shape()))\n</code></pre>"},{"location":"api/#occwl.face.Face.visibility_status","title":"<code>visibility_status(uv)</code>","text":"<p>Check if the uv-coordinate in on the visible region of the face</p> <p>Parameters:</p> Name Type Description Default <code>uv</code> <code>ndarray or tuple</code> <p>Surface parameter</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>TopAbs_STATE enum</code> <p>0: TopAbs_IN, 1: TopAbs_OUT, 2: TopAbs_ON, 3: TopAbs_UNKNOWN</p> Source code in <code>src/occwl/face.py</code> <pre><code>def visibility_status(self, uv):\n    \"\"\"\n    Check if the uv-coordinate in on the visible region of the face\n\n    Args:\n        uv (np.ndarray or tuple): Surface parameter\n\n    Returns:\n        int (TopAbs_STATE enum): 0: TopAbs_IN, 1: TopAbs_OUT, 2: TopAbs_ON, 3: TopAbs_UNKNOWN\n    \"\"\"\n    result = self._trimmed.Perform(gp_Pnt2d(uv[0], uv[1]))\n    return int(result)\n</code></pre>"},{"location":"api/#occwl.face.Face.wires","title":"<code>wires()</code>","text":"<p>Get an iterator to go over all wires in the Shape</p> <p>Returns:</p> Type Description <p>Iterator[occwl.wire.Wire]: Wire iterator</p> Source code in <code>src/occwl/base.py</code> <pre><code>def wires(self):\n    \"\"\"\n    Get an iterator to go over all wires in the Shape\n\n    Returns:\n        Iterator[occwl.wire.Wire]: Wire iterator\n    \"\"\"\n    from occwl.wire import Wire\n    return map(Wire, self._top_exp.wires())\n</code></pre>"},{"location":"api/#occwl.geometry","title":"<code>geometry</code>","text":""},{"location":"api/#occwl.geometry.arc_length_param_finder","title":"<code>arc_length_param_finder</code>","text":"<p>Tools for finding an arc-length parameterization from an edge, curve interval or surface iso-parametric curve</p>"},{"location":"api/#occwl.geometry.arc_length_param_finder.ArcLengthParamFinder","title":"<code>ArcLengthParamFinder</code>","text":"Source code in <code>src/occwl/geometry/arc_length_param_finder.py</code> <pre><code>class ArcLengthParamFinder:\n    def __init__(self, points=None, us=None, edge=None, num_arc_length_samples=100):\n        \"\"\"\n        Create a class to generate arc-length parameters\n\n        Args:\n            points (list(np.array)): Point samples on the curve\n            us (list(float)): u parameters on the curve\n\n            or\n\n            edge (occwl.edge.Edge): An edge\n            num_arc_length_samples (int): The number of samples to use the the calculation\n        \"\"\"\n        self.good = True\n        if edge is not None:\n            # For an edge we can sample points directly\n            self._generate_data_from_edge(edge, num_arc_length_samples)\n        else:\n            # This code could be expanded to sample from surface iso-parametric lines\n            assert points is not None\n            assert us is not None\n            self.points = points\n            self.us = us\n\n    def find_arc_length_parameters(self, num_samples):\n        \"\"\"\n        Find a list of u parameters which provides an equal arc length\n        list for the given points and us\n        \"\"\"\n        assert num_samples &gt;= 2\n        assert len(self.points) &gt;= 2\n        assert len(self.us) == len(self.points)\n\n        # Find the arc lengths between the sample points\n        lengths = []\n        total_length = 0\n        prev_point = None\n        for point in self.points:\n            if prev_point is not None:\n                length = np.linalg.norm(point - prev_point)\n                lengths.append(length)\n                total_length += length\n            prev_point = point\n\n        # Find the cumulative arc length over the points\n        arc_length_fraction = [0.0]\n        cumulative_length = 0.0\n        for length in lengths:\n            cumulative_length += length\n            arc_length_fraction.append(cumulative_length / total_length)\n\n        # Build the arc-length parameterization\n        arc_length_params = []\n        arc_length_index = 0\n        for i in range(num_samples):\n            desired_arc_length_fraction = i / (num_samples - 1)\n\n            # Find the correct span of the polyline\n            while arc_length_fraction[arc_length_index] &lt; desired_arc_length_fraction:\n                arc_length_index += 1\n                if arc_length_index &gt;= len(arc_length_fraction) - 1:\n                    break\n\n            # Handle the special case at the first point\n            if arc_length_index == 0:\n                u_low = self.us[0]\n                frac_low = arc_length_fraction[0]\n            else:\n                u_low = self.us[arc_length_index - 1]\n                frac_low = arc_length_fraction[arc_length_index - 1]\n\n            # Find the arc length parameter by interpolation\n            u_high = self.us[arc_length_index]\n            frac_high = arc_length_fraction[arc_length_index]\n\n            # Check we found the correct range\n            assert desired_arc_length_fraction &gt;= frac_low\n            assert desired_arc_length_fraction &lt;= frac_high\n\n            d_frac = frac_high - frac_low\n            if d_frac &lt;= 0.0:\n                u_param = u_low\n            else:\n                u_interval = Interval(u_low, u_high)\n                position_in_interval = (desired_arc_length_fraction - frac_low) / (\n                    d_frac\n                )\n                u_param = u_interval.interpolate(position_in_interval)\n            arc_length_params.append(u_param)\n\n        return arc_length_params\n\n    def _generate_data_from_edge(self, edge, num_points_arclength):\n        interval = edge.u_bounds()\n        if interval.invalid():\n            self.good = False\n            return\n        self.points = []\n        self.us = []\n        for i in range(num_points_arclength):\n            u = interval.interpolate(i / (num_points_arclength - 1))\n            self.points.append(edge.point(u))\n            self.us.append(u)\n\n    def _check_non_decreasing(self, us):\n        prev = us[0]\n        for u in us:\n            if u &lt; prev:\n                return False\n            prev = u\n        return True\n</code></pre>"},{"location":"api/#occwl.geometry.arc_length_param_finder.ArcLengthParamFinder.__init__","title":"<code>__init__(points=None, us=None, edge=None, num_arc_length_samples=100)</code>","text":"<p>Create a class to generate arc-length parameters</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>list(np.array</code> <p>Point samples on the curve</p> <code>None</code> <code>us</code> <code>list(float</code> <p>u parameters on the curve</p> <code>None</code> <code>edge</code> <code>Edge</code> <p>An edge</p> <code>None</code> <code>num_arc_length_samples</code> <code>int</code> <p>The number of samples to use the the calculation</p> <code>100</code> Source code in <code>src/occwl/geometry/arc_length_param_finder.py</code> <pre><code>def __init__(self, points=None, us=None, edge=None, num_arc_length_samples=100):\n    \"\"\"\n    Create a class to generate arc-length parameters\n\n    Args:\n        points (list(np.array)): Point samples on the curve\n        us (list(float)): u parameters on the curve\n\n        or\n\n        edge (occwl.edge.Edge): An edge\n        num_arc_length_samples (int): The number of samples to use the the calculation\n    \"\"\"\n    self.good = True\n    if edge is not None:\n        # For an edge we can sample points directly\n        self._generate_data_from_edge(edge, num_arc_length_samples)\n    else:\n        # This code could be expanded to sample from surface iso-parametric lines\n        assert points is not None\n        assert us is not None\n        self.points = points\n        self.us = us\n</code></pre>"},{"location":"api/#occwl.geometry.arc_length_param_finder.ArcLengthParamFinder.find_arc_length_parameters","title":"<code>find_arc_length_parameters(num_samples)</code>","text":"<p>Find a list of u parameters which provides an equal arc length list for the given points and us</p> Source code in <code>src/occwl/geometry/arc_length_param_finder.py</code> <pre><code>def find_arc_length_parameters(self, num_samples):\n    \"\"\"\n    Find a list of u parameters which provides an equal arc length\n    list for the given points and us\n    \"\"\"\n    assert num_samples &gt;= 2\n    assert len(self.points) &gt;= 2\n    assert len(self.us) == len(self.points)\n\n    # Find the arc lengths between the sample points\n    lengths = []\n    total_length = 0\n    prev_point = None\n    for point in self.points:\n        if prev_point is not None:\n            length = np.linalg.norm(point - prev_point)\n            lengths.append(length)\n            total_length += length\n        prev_point = point\n\n    # Find the cumulative arc length over the points\n    arc_length_fraction = [0.0]\n    cumulative_length = 0.0\n    for length in lengths:\n        cumulative_length += length\n        arc_length_fraction.append(cumulative_length / total_length)\n\n    # Build the arc-length parameterization\n    arc_length_params = []\n    arc_length_index = 0\n    for i in range(num_samples):\n        desired_arc_length_fraction = i / (num_samples - 1)\n\n        # Find the correct span of the polyline\n        while arc_length_fraction[arc_length_index] &lt; desired_arc_length_fraction:\n            arc_length_index += 1\n            if arc_length_index &gt;= len(arc_length_fraction) - 1:\n                break\n\n        # Handle the special case at the first point\n        if arc_length_index == 0:\n            u_low = self.us[0]\n            frac_low = arc_length_fraction[0]\n        else:\n            u_low = self.us[arc_length_index - 1]\n            frac_low = arc_length_fraction[arc_length_index - 1]\n\n        # Find the arc length parameter by interpolation\n        u_high = self.us[arc_length_index]\n        frac_high = arc_length_fraction[arc_length_index]\n\n        # Check we found the correct range\n        assert desired_arc_length_fraction &gt;= frac_low\n        assert desired_arc_length_fraction &lt;= frac_high\n\n        d_frac = frac_high - frac_low\n        if d_frac &lt;= 0.0:\n            u_param = u_low\n        else:\n            u_interval = Interval(u_low, u_high)\n            position_in_interval = (desired_arc_length_fraction - frac_low) / (\n                d_frac\n            )\n            u_param = u_interval.interpolate(position_in_interval)\n        arc_length_params.append(u_param)\n\n    return arc_length_params\n</code></pre>"},{"location":"api/#occwl.geometry.box","title":"<code>box</code>","text":""},{"location":"api/#occwl.geometry.box.Box","title":"<code>Box</code>","text":"<p>A 2d or 3d box for points defined as numpy arrays</p> Source code in <code>src/occwl/geometry/box.py</code> <pre><code>class Box:\n    \"\"\"A 2d or 3d box for points defined as numpy arrays\"\"\"\n\n    def __init__(self, pt=None):\n        self.intervals = []\n        if pt is not None:\n            for value in pt:\n                self.intervals.append(Interval(value, value))\n\n    def encompass_box(self, box):\n        if len(self.intervals) == 0:\n            for interval in box.intervals:\n                self.intervals.append(interval)\n        else:\n            assert len(self.intervals) == len(box.intervals)\n            for i, interval in enumerate(box.intervals):\n                self.intervals[i].encompass_interval(interval)\n\n    def encompass_point(self, point):\n        if len(self.intervals) == 0:\n            for i, value in enumerate(point):\n                self.intervals.append(Interval(value, value))\n        else:\n            assert len(self.intervals) == point.size\n            for i, value in enumerate(point):\n                self.intervals[i].encompass_value(value)\n\n    def contains_point(self, point):\n        assert len(self.intervals) == point.size\n        for i, value in enumerate(point):\n            if not self.intervals[i].contains_value(value):\n                return False\n        return True\n\n    def contains_box(self, box):\n        assert len(self.intervals) == len(box.intervals)\n        for i, interval in enumerate(self.intervals):\n            if not interval.contains_interval(box.intervals[i]):\n                return False\n        return True\n\n    def x_length(self):\n        assert len(self.intervals) &gt;= 1\n        return self.intervals[0].length()\n\n    def y_length(self):\n        assert len(self.intervals) &gt;= 2\n        return self.intervals[1].length()\n\n    def z_length(self):\n        assert len(self.intervals) &gt;= 2\n        return self.intervals[2].length()\n\n    def max_box_length(self):\n        max_length = 0.0\n        for interval in self.intervals:\n            length = interval.length()\n            if length &gt; max_length:\n                max_length = length\n        return max_length\n\n    def min_point(self):\n        return np.array([interval.a for interval in self.intervals])\n\n    def max_point(self):\n        return np.array([interval.b for interval in self.intervals])\n\n    def diagonal(self):\n        return self.max_point() - self.min_point()\n\n    def center(self):\n        return np.array([interval.middle() for interval in self.intervals])\n\n    def offset(self, dist):\n        for i in range(len(self.intervals)):\n            self.intervals[i].offset(dist)\n</code></pre>"},{"location":"api/#occwl.geometry.interval","title":"<code>interval</code>","text":""},{"location":"api/#occwl.geometry.interval.Interval","title":"<code>Interval</code>","text":"Source code in <code>src/occwl/geometry/interval.py</code> <pre><code>class Interval:\n    def __init__(self, a=sys.float_info.max, b=-sys.float_info.max):\n        if a == sys.float_info.max or a &lt; b:\n            self.a = a\n            self.b = b\n        else:\n            self.a = b\n            self.b = a\n\n    def invalid(self):\n        \"\"\"\n        An invalid interval is uninitialized.\n        It can be thought of as an intervale containing \n        no points\n        \"\"\"\n        return self.b &lt; self.a\n\n    def encompass_interval(self, interval):\n        if self.a &gt; interval.a:\n            self.a = interval.a\n        if self.b &lt; interval.b:\n            self.b = interval.b\n\n    def encompass_value(self, value):\n        if self.a &gt; value:\n            self.a = value\n        if self.b &lt; value:\n            self.b = value\n\n    def contains_value(self, value):\n        assert not self.invalid(), \"Invalid interval\"\n        return self.a &lt;= value and value &lt;= self.b\n\n    def contains_interval(self, interval):\n        assert not self.invalid(), \"Invalid interval\"\n        assert self.a &lt;= self.b\n        assert interval.a &lt;= interval.b\n        return self.a &lt;= interval.a and interval.b &lt;= self.b\n\n    def length(self):\n        assert not self.invalid()\n        l = self.b - self.a\n        if l &lt; 0.0:\n            return 0.0\n        return l\n\n    def middle(self):\n        assert not self.invalid()\n        return (self.a + self.b) / 2.0\n\n    def interpolate(self, t):\n        \"\"\"Return a position inside the interval \n           which interpolates between a and b.  i.e.\n           If t==0 then return a\n           If t==1 then return b\n           If 0&lt;t&lt;1 then return a value inside the interval\n        \"\"\"\n        assert not self.invalid()\n        return (1.0 - t) * self.a + t * self.b\n\n    def offset(self, dist):\n        assert not self.invalid()\n        self.a -= dist\n        self.b += dist\n</code></pre>"},{"location":"api/#occwl.geometry.interval.Interval.interpolate","title":"<code>interpolate(t)</code>","text":"<p>Return a position inside the interval  which interpolates between a and b.  i.e. If t==0 then return a If t==1 then return b If 0&lt;t&lt;1 then return a value inside the interval</p> Source code in <code>src/occwl/geometry/interval.py</code> <pre><code>def interpolate(self, t):\n    \"\"\"Return a position inside the interval \n       which interpolates between a and b.  i.e.\n       If t==0 then return a\n       If t==1 then return b\n       If 0&lt;t&lt;1 then return a value inside the interval\n    \"\"\"\n    assert not self.invalid()\n    return (1.0 - t) * self.a + t * self.b\n</code></pre>"},{"location":"api/#occwl.geometry.interval.Interval.invalid","title":"<code>invalid()</code>","text":"<p>An invalid interval is uninitialized. It can be thought of as an intervale containing  no points</p> Source code in <code>src/occwl/geometry/interval.py</code> <pre><code>def invalid(self):\n    \"\"\"\n    An invalid interval is uninitialized.\n    It can be thought of as an intervale containing \n    no points\n    \"\"\"\n    return self.b &lt; self.a\n</code></pre>"},{"location":"api/#occwl.graph","title":"<code>graph</code>","text":""},{"location":"api/#occwl.graph.face_adjacency","title":"<code>face_adjacency(shape, self_loops=False)</code>","text":"<p>Creates a face adjacency graph from the given shape (Solid or Compound)</p> <p>Parameters:</p> Name Type Description Default <code>shape</code> <code>Shell, Solid, or Compound</code> <p>Shape</p> required <code>self_loops</code> <code>bool</code> <p>Whether to add self loops in the graph. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <p>nx.DiGraph: Each B-rep face is mapped to a node with its index and each B-rep edge is mapped to an edge in the graph         Node attributes:         - \"face\": contains the B-rep face         Edge attributes:         - \"edge\": contains the B-rep (ordered) edge         - \"edge_idx\": index of the (ordered) edge in the solid</p> <code>None</code> <p>if the shape is non-manifold or open</p> Source code in <code>src/occwl/graph.py</code> <pre><code>def face_adjacency(shape, self_loops=False):\n    \"\"\"\n    Creates a face adjacency graph from the given shape (Solid or Compound)\n\n    Args:\n        shape (Shell, Solid, or Compound): Shape\n        self_loops (bool, optional): Whether to add self loops in the graph. Defaults to False.\n\n    Returns:\n        nx.DiGraph: Each B-rep face is mapped to a node with its index and each B-rep edge is mapped to an edge in the graph\n                    Node attributes:\n                    - \"face\": contains the B-rep face\n                    Edge attributes:\n                    - \"edge\": contains the B-rep (ordered) edge\n                    - \"edge_idx\": index of the (ordered) edge in the solid\n        None: if the shape is non-manifold or open\n    \"\"\"\n    assert isinstance(shape, (Shell, Solid, Compound))\n    mapper = EntityMapper(shape)\n    graph = nx.DiGraph()\n    for face in shape.faces():\n        face_idx = mapper.face_index(face)\n        graph.add_node(face_idx, face=face)\n\n    for edge in shape.edges():\n        if not edge.has_curve():\n            continue\n        connected_faces = list(shape.faces_from_edge(edge))\n        if len(connected_faces) &lt; 2:\n            if edge.seam(connected_faces[0]) and self_loops:\n                face_idx = mapper.face_index(connected_faces[0])\n                graph.add_edge(face_idx, face_idx)\n        elif len(connected_faces) == 2:\n            left_face, right_face = edge.find_left_and_right_faces(connected_faces)\n            if left_face is None or right_face is None:\n                continue\n            edge_idx = mapper.oriented_edge_index(edge)\n            edge_reversed = edge.reversed_edge()\n            if not mapper.oriented_edge_exists(edge_reversed):\n                continue\n            edge_reversed_idx = mapper.oriented_edge_index(edge_reversed)\n            left_index = mapper.face_index(left_face)\n            right_index = mapper.face_index(right_face)\n            graph.add_edge(left_index, right_index, edge=edge, edge_index=edge_idx) \n            graph.add_edge(right_index, left_index, edge=edge_reversed, edge_index=edge_reversed_idx)\n        else:\n            raise RuntimeError(\"Expected a manifold, an edge must be incident on one/two faces\")\n    return graph\n</code></pre>"},{"location":"api/#occwl.graph.vertex_adjacency","title":"<code>vertex_adjacency(shape, self_loops=False)</code>","text":"<p>Creates a vertex adjacency graph from the given shape (Wire, Solid or Compound)</p> <p>Parameters:</p> Name Type Description Default <code>shape</code> <code>Wire, Face, Shell, Solid, or Compound</code> <p>Shape</p> required <code>self_loops</code> <code>bool</code> <p>Whether to add self loops in the graph. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <p>nx.DiGraph: Each B-rep vertex is mapped to a node with its index and each B-rep edge is mapped to an edge in the graph         Node attributes:         - \"vertex\": contains the B-rep vertex         Edge attributes:         - \"edge\": contains the B-rep (ordered) edge         - \"edge_idx\": index of the (ordered) edge in the solid</p> Source code in <code>src/occwl/graph.py</code> <pre><code>def vertex_adjacency(shape, self_loops=False):\n    \"\"\" \n    Creates a vertex adjacency graph from the given shape (Wire, Solid or Compound)\n\n    Args:\n        shape (Wire, Face, Shell, Solid, or Compound): Shape\n        self_loops (bool, optional): Whether to add self loops in the graph. Defaults to False.\n\n    Returns:\n        nx.DiGraph: Each B-rep vertex is mapped to a node with its index and each B-rep edge is mapped to an edge in the graph\n                    Node attributes:\n                    - \"vertex\": contains the B-rep vertex\n                    Edge attributes:\n                    - \"edge\": contains the B-rep (ordered) edge\n                    - \"edge_idx\": index of the (ordered) edge in the solid\n    \"\"\"\n    assert isinstance(shape, (Wire, Face, Shell, Solid, Compound))\n    mapper = EntityMapper(shape)\n    graph = nx.DiGraph()\n    for vert in shape.vertices():\n        vert_idx = mapper.vertex_index(vert)\n        graph.add_node(vert_idx, vertex=vert)\n\n    for edge in shape.edges():\n        connected_verts = list(shape.vertices_from_edge(edge))\n        if not edge.has_curve():\n            continue\n        if len(connected_verts) == 1:\n            if edge.closed_edge() and self_loops:\n                vert_idx = mapper.vertex_index(connected_verts[0])\n                graph.add_edge(vert_idx, vert_idx)\n        elif len(connected_verts) == 2:\n            # Don't add an edge if the edge doesn't exist in the model\n            if not mapper.oriented_edge_exists(edge):\n                continue\n            edge_idx = mapper.oriented_edge_index(edge)\n            edge_reversed = edge.reversed_edge()\n            if not mapper.oriented_edge_exists(edge_reversed):\n                continue\n            edge_reversed_idx = mapper.oriented_edge_index(edge_reversed)\n            vert_i_index = mapper.vertex_index(edge.start_vertex())\n            vert_j_index = mapper.vertex_index(edge.end_vertex())\n            graph.add_edge(\n                vert_i_index, vert_j_index, edge=edge, edge_index=edge_idx\n            )\n            graph.add_edge(\n                vert_j_index, vert_i_index, edge=edge_reversed, edge_index=edge_reversed_idx\n            )\n        else:\n            raise RuntimeError(\"Expected an edge two connected one/two vertices\")\n\n    return graph\n</code></pre>"},{"location":"api/#occwl.io","title":"<code>io</code>","text":""},{"location":"api/#occwl.io.load_single_compound_from_step","title":"<code>load_single_compound_from_step(step_filename)</code>","text":"<p>Load data from a STEP file as a single compound</p> <p>Parameters:</p> Name Type Description Default <code>step_filename</code> <code>str</code> <p>Path to STEP file</p> required <p>Returns:</p> Type Description <p>List of occwl.Compound: a single compound containing all shapes in                     the file</p> Source code in <code>src/occwl/io.py</code> <pre><code>@deprecated(target=None, deprecated_in=\"0.0.3\", remove_in=\"0.0.5\")\ndef load_single_compound_from_step(step_filename):\n    \"\"\"\n    Load data from a STEP file as a single compound\n\n    Args:\n        step_filename (str): Path to STEP file\n\n    Returns:\n        List of occwl.Compound: a single compound containing all shapes in\n                                the file\n    \"\"\"\n    return Compound.load_from_step(step_filename)\n</code></pre>"},{"location":"api/#occwl.io.load_step","title":"<code>load_step(step_filename)</code>","text":"<p>Load solids from a STEP file</p> <p>Parameters:</p> Name Type Description Default <code>step_filename</code> <code>str</code> <p>Path to STEP file</p> required <p>Returns:</p> Type Description <p>List of occwl.Solid: a list of solid models from the file</p> Source code in <code>src/occwl/io.py</code> <pre><code>@deprecated(target=None, deprecated_in=\"0.0.3\", remove_in=\"0.0.5\")\ndef load_step(step_filename):\n    \"\"\"Load solids from a STEP file\n\n    Args:\n        step_filename (str): Path to STEP file\n\n    Returns:\n        List of occwl.Solid: a list of solid models from the file\n    \"\"\"\n    compound = load_single_compound_from_step(step_filename)\n    return list(compound.solids())\n</code></pre>"},{"location":"api/#occwl.io.save_step","title":"<code>save_step(list_of_solids, filename)</code>","text":"<p>Save solids into a STEP file</p> <p>Parameters:</p> Name Type Description Default <code>list_of_solids</code> <code>List[Solid]</code> <p>List of solids</p> required <code>filename</code> <code>Path or str</code> <p>Output STEP file name</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>Whether successful</p> Source code in <code>src/occwl/io.py</code> <pre><code>def save_step(list_of_solids, filename):\n    \"\"\"Save solids into a STEP file\n\n    Args:\n        list_of_solids (List[occwl.solid.Solid]): List of solids\n        filename (pathlib.Path or str): Output STEP file name\n\n    Returns:\n        bool: Whether successful\n    \"\"\"\n    step_writer = STEPControl_Writer()\n    Interface_Static_SetCVal(\"write.step.schema\", \"AP203\")\n    for solid in list_of_solids:\n        assert isinstance(solid, (Solid, Compound))\n        step_writer.Transfer(solid.topods_shape(), STEPControl_AsIs)\n    status = step_writer.Write(str(filename))\n    return status == IFSelect_RetDone\n</code></pre>"},{"location":"api/#occwl.io.save_stl","title":"<code>save_stl(shape, filename, binary=True)</code>","text":"<p>Saves a tesselated entity as a STL file NOTE: Call Solid.triangulate_all_faces() first</p> <p>Parameters:</p> Name Type Description Default <code>shape</code> <code>[type]</code> <p>[description]</p> required <code>filename</code> <code>[type]</code> <p>[description]</p> required <code>binary</code> <code>bool</code> <p>[description]. Defaults to True.</p> <code>True</code> Source code in <code>src/occwl/io.py</code> <pre><code>def save_stl(shape, filename, binary=True):\n    \"\"\"Saves a tesselated entity as a STL file\n    NOTE: Call Solid.triangulate_all_faces() first\n\n    Args:\n        shape ([type]): [description]\n        filename ([type]): [description]\n        binary (bool, optional): [description]. Defaults to True.\n    \"\"\"\n    from OCC.Extend.DataExchange import write_stl_file\n\n    write_stl_file(shape, filename, mode=\"binary\" if binary else \"ascii\")\n</code></pre>"},{"location":"api/#occwl.io.save_svg","title":"<code>save_svg(shape, filename, export_hidden_edges=True, location=(0, 0, 0), direction=(1, 1, 1), color='black', line_width=0.1)</code>","text":"<p>Saves the shape outline as an SVG file</p> <p>Parameters:</p> Name Type Description Default <code>shape</code> <code>Any occwl topology type</code> <p>Any topological entity</p> required <code>filename</code> <code>str</code> <p>Path to output SVG</p> required <code>export_hidden_edges</code> <code>bool</code> <p>Whether to render hidden edges as dotted lines in the SVG. Defaults to True.</p> <code>True</code> <code>location</code> <code>tuple</code> <p>Location. Defaults to (0, 0, 0).</p> <code>(0, 0, 0)</code> <code>direction</code> <code>tuple</code> <p>Direction. Defaults to (1, 1, 1).</p> <code>(1, 1, 1)</code> <code>color</code> <code>str</code> <p>Color of the paths in SVG. Defaults to \"black\".</p> <code>'black'</code> <code>line_width</code> <code>float</code> <p>Width of each path. Defaults to 0.1.</p> <code>0.1</code> Source code in <code>src/occwl/io.py</code> <pre><code>def save_svg(\n    shape,\n    filename,\n    export_hidden_edges=True,\n    location=(0, 0, 0),\n    direction=(1, 1, 1),\n    color=\"black\",\n    line_width=0.1,\n):\n    \"\"\"Saves the shape outline as an SVG file\n\n    Args:\n        shape (Any occwl topology type): Any topological entity\n        filename (str): Path to output SVG\n        export_hidden_edges (bool, optional): Whether to render hidden edges as dotted lines in the SVG. Defaults to True.\n        location (tuple, optional): Location. Defaults to (0, 0, 0).\n        direction (tuple, optional): Direction. Defaults to (1, 1, 1).\n        color (str, optional): Color of the paths in SVG. Defaults to \"black\".\n        line_width (float, optional): Width of each path. Defaults to 0.1.\n    \"\"\"\n    if isinstance(shape, Solid):\n        shape = shape.topods_solid()\n    elif isinstance(shape, Face):\n        shape = shape.topods_face()\n    elif isinstance(shape, Edge):\n        shape = shape.topods_edge()\n    else:\n        raise NotImplementedError\n    svg_string = export_shape_to_svg(\n        shape,\n        filename=filename,\n        export_hidden_edges=export_hidden_edges,\n        location=gp_Pnt(*location),\n        direction=gp_Dir(*direction),\n        color=color,\n        line_width=line_width,\n        margin_left=0,\n        margin_top=0,\n    )\n</code></pre>"},{"location":"api/#occwl.jupyter_viewer","title":"<code>jupyter_viewer</code>","text":""},{"location":"api/#occwl.jupyter_viewer.JupyterViewer","title":"<code>JupyterViewer</code>","text":"<p>A viewer for models in a Jupyter notebook</p> Source code in <code>src/occwl/jupyter_viewer.py</code> <pre><code>class JupyterViewer:\n    \"\"\"\n    A viewer for models in a Jupyter notebook\n    \"\"\"\n\n    def __init__(\n        self,\n        size: Optional[Tuple[int, int]] = (640, 480),\n        background_color: Optional[str] =\"white\"\n    ):\n        \"\"\"\n        Construct the Viewer\n\n        Args:\n        \"\"\"\n        self._renderer = MultiSelectJupyterRenderer(\n            size=size, \n            background_color=background_color\n        )\n        self._renderer.register_select_callback(self._select_callback)\n        self._selected_faces = []\n        self._selected_edges = []\n\n\n    def display(\n        self, \n        shape, \n        update=False, \n        shape_color=None, \n        render_edges=False,\n        edge_color=None, \n        transparency=0.0\n    ):\n        \"\"\"\n        Display a shape (must be a Solid, Face, or Edge)\n\n        Args:\n            shape (Solid, Face, or Edge): Shape to display\n            update (bool, optional): Whether to update and repaint. Defaults to False.\n            shape_color ([type], optional): Color of the shape.\n            edge_color ([type], optional):  Color of the shape's edges.\n                                            Can be 'WHITE', 'BLUE', 'RED', 'GREEN', 'YELLOW',\n                                            'CYAN', 'BLACK', 'ORANGE' or [r,g,b] \n                                            Defaults to None.\n            render_edges (bool): Whether to render edges\n            transparency (float, optional): Defaults to 0. (opaque). 0. is fully opaque, 1. is fully transparent.\n        \"\"\"\n        shape = shape.topods_shape()\n\n        self._renderer.DisplayShape(\n            shape, \n            update=update, \n            shape_color=shape_color,\n            render_edges=render_edges,\n            edge_color=edge_color,\n            transparency=transparency != 0.,\n            opacity=1. - transparency\n        )\n\n    def display_face_colormap(\n        self, \n        solid,\n        values_for_faces,\n        color_map = \"rainbow\",\n        update=False, \n        render_edges=False,\n        edge_color=None,\n        transparency=0.\n    ):\n        \"\"\"\n        Display a solid with the faces colored according to\n        some scalar function.\n\n        Args:\n            solid (Solid,): Solid to display\n            update (bool, optional): Whether to update and repaint. Defaults to False.\n            color_map (str): Choose from https://matplotlib.org/stable/tutorials/colors/colormaps.html\n            values_for_faces (list, np.array): Array of values, one for each face \n            render_edges (bool): Whether to render edges\n            transparency (float, optional): Defaults to 0. (opaque). 0. is fully opaque, 1. is fully transparent.\n        \"\"\"\n        if not isinstance(values_for_faces, np.ndarray):\n            values_for_faces = np.array(values_for_faces)\n\n        assert values_for_faces.size == solid.num_faces(), \"Must have one value for each face\"\n\n        norm = Normalize(values_for_faces.min(), values_for_faces.max())\n        norm_values_for_faces = norm(values_for_faces)\n\n        color_mapper = get_cmap(color_map)\n        face_colors = color_mapper(norm_values_for_faces)[:, :3]\n\n        for face_index, face in enumerate(solid.faces()):\n            shape_color=rgb2hex(face_colors[face_index])\n            self.display(\n                face, \n                update=False, \n                shape_color=shape_color, \n                render_edges=render_edges,\n                edge_color=edge_color,\n                transparency=transparency\n            )\n\n        # Plot the color scale\n        ax = plt.subplot()\n        color_mapper = get_cmap(\"rainbow\")\n        values = np.arange(100)\n        values = np.stack([values]*5)\n        im = ax.imshow(values, color_mapper)\n        plt.tick_params(\n            axis='both',       # changes apply to the x-axis\n            which='both',      # both major and minor ticks are affected\n            bottom=False,      # ticks along the bottom edge are off\n            top=False,         # ticks along the top edge are off\n            left=False,        # ticks along the left edge are off\n            labelbottom=False, # labels along the bottom edge are off\n            labelleft=False    # labels along the left edge are off\n        ) \n        plt.show()\n\n        if update:\n            self.show()\n\n    def display_points(\n        self, \n        points, \n        normals=None, \n        point_color=\"red\", \n        point_width=4,\n        update=False\n    ):\n        \"\"\"\n        Display a set of points\n\n        Args:\n            points (np.array): Array of points size [ num_points x 3 ] \n        \"\"\"\n        self._renderer.add_points(\n            points, \n            vertex_color=point_color, \n            vertex_width=point_width, \n            update=update\n        )\n\n\n\n    def display_lines(\n        self, \n        start_points,\n        end_points,\n        line_color=\"blue\", \n        line_width=1,\n        update=False\n    ):\n        \"\"\"\n        Display points a set of points\n\n        Args:\n            start_points (np.array): Array of start_points size [ num_points x 3 ] \n            end_points (np.array): Array of end_points size [ num_points x 3 ] \n        \"\"\"\n        self._renderer.add_lines(\n            start_points,\n            end_points,\n            line_color=line_color, \n            line_width=line_width, \n            update=update\n        )\n\n\n    def display_unit_vectors(\n        self, \n        points,\n        directions,\n        line_color=\"blue\", \n        line_width=2,\n        update=False\n    ):\n        \"\"\"\n        Display a set of unit vectors\n\n        Args:\n            points (np.array): Array of points size [ num_points x 3 ] \n            directions (np.array): Array of directions size [ num_points x 3 ] \n        \"\"\"\n        mins = np.min(points, axis=0)\n        maxs = np.max(points, axis=0)\n        diag = maxs - mins\n        longest = np.max(diag)\n        line_length = longest/20\n        end_points = points + directions*line_length\n        self.display_lines(\n                points,\n                end_points,\n                line_color=line_color, \n                line_width=line_width,\n                update=False\n            )\n\n\n    def _select_callback(self, topo_ds_shape):\n        \"\"\"\n        Callback called when a selection occurs\n        \"\"\"\n        if type(topo_ds_shape) == TopoDS_Edge:\n            self._selected_edges.append(Edge(topo_ds_shape))\n        elif type(topo_ds_shape) == TopoDS_Face:\n            self._selected_faces.append(Face(topo_ds_shape))\n\n\n    def selected_faces(self):\n        \"\"\"\n        Get the selected faces\n\n        Returns:\n            List[Face]: List of selected faces\n        \"\"\"\n        return self._selected_faces\n\n\n    def selected_face_indices(self, entity_mapper):\n        \"\"\"\n        Get the selected face indices\n\n        Returns:\n           np.ndarray(int) : List of indices of selected faces\n        \"\"\"\n        selected_face_indices = []\n        for f in self._selected_faces:\n            selected_face_indices.append(entity_mapper.face_index(f))\n        return np.array(selected_face_indices)\n\n    def selected_edges(self):\n        \"\"\"\n        Get the selected edges\n\n        Returns:\n            List[Face]: List of selected edges\n        \"\"\"\n        return self._selected_faces\n\n    def selected_edge_indices(self, entity_mapper):\n        \"\"\"\n        Get the selected edge indices\n\n        Returns:\n           np.ndarray(int) : List of indices of selected edges\n        \"\"\"\n        selected_edge_indices = []\n        for e in self._selected_edges:\n            selected_edge_indices.append(entity_mapper.edge_index(e))\n        return np.array(selected_edge_indices)\n\n\n    def show(self):\n        \"\"\"\n        Show the viewer\n        \"\"\"\n        self._renderer.Display()\n</code></pre>"},{"location":"api/#occwl.jupyter_viewer.JupyterViewer.__init__","title":"<code>__init__(size=(640, 480), background_color='white')</code>","text":"<p>Construct the Viewer</p> <p>Args:</p> Source code in <code>src/occwl/jupyter_viewer.py</code> <pre><code>def __init__(\n    self,\n    size: Optional[Tuple[int, int]] = (640, 480),\n    background_color: Optional[str] =\"white\"\n):\n    \"\"\"\n    Construct the Viewer\n\n    Args:\n    \"\"\"\n    self._renderer = MultiSelectJupyterRenderer(\n        size=size, \n        background_color=background_color\n    )\n    self._renderer.register_select_callback(self._select_callback)\n    self._selected_faces = []\n    self._selected_edges = []\n</code></pre>"},{"location":"api/#occwl.jupyter_viewer.JupyterViewer.display","title":"<code>display(shape, update=False, shape_color=None, render_edges=False, edge_color=None, transparency=0.0)</code>","text":"<p>Display a shape (must be a Solid, Face, or Edge)</p> <p>Parameters:</p> Name Type Description Default <code>shape</code> <code>Solid, Face, or Edge</code> <p>Shape to display</p> required <code>update</code> <code>bool</code> <p>Whether to update and repaint. Defaults to False.</p> <code>False</code> <code>shape_color</code> <code>[type]</code> <p>Color of the shape.</p> <code>None</code> <code>edge_color</code> <code>[type]</code> <p>Color of the shape's edges.                             Can be 'WHITE', 'BLUE', 'RED', 'GREEN', 'YELLOW',                             'CYAN', 'BLACK', 'ORANGE' or [r,g,b]                              Defaults to None.</p> <code>None</code> <code>render_edges</code> <code>bool</code> <p>Whether to render edges</p> <code>False</code> <code>transparency</code> <code>float</code> <p>Defaults to 0. (opaque). 0. is fully opaque, 1. is fully transparent.</p> <code>0.0</code> Source code in <code>src/occwl/jupyter_viewer.py</code> <pre><code>def display(\n    self, \n    shape, \n    update=False, \n    shape_color=None, \n    render_edges=False,\n    edge_color=None, \n    transparency=0.0\n):\n    \"\"\"\n    Display a shape (must be a Solid, Face, or Edge)\n\n    Args:\n        shape (Solid, Face, or Edge): Shape to display\n        update (bool, optional): Whether to update and repaint. Defaults to False.\n        shape_color ([type], optional): Color of the shape.\n        edge_color ([type], optional):  Color of the shape's edges.\n                                        Can be 'WHITE', 'BLUE', 'RED', 'GREEN', 'YELLOW',\n                                        'CYAN', 'BLACK', 'ORANGE' or [r,g,b] \n                                        Defaults to None.\n        render_edges (bool): Whether to render edges\n        transparency (float, optional): Defaults to 0. (opaque). 0. is fully opaque, 1. is fully transparent.\n    \"\"\"\n    shape = shape.topods_shape()\n\n    self._renderer.DisplayShape(\n        shape, \n        update=update, \n        shape_color=shape_color,\n        render_edges=render_edges,\n        edge_color=edge_color,\n        transparency=transparency != 0.,\n        opacity=1. - transparency\n    )\n</code></pre>"},{"location":"api/#occwl.jupyter_viewer.JupyterViewer.display_face_colormap","title":"<code>display_face_colormap(solid, values_for_faces, color_map='rainbow', update=False, render_edges=False, edge_color=None, transparency=0.0)</code>","text":"<p>Display a solid with the faces colored according to some scalar function.</p> <p>Parameters:</p> Name Type Description Default <code>solid</code> <code>(Solid,)</code> <p>Solid to display</p> required <code>update</code> <code>bool</code> <p>Whether to update and repaint. Defaults to False.</p> <code>False</code> <code>color_map</code> <code>str</code> <p>Choose from https://matplotlib.org/stable/tutorials/colors/colormaps.html</p> <code>'rainbow'</code> <code>values_for_faces</code> <code>(list, array)</code> <p>Array of values, one for each face </p> required <code>render_edges</code> <code>bool</code> <p>Whether to render edges</p> <code>False</code> <code>transparency</code> <code>float</code> <p>Defaults to 0. (opaque). 0. is fully opaque, 1. is fully transparent.</p> <code>0.0</code> Source code in <code>src/occwl/jupyter_viewer.py</code> <pre><code>def display_face_colormap(\n    self, \n    solid,\n    values_for_faces,\n    color_map = \"rainbow\",\n    update=False, \n    render_edges=False,\n    edge_color=None,\n    transparency=0.\n):\n    \"\"\"\n    Display a solid with the faces colored according to\n    some scalar function.\n\n    Args:\n        solid (Solid,): Solid to display\n        update (bool, optional): Whether to update and repaint. Defaults to False.\n        color_map (str): Choose from https://matplotlib.org/stable/tutorials/colors/colormaps.html\n        values_for_faces (list, np.array): Array of values, one for each face \n        render_edges (bool): Whether to render edges\n        transparency (float, optional): Defaults to 0. (opaque). 0. is fully opaque, 1. is fully transparent.\n    \"\"\"\n    if not isinstance(values_for_faces, np.ndarray):\n        values_for_faces = np.array(values_for_faces)\n\n    assert values_for_faces.size == solid.num_faces(), \"Must have one value for each face\"\n\n    norm = Normalize(values_for_faces.min(), values_for_faces.max())\n    norm_values_for_faces = norm(values_for_faces)\n\n    color_mapper = get_cmap(color_map)\n    face_colors = color_mapper(norm_values_for_faces)[:, :3]\n\n    for face_index, face in enumerate(solid.faces()):\n        shape_color=rgb2hex(face_colors[face_index])\n        self.display(\n            face, \n            update=False, \n            shape_color=shape_color, \n            render_edges=render_edges,\n            edge_color=edge_color,\n            transparency=transparency\n        )\n\n    # Plot the color scale\n    ax = plt.subplot()\n    color_mapper = get_cmap(\"rainbow\")\n    values = np.arange(100)\n    values = np.stack([values]*5)\n    im = ax.imshow(values, color_mapper)\n    plt.tick_params(\n        axis='both',       # changes apply to the x-axis\n        which='both',      # both major and minor ticks are affected\n        bottom=False,      # ticks along the bottom edge are off\n        top=False,         # ticks along the top edge are off\n        left=False,        # ticks along the left edge are off\n        labelbottom=False, # labels along the bottom edge are off\n        labelleft=False    # labels along the left edge are off\n    ) \n    plt.show()\n\n    if update:\n        self.show()\n</code></pre>"},{"location":"api/#occwl.jupyter_viewer.JupyterViewer.display_lines","title":"<code>display_lines(start_points, end_points, line_color='blue', line_width=1, update=False)</code>","text":"<p>Display points a set of points</p> <p>Parameters:</p> Name Type Description Default <code>start_points</code> <code>array</code> <p>Array of start_points size [ num_points x 3 ] </p> required <code>end_points</code> <code>array</code> <p>Array of end_points size [ num_points x 3 ]</p> required Source code in <code>src/occwl/jupyter_viewer.py</code> <pre><code>def display_lines(\n    self, \n    start_points,\n    end_points,\n    line_color=\"blue\", \n    line_width=1,\n    update=False\n):\n    \"\"\"\n    Display points a set of points\n\n    Args:\n        start_points (np.array): Array of start_points size [ num_points x 3 ] \n        end_points (np.array): Array of end_points size [ num_points x 3 ] \n    \"\"\"\n    self._renderer.add_lines(\n        start_points,\n        end_points,\n        line_color=line_color, \n        line_width=line_width, \n        update=update\n    )\n</code></pre>"},{"location":"api/#occwl.jupyter_viewer.JupyterViewer.display_points","title":"<code>display_points(points, normals=None, point_color='red', point_width=4, update=False)</code>","text":"<p>Display a set of points</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>array</code> <p>Array of points size [ num_points x 3 ]</p> required Source code in <code>src/occwl/jupyter_viewer.py</code> <pre><code>def display_points(\n    self, \n    points, \n    normals=None, \n    point_color=\"red\", \n    point_width=4,\n    update=False\n):\n    \"\"\"\n    Display a set of points\n\n    Args:\n        points (np.array): Array of points size [ num_points x 3 ] \n    \"\"\"\n    self._renderer.add_points(\n        points, \n        vertex_color=point_color, \n        vertex_width=point_width, \n        update=update\n    )\n</code></pre>"},{"location":"api/#occwl.jupyter_viewer.JupyterViewer.display_unit_vectors","title":"<code>display_unit_vectors(points, directions, line_color='blue', line_width=2, update=False)</code>","text":"<p>Display a set of unit vectors</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>array</code> <p>Array of points size [ num_points x 3 ] </p> required <code>directions</code> <code>array</code> <p>Array of directions size [ num_points x 3 ]</p> required Source code in <code>src/occwl/jupyter_viewer.py</code> <pre><code>def display_unit_vectors(\n    self, \n    points,\n    directions,\n    line_color=\"blue\", \n    line_width=2,\n    update=False\n):\n    \"\"\"\n    Display a set of unit vectors\n\n    Args:\n        points (np.array): Array of points size [ num_points x 3 ] \n        directions (np.array): Array of directions size [ num_points x 3 ] \n    \"\"\"\n    mins = np.min(points, axis=0)\n    maxs = np.max(points, axis=0)\n    diag = maxs - mins\n    longest = np.max(diag)\n    line_length = longest/20\n    end_points = points + directions*line_length\n    self.display_lines(\n            points,\n            end_points,\n            line_color=line_color, \n            line_width=line_width,\n            update=False\n        )\n</code></pre>"},{"location":"api/#occwl.jupyter_viewer.JupyterViewer.selected_edge_indices","title":"<code>selected_edge_indices(entity_mapper)</code>","text":"<p>Get the selected edge indices</p> <p>Returns:</p> Type Description <p>np.ndarray(int) : List of indices of selected edges</p> Source code in <code>src/occwl/jupyter_viewer.py</code> <pre><code>def selected_edge_indices(self, entity_mapper):\n    \"\"\"\n    Get the selected edge indices\n\n    Returns:\n       np.ndarray(int) : List of indices of selected edges\n    \"\"\"\n    selected_edge_indices = []\n    for e in self._selected_edges:\n        selected_edge_indices.append(entity_mapper.edge_index(e))\n    return np.array(selected_edge_indices)\n</code></pre>"},{"location":"api/#occwl.jupyter_viewer.JupyterViewer.selected_edges","title":"<code>selected_edges()</code>","text":"<p>Get the selected edges</p> <p>Returns:</p> Type Description <p>List[Face]: List of selected edges</p> Source code in <code>src/occwl/jupyter_viewer.py</code> <pre><code>def selected_edges(self):\n    \"\"\"\n    Get the selected edges\n\n    Returns:\n        List[Face]: List of selected edges\n    \"\"\"\n    return self._selected_faces\n</code></pre>"},{"location":"api/#occwl.jupyter_viewer.JupyterViewer.selected_face_indices","title":"<code>selected_face_indices(entity_mapper)</code>","text":"<p>Get the selected face indices</p> <p>Returns:</p> Type Description <p>np.ndarray(int) : List of indices of selected faces</p> Source code in <code>src/occwl/jupyter_viewer.py</code> <pre><code>def selected_face_indices(self, entity_mapper):\n    \"\"\"\n    Get the selected face indices\n\n    Returns:\n       np.ndarray(int) : List of indices of selected faces\n    \"\"\"\n    selected_face_indices = []\n    for f in self._selected_faces:\n        selected_face_indices.append(entity_mapper.face_index(f))\n    return np.array(selected_face_indices)\n</code></pre>"},{"location":"api/#occwl.jupyter_viewer.JupyterViewer.selected_faces","title":"<code>selected_faces()</code>","text":"<p>Get the selected faces</p> <p>Returns:</p> Type Description <p>List[Face]: List of selected faces</p> Source code in <code>src/occwl/jupyter_viewer.py</code> <pre><code>def selected_faces(self):\n    \"\"\"\n    Get the selected faces\n\n    Returns:\n        List[Face]: List of selected faces\n    \"\"\"\n    return self._selected_faces\n</code></pre>"},{"location":"api/#occwl.jupyter_viewer.JupyterViewer.show","title":"<code>show()</code>","text":"<p>Show the viewer</p> Source code in <code>src/occwl/jupyter_viewer.py</code> <pre><code>def show(self):\n    \"\"\"\n    Show the viewer\n    \"\"\"\n    self._renderer.Display()\n</code></pre>"},{"location":"api/#occwl.jupyter_viewer.MultiSelectJupyterRenderer","title":"<code>MultiSelectJupyterRenderer</code>","text":"<p>               Bases: <code>JupyterRenderer</code></p> <p>This class derived from JupyterRenderer allows more than  one shape to be selected at a time.</p> Source code in <code>src/occwl/jupyter_viewer.py</code> <pre><code>class MultiSelectJupyterRenderer(JupyterRenderer):\n    \"\"\"\n    This class derived from JupyterRenderer allows more than \n    one shape to be selected at a time.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super(MultiSelectJupyterRenderer, self).__init__(*args, **kwargs)\n\n    def click(self, value):\n        \"\"\" called whenever a shape  or edge is clicked\n        \"\"\"\n        try:\n            obj = value.owner.object\n            self.clicked_obj = obj\n            if self._current_mesh_selection != obj:\n                if obj is not None:\n                    self._shp_properties_button.disabled = False\n                    self._toggle_shp_visibility_button.disabled = False\n                    self._remove_shp_button.disabled = False\n                    id_clicked = obj.name  # the mesh id clicked\n                    self._current_mesh_selection = obj\n                    self._current_selection_material_color = obj.material.color\n                    obj.material.color = self._selection_color\n                    # selected part becomes transparent\n                    obj.material.transparent = True\n                    obj.material.opacity = 0.5\n                    # get the shape from this mesh id\n                    selected_shape = self._shapes[id_clicked]\n                    self._current_shape_selection = selected_shape\n                # then execute calbacks\n                for callback in self._select_callbacks:\n                    callback(self._current_shape_selection)\n        except Exception as e:\n            self.html.value = f\"{str(e)}\"\n\n    def add_points(self, points_array, vertex_color=\"red\", vertex_width=5, update=False):\n        \"\"\" \n        Args:\n            points_array (np.array): A numpy array of points [ num_points x 3 ]\n            vertex_color (str): color for the points\n            vertex_width (int): vertex width in pixels\n            update (bool): Update the display\n        \"\"\"\n        point_cloud_id = \"%s\" % uuid.uuid4().hex\n        points_array = np.array(points_array, dtype=np.float32)\n        attributes = {\"position\": BufferAttribute(points_array, normalized=False)}\n        mat = PointsMaterial(color=vertex_color, sizeAttenuation=True, size=vertex_width)\n        geom = BufferGeometry(attributes=attributes)\n        points = Points(geometry=geom, material=mat, name=point_cloud_id)\n        self._displayed_pickable_objects.add(points)\n\n        if update:\n            self.Display()\n\n    def add_lines(self, start_arr, end_arr, line_color=\"blue\", line_width=2, update=False):\n        \"\"\" \n        Args:\n            start_arr (np.array): A numpy array of points [ num_points x 3 ]\n            end_arr (np.array): A numpy array of points [ num_points x 3 ]\n            line_color (str): color for the points\n            vertex_width (int): vertex width in pixels\n            update (bool): Update the display\n        \"\"\"\n        line_cloud_id = \"%s\" % uuid.uuid4().hex\n        points = np.stack([start_arr, end_arr], axis=1)       \n        points = np.array(points, dtype=np.float32)    \n        geom = LineSegmentsGeometry(positions=points)\n        mat = LineMaterial(linewidth=line_width, color=line_color)\n        lines = LineSegments2(geom, mat, name=line_cloud_id)\n        self._displayed_pickable_objects.add(lines)\n\n        if update:\n            self.Display()\n</code></pre>"},{"location":"api/#occwl.jupyter_viewer.MultiSelectJupyterRenderer.add_lines","title":"<code>add_lines(start_arr, end_arr, line_color='blue', line_width=2, update=False)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>start_arr</code> <code>array</code> <p>A numpy array of points [ num_points x 3 ]</p> required <code>end_arr</code> <code>array</code> <p>A numpy array of points [ num_points x 3 ]</p> required <code>line_color</code> <code>str</code> <p>color for the points</p> <code>'blue'</code> <code>vertex_width</code> <code>int</code> <p>vertex width in pixels</p> required <code>update</code> <code>bool</code> <p>Update the display</p> <code>False</code> Source code in <code>src/occwl/jupyter_viewer.py</code> <pre><code>def add_lines(self, start_arr, end_arr, line_color=\"blue\", line_width=2, update=False):\n    \"\"\" \n    Args:\n        start_arr (np.array): A numpy array of points [ num_points x 3 ]\n        end_arr (np.array): A numpy array of points [ num_points x 3 ]\n        line_color (str): color for the points\n        vertex_width (int): vertex width in pixels\n        update (bool): Update the display\n    \"\"\"\n    line_cloud_id = \"%s\" % uuid.uuid4().hex\n    points = np.stack([start_arr, end_arr], axis=1)       \n    points = np.array(points, dtype=np.float32)    \n    geom = LineSegmentsGeometry(positions=points)\n    mat = LineMaterial(linewidth=line_width, color=line_color)\n    lines = LineSegments2(geom, mat, name=line_cloud_id)\n    self._displayed_pickable_objects.add(lines)\n\n    if update:\n        self.Display()\n</code></pre>"},{"location":"api/#occwl.jupyter_viewer.MultiSelectJupyterRenderer.add_points","title":"<code>add_points(points_array, vertex_color='red', vertex_width=5, update=False)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>points_array</code> <code>array</code> <p>A numpy array of points [ num_points x 3 ]</p> required <code>vertex_color</code> <code>str</code> <p>color for the points</p> <code>'red'</code> <code>vertex_width</code> <code>int</code> <p>vertex width in pixels</p> <code>5</code> <code>update</code> <code>bool</code> <p>Update the display</p> <code>False</code> Source code in <code>src/occwl/jupyter_viewer.py</code> <pre><code>def add_points(self, points_array, vertex_color=\"red\", vertex_width=5, update=False):\n    \"\"\" \n    Args:\n        points_array (np.array): A numpy array of points [ num_points x 3 ]\n        vertex_color (str): color for the points\n        vertex_width (int): vertex width in pixels\n        update (bool): Update the display\n    \"\"\"\n    point_cloud_id = \"%s\" % uuid.uuid4().hex\n    points_array = np.array(points_array, dtype=np.float32)\n    attributes = {\"position\": BufferAttribute(points_array, normalized=False)}\n    mat = PointsMaterial(color=vertex_color, sizeAttenuation=True, size=vertex_width)\n    geom = BufferGeometry(attributes=attributes)\n    points = Points(geometry=geom, material=mat, name=point_cloud_id)\n    self._displayed_pickable_objects.add(points)\n\n    if update:\n        self.Display()\n</code></pre>"},{"location":"api/#occwl.jupyter_viewer.MultiSelectJupyterRenderer.click","title":"<code>click(value)</code>","text":"<p>called whenever a shape  or edge is clicked</p> Source code in <code>src/occwl/jupyter_viewer.py</code> <pre><code>def click(self, value):\n    \"\"\" called whenever a shape  or edge is clicked\n    \"\"\"\n    try:\n        obj = value.owner.object\n        self.clicked_obj = obj\n        if self._current_mesh_selection != obj:\n            if obj is not None:\n                self._shp_properties_button.disabled = False\n                self._toggle_shp_visibility_button.disabled = False\n                self._remove_shp_button.disabled = False\n                id_clicked = obj.name  # the mesh id clicked\n                self._current_mesh_selection = obj\n                self._current_selection_material_color = obj.material.color\n                obj.material.color = self._selection_color\n                # selected part becomes transparent\n                obj.material.transparent = True\n                obj.material.opacity = 0.5\n                # get the shape from this mesh id\n                selected_shape = self._shapes[id_clicked]\n                self._current_shape_selection = selected_shape\n            # then execute calbacks\n            for callback in self._select_callbacks:\n                callback(self._current_shape_selection)\n    except Exception as e:\n        self.html.value = f\"{str(e)}\"\n</code></pre>"},{"location":"api/#occwl.shape","title":"<code>shape</code>","text":"<p>Base class for faces, edges and vertices</p>"},{"location":"api/#occwl.shape.ClosestPointData","title":"<code>ClosestPointData</code>","text":"<p>A class to record information about the closest point on a shape to some datum point</p> Source code in <code>src/occwl/shape.py</code> <pre><code>class ClosestPointData:\n    \"\"\"\n    A class to record information about the closest point on a shape\n    to some datum point\n    \"\"\"\n\n    def __init__(self, dist_shape_shape):\n        \"\"\"\n        Args:\n            dist_shape_shape (BRepExtrema_DistShapeShape): OCC class for distance to a shape\n        \"\"\"\n        assert dist_shape_shape.IsDone()\n        self.closest_entity = dist_shape_shape.SupportOnShape2(1)\n        self.closest_point = geom_utils.gp_to_numpy(dist_shape_shape.PointOnShape2(1))\n        self.distance = dist_shape_shape.Value()\n</code></pre>"},{"location":"api/#occwl.shape.ClosestPointData.__init__","title":"<code>__init__(dist_shape_shape)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>dist_shape_shape</code> <code>BRepExtrema_DistShapeShape</code> <p>OCC class for distance to a shape</p> required Source code in <code>src/occwl/shape.py</code> <pre><code>def __init__(self, dist_shape_shape):\n    \"\"\"\n    Args:\n        dist_shape_shape (BRepExtrema_DistShapeShape): OCC class for distance to a shape\n    \"\"\"\n    assert dist_shape_shape.IsDone()\n    self.closest_entity = dist_shape_shape.SupportOnShape2(1)\n    self.closest_point = geom_utils.gp_to_numpy(dist_shape_shape.PointOnShape2(1))\n    self.distance = dist_shape_shape.Value()\n</code></pre>"},{"location":"api/#occwl.shape.Shape","title":"<code>Shape</code>","text":"Source code in <code>src/occwl/shape.py</code> <pre><code>class Shape:\n    def __init__(self, topods_shape):\n        \"\"\"\n        Construct the Shape (this class is not meant to be instantiated directly)\n\n        Args:\n            topods_shape (OCC.Core.TopoDS.TopoDS_Vertex/Edge/Face/Wire/Shell/Solid): OCC TopoDS_* as provided by the derived class\n\n        Raises:\n            Exception: [description]\n        \"\"\"\n        if type(self) == Shape:\n            raise Exception(\"Shape must be subclassed and instantiated.\")\n        assert isinstance(\n            topods_shape,\n            (\n                TopoDS_Vertex,\n                TopoDS_Edge,\n                TopoDS_Face,\n                TopoDS_Wire,\n                TopoDS_Shell,\n                TopoDS_Solid,\n                TopoDS_Compound,\n                TopoDS_CompSolid,\n            ),\n        )\n        self._shape = topods_shape\n        self._top_exp = TopologyUtils.TopologyExplorer(self.topods_shape(), True)\n\n    def topods_shape(self):\n        \"\"\"\n        Get the underlying OCC shape\n\n        Returns:\n            OCC.Core.TopoDS.TopoDS_Vertex/Edge/Face/Wire/Shell/Solid: OCC TopoDS_*\n        \"\"\"\n        return self._shape\n\n    @staticmethod\n    def occwl_shape(topods_shape):\n        \"\"\"\n        Static method to create an occwl shape of the appropriate \n        class from the given topods_shape\n        Args:\n            topods_shape (OCC.Core.TopoDS.TopoDS_Vertex/Edge/Face/Wire/Shell/Solid): TopoDS shape\n\n        Returns:\n            One of\n                occwl.compound.Compound\n                occwl.solid.Solid\n                occwl.face.Face\n                occwl.edge.Edge\n                occwl.vertex.Vertex\n                occwl.wire.Wire\n                occwl.shell.Shell\n        Raises:\n            Exception: [description]\n        \"\"\"\n        from occwl.compound import Compound\n        from occwl.solid import Solid\n        from occwl.face import Face\n        from occwl.edge import Edge\n        from occwl.vertex import Vertex\n        from occwl.wire import Wire\n        from occwl.shell import Shell\n\n        if isinstance(topods_shape, TopoDS_Vertex):\n            return Vertex(topods_shape)\n        if isinstance(topods_shape, TopoDS_Edge):\n            return Edge(topods_shape)\n        if isinstance(topods_shape, TopoDS_Face):\n            return Face(topods_shape)\n        if isinstance(topods_shape, TopoDS_Wire):\n            return Wire(topods_shape)\n        if isinstance(topods_shape, TopoDS_Shell):\n            return Shell(topods_shape)\n        if isinstance(topods_shape, TopoDS_Solid):\n            return Solid(topods_shape)\n        if isinstance(topods_shape, (TopoDS_Compound, TopoDS_CompSolid)):\n            return Compound(topods_shape)\n        raise Exception(\n            \"Shape must be one of TopoDS_Vertex, TopoDS_Edge, TopoDS_Face, TopoDS_Shell, TopoDS_Solid, TopoDS_Compound, TopoDS_CompSolid\"\n        )\n\n    def __hash__(self):\n        \"\"\"\n        Hash for the shape\n\n        Returns:\n            int: Hash value\n        \"\"\"\n        return self.topods_shape().__hash__()\n\n    def __eq__(self, other):\n        \"\"\"\n        Equality check for the shape\n\n        NOTE: This function only checks if the shape is the same.\n        It doesn't check the edge orienation for example, so \n\n        edge1 == edge2\n\n        does not necessarily mean \n\n        edge1.reversed() == edge2.reversed()\n        \"\"\"\n        return self.topods_shape().__hash__() == other.topods_shape().__hash__()\n\n    def save_to_occ_native(\n            self, \n            filename, \n            verbosity=False,\n            with_triangles=False,\n            with_normals=False,\n            format_version=None\n        ):\n        \"\"\"\n        Save this shape into a native OCC binary .brep file.\n\n        Note:  Saving to and loading from the native file format \n               is between one and two orders of magnitude faster \n               than loading from STEP, so it is recommended for \n               large scale data processing\n\n        Args:\n            filename (str or pathlib.Path): .brep filename\n            with_triangles (bool): Whether to save triangle data cached in the shape.\n            with_normals (bool): Whether to save vertex normals cached in the shape\n            format_version (int):  Use None to save to the latest version\n                1 - first revision\n                2 - added storing of CurveOnSurface UV Points\n                3 - [OCCT 7.6] added storing of per-vertex normal information\n                               and dropped storing of CurveOnSurface UV Points\n        \"\"\"\n        self.save_shapes_to_occ_native(\n            filename, \n            [ self ],\n            with_triangles=with_triangles,\n            with_normals=with_normals,\n            format_version=format_version\n        )\n\n    @staticmethod\n    def save_shapes_to_occ_native(\n            filename, \n            shapes,\n            with_triangles=False,\n            with_normals=False,\n            format_version=None\n        ):\n        \"\"\"\n        Save this shape into a native OCC binary .brep file.\n\n        Note:  Saving to and loading from the native file format \n                is between one and two orders of magnitude faster \n                than loading from STEP, so it is recommended for \n                large scale data processing\n\n        Args:\n            filename (str or pathlib.Path): .brep filename\n\n            with_triangles (bool): Whether to save triangle data cached in the shape.\n            with_normals (bool): Whether to save vertex normals cached in the shape\n            format_version (int):  Use None to save to the latest version\n                1 - first revision\n                2 - added storing of CurveOnSurface UV Points\n                3 - [OCCT 7.6] added storing of per-vertex normal information\n                               and dropped storing of CurveOnSurface UV Points\n        \"\"\"\n        new_api = False\n        shapes_set = BRepTools_ShapeSet(with_triangles)\n        # shapes_set.SetWithNormals(with_normals) # Not in OCC 7.5.0\n\n        for shp in shapes:\n            shapes_set.Add(shp.topods_shape())\n        if format_version is not None:\n            shapes_set.SetFormatNb(format_version)\n\n\n        with open(filename, \"w\") as fp:\n            s = shapes_set.WriteToString()\n            fp.write(s)\n\n\n\n    def reversed(self):\n        \"\"\"\n        Whether this shape is reversed.\n\n        - For an edge this is whether the edge is reversed with respect to the curve geometry\n        - For a face this is whether the face is reversed with respect to the surface geometry\n        - For a vertex this is whether the vertex is at the upper or lower parameter value on the\n          edges curve\n\n        Returns:\n            bool: If rational\n        \"\"\"\n        return self.topods_shape().Orientation() == TopAbs_REVERSED\n\n\n    def find_closest_point_data(self, datum):\n        \"\"\"\n        Find the information about the closest point on this shape\n\n        Args:\n            datum (np.ndarray): 3D Point\n\n        Returns:\n            ClosestPointData: Data about the closest point on this shape\n            None: if error\n        \"\"\"\n        # Folowing https://dev.opencascade.org/content/how-retrieve-nearest-face-shape-given-gppnt\n        # Create a vertex from the point\n        occ_point = geom_utils.numpy_to_gp(datum)\n        vertex_maker = BRepBuilderAPI_MakeVertex(occ_point)\n        vertex = vertex_maker.Shape()\n        dist_shape_shape = BRepExtrema_DistShapeShape(\n            vertex, self.topods_shape(), Extrema_ExtFlag_MIN\n        )\n        ok = dist_shape_shape.Perform()\n        if not ok:\n            return None\n\n        return ClosestPointData(dist_shape_shape)\n\n    def translate(self, offset):\n        \"\"\"\n        Translate the shape by an offset vector\n\n        Args:\n            offset (np.ndarray): Offset vector\n        \"\"\"\n        self._shape = translate_shp(self._shape, geom_utils.numpy_to_gp_vec(offset))\n\n    def rotate_axis_angle(\n        self, axis, angle_radians, origin=np.zeros(3, dtype=np.float32)\n    ):\n        \"\"\"\n        Rotate the shape about the given axis by the given angle in radians\n\n        Args:\n            axis (np.ndarray): Rotation axis\n            angle_radians (float): Angle in radians\n        \"\"\"\n        self._shape = rotate_shape(\n            self._shape,\n            gp_Ax1(geom_utils.numpy_to_gp(origin), geom_utils.numpy_to_gp_dir(axis)),\n            angle_radians,\n            unite=\"rad\",\n        )\n\n    def rotate_euler_angles(self, angles_xyz_radians):\n        \"\"\"\n        Rotate the shape by the given Euler angles in radians\n\n        Args:\n            angle_xyz_radians (np.ndarray): 3D array with angles to rotate about x-axis, y-axis and z-axis respectively in radians\n        \"\"\"\n        self._shape = rotate_shp_3_axis(\n            self._shape,\n            angles_xyz_radians[0],\n            angles_xyz_radians[1],\n            angles_xyz_radians[2],\n            unity=\"rad\",\n        )\n\n    def scale(self, scale_vector):\n        \"\"\"\n        Scale the shape by the given 3D vector\n\n        Args:\n            scale_vector (np.ndarray): 3D array with scales to resize the shape along the x-axis, y-axis and z-axis respectively\n        \"\"\"\n        self._shape = scale_shape(\n            self._shape, scale_vector[0], scale_vector[1], scale_vector[2]\n        )\n\n    def valid(self, return_analyzer=False):\n        \"\"\"\n        Check if the shape is valid\n\n        Args:\n            return_analyzer (bool): Whether to return the BRepCheck_Analyzer object for more inspection\n\n        Returns:\n            bool: Whether the shape is valid\n            BRepCheck_Analyzer [optional]: if return_analyzer is True\n        \"\"\"\n        analyzer = BRepCheck_Analyzer(self.topods_shape())\n        if return_analyzer:\n            return analyzer.IsValid(), analyzer\n        return analyzer.IsValid()\n\n\n\n    def set_transform_to_identity(self):\n        \"\"\"\n        When an assembly is loaded from a STEP file\n        the solids will be transformed relative to\n        their local coordinate system.   i.e. they\n        are placed in the assembly root components \n        coordinate system.\n\n        When working with individual bodies you often\n        want them to be axis aligned, in which case \n        you want to remove the assembly transform.\n        This function removes it for you.\n\n        If however you want to bake the transform\n        into the bodies and suppress the asserts \n        from parts of occwl which don't cope with\n        transforms then use the transform() function\n        below with copy=True\n        \"\"\"\n        identity = TopLoc_Location()\n        self.topods_shape().Location(identity)\n        self._top_exp = TopologyUtils.TopologyExplorer(self.topods_shape(), True)\n        self.convert_geometric_identity_transforms_to_identity()\n\n\n    def convert_geometric_identity_transforms_to_identity(self):\n        \"\"\"\n        Open Cascade models sometimes contain transforms which\n        are \"geometrically\" identify transforms, but the identity\n        flag is not set.\n\n        This function checks each transform and sets the flag if \n        the appropriate.\n        \"\"\"\n        identity = TopLoc_Location()\n        if geom_utils.is_geometric_identity(\n            self.topods_shape().Location().Transformation()\n        ):\n            self.topods_shape().Location(identity)\n            self._top_exp = TopologyUtils.TopologyExplorer(self.topods_shape(), True)\n\n        for face in self._top_exp.faces():\n            if geom_utils.is_geometric_identity(face.Location().Transformation()):\n                face.Location(identity)\n\n        for edge in self._top_exp.edges():\n            if geom_utils.is_geometric_identity(edge.Location().Transformation()):\n                edge.Location(identity)\n\n        for vertex in self._top_exp.vertices():\n            if geom_utils.is_geometric_identity(vertex.Location().Transformation()):\n                vertex.Location(identity)\n\n\n    def transform(self, a: np.ndarray, copy=True):\n        \"\"\"\n        Apply the given 3x4 transform matrix to the solid.\n\n        Args: a (nd.array) - Homogeneous transform matrix\n                             The transform that will be applied is\n\n                             x' =  a[0,0]*x + a[0,1]*y + a[0,2]*z + a[0, 3]\n                             y' =  a[1,0]*x + a[1,1]*y + a[1,2]*z + a[1, 3]\n                             z' =  a[2,0]*x + a[2,1]*y + a[2,2]*z + a[2, 3]\n\n             copy (bool)    True - Copy entities and apply the transform to\n                                   the underlying geometry\n                            False - Apply the transform to the topods Locator\n                                    if possible \n        \"\"\"\n        assert (a.shape == (3, 4)), \"Transform matrix must be 3x4\"\n        a = a.astype(np.float64)\n\n        # Create an identity transform\n        trsf = gp_Trsf()\n\n        # If the matrix is an identity matrix then\n        # we don't want to set the values as this\n        # would give us a geometric identity without\n        # the identity flag set\n        if not np.allclose(a, np.eye(3, 4)):\n            trsf.SetValues(\n                a[0,0], a[0,1], a[0,2], a[0, 3],\n                a[1,0], a[1,1], a[1,2], a[1, 3],\n                a[2,0], a[2,1], a[2,2], a[2, 3]\n            )\n        return self._apply_transform(trsf, copy=copy)\n\n    def _apply_transform(self, trsf_to_apply, copy=True):\n        \"\"\"\n        Apply the given transform to this Shape\n        \"\"\"\n        apply_transform = BRepBuilderAPI_Transform(trsf_to_apply)\n        apply_transform.Perform(self.topods_shape(), copy)\n        transformed_shape = apply_transform.ModifiedShape(self.topods_shape())\n\n        return type(self)(transformed_shape)\n</code></pre>"},{"location":"api/#occwl.shape.Shape.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Equality check for the shape</p> <p>NOTE: This function only checks if the shape is the same. It doesn't check the edge orienation for example, so </p> <p>edge1 == edge2</p> <p>does not necessarily mean </p> <p>edge1.reversed() == edge2.reversed()</p> Source code in <code>src/occwl/shape.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"\n    Equality check for the shape\n\n    NOTE: This function only checks if the shape is the same.\n    It doesn't check the edge orienation for example, so \n\n    edge1 == edge2\n\n    does not necessarily mean \n\n    edge1.reversed() == edge2.reversed()\n    \"\"\"\n    return self.topods_shape().__hash__() == other.topods_shape().__hash__()\n</code></pre>"},{"location":"api/#occwl.shape.Shape.__hash__","title":"<code>__hash__()</code>","text":"<p>Hash for the shape</p> <p>Returns:</p> Name Type Description <code>int</code> <p>Hash value</p> Source code in <code>src/occwl/shape.py</code> <pre><code>def __hash__(self):\n    \"\"\"\n    Hash for the shape\n\n    Returns:\n        int: Hash value\n    \"\"\"\n    return self.topods_shape().__hash__()\n</code></pre>"},{"location":"api/#occwl.shape.Shape.__init__","title":"<code>__init__(topods_shape)</code>","text":"<p>Construct the Shape (this class is not meant to be instantiated directly)</p> <p>Parameters:</p> Name Type Description Default <code>topods_shape</code> <code>TopoDS_Vertex / Edge / Face / Wire / Shell / Solid</code> <p>OCC TopoDS_* as provided by the derived class</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>[description]</p> Source code in <code>src/occwl/shape.py</code> <pre><code>def __init__(self, topods_shape):\n    \"\"\"\n    Construct the Shape (this class is not meant to be instantiated directly)\n\n    Args:\n        topods_shape (OCC.Core.TopoDS.TopoDS_Vertex/Edge/Face/Wire/Shell/Solid): OCC TopoDS_* as provided by the derived class\n\n    Raises:\n        Exception: [description]\n    \"\"\"\n    if type(self) == Shape:\n        raise Exception(\"Shape must be subclassed and instantiated.\")\n    assert isinstance(\n        topods_shape,\n        (\n            TopoDS_Vertex,\n            TopoDS_Edge,\n            TopoDS_Face,\n            TopoDS_Wire,\n            TopoDS_Shell,\n            TopoDS_Solid,\n            TopoDS_Compound,\n            TopoDS_CompSolid,\n        ),\n    )\n    self._shape = topods_shape\n    self._top_exp = TopologyUtils.TopologyExplorer(self.topods_shape(), True)\n</code></pre>"},{"location":"api/#occwl.shape.Shape.convert_geometric_identity_transforms_to_identity","title":"<code>convert_geometric_identity_transforms_to_identity()</code>","text":"<p>Open Cascade models sometimes contain transforms which are \"geometrically\" identify transforms, but the identity flag is not set.</p> <p>This function checks each transform and sets the flag if  the appropriate.</p> Source code in <code>src/occwl/shape.py</code> <pre><code>def convert_geometric_identity_transforms_to_identity(self):\n    \"\"\"\n    Open Cascade models sometimes contain transforms which\n    are \"geometrically\" identify transforms, but the identity\n    flag is not set.\n\n    This function checks each transform and sets the flag if \n    the appropriate.\n    \"\"\"\n    identity = TopLoc_Location()\n    if geom_utils.is_geometric_identity(\n        self.topods_shape().Location().Transformation()\n    ):\n        self.topods_shape().Location(identity)\n        self._top_exp = TopologyUtils.TopologyExplorer(self.topods_shape(), True)\n\n    for face in self._top_exp.faces():\n        if geom_utils.is_geometric_identity(face.Location().Transformation()):\n            face.Location(identity)\n\n    for edge in self._top_exp.edges():\n        if geom_utils.is_geometric_identity(edge.Location().Transformation()):\n            edge.Location(identity)\n\n    for vertex in self._top_exp.vertices():\n        if geom_utils.is_geometric_identity(vertex.Location().Transformation()):\n            vertex.Location(identity)\n</code></pre>"},{"location":"api/#occwl.shape.Shape.find_closest_point_data","title":"<code>find_closest_point_data(datum)</code>","text":"<p>Find the information about the closest point on this shape</p> <p>Parameters:</p> Name Type Description Default <code>datum</code> <code>ndarray</code> <p>3D Point</p> required <p>Returns:</p> Name Type Description <code>ClosestPointData</code> <p>Data about the closest point on this shape</p> <code>None</code> <p>if error</p> Source code in <code>src/occwl/shape.py</code> <pre><code>def find_closest_point_data(self, datum):\n    \"\"\"\n    Find the information about the closest point on this shape\n\n    Args:\n        datum (np.ndarray): 3D Point\n\n    Returns:\n        ClosestPointData: Data about the closest point on this shape\n        None: if error\n    \"\"\"\n    # Folowing https://dev.opencascade.org/content/how-retrieve-nearest-face-shape-given-gppnt\n    # Create a vertex from the point\n    occ_point = geom_utils.numpy_to_gp(datum)\n    vertex_maker = BRepBuilderAPI_MakeVertex(occ_point)\n    vertex = vertex_maker.Shape()\n    dist_shape_shape = BRepExtrema_DistShapeShape(\n        vertex, self.topods_shape(), Extrema_ExtFlag_MIN\n    )\n    ok = dist_shape_shape.Perform()\n    if not ok:\n        return None\n\n    return ClosestPointData(dist_shape_shape)\n</code></pre>"},{"location":"api/#occwl.shape.Shape.occwl_shape","title":"<code>occwl_shape(topods_shape)</code>  <code>staticmethod</code>","text":"<p>Static method to create an occwl shape of the appropriate  class from the given topods_shape Args:     topods_shape (OCC.Core.TopoDS.TopoDS_Vertex/Edge/Face/Wire/Shell/Solid): TopoDS shape</p> <p>Returns:</p> Type Description <p>One of occwl.compound.Compound occwl.solid.Solid occwl.face.Face occwl.edge.Edge occwl.vertex.Vertex occwl.wire.Wire occwl.shell.Shell</p> <p>Raises:     Exception: [description]</p> Source code in <code>src/occwl/shape.py</code> <pre><code>@staticmethod\ndef occwl_shape(topods_shape):\n    \"\"\"\n    Static method to create an occwl shape of the appropriate \n    class from the given topods_shape\n    Args:\n        topods_shape (OCC.Core.TopoDS.TopoDS_Vertex/Edge/Face/Wire/Shell/Solid): TopoDS shape\n\n    Returns:\n        One of\n            occwl.compound.Compound\n            occwl.solid.Solid\n            occwl.face.Face\n            occwl.edge.Edge\n            occwl.vertex.Vertex\n            occwl.wire.Wire\n            occwl.shell.Shell\n    Raises:\n        Exception: [description]\n    \"\"\"\n    from occwl.compound import Compound\n    from occwl.solid import Solid\n    from occwl.face import Face\n    from occwl.edge import Edge\n    from occwl.vertex import Vertex\n    from occwl.wire import Wire\n    from occwl.shell import Shell\n\n    if isinstance(topods_shape, TopoDS_Vertex):\n        return Vertex(topods_shape)\n    if isinstance(topods_shape, TopoDS_Edge):\n        return Edge(topods_shape)\n    if isinstance(topods_shape, TopoDS_Face):\n        return Face(topods_shape)\n    if isinstance(topods_shape, TopoDS_Wire):\n        return Wire(topods_shape)\n    if isinstance(topods_shape, TopoDS_Shell):\n        return Shell(topods_shape)\n    if isinstance(topods_shape, TopoDS_Solid):\n        return Solid(topods_shape)\n    if isinstance(topods_shape, (TopoDS_Compound, TopoDS_CompSolid)):\n        return Compound(topods_shape)\n    raise Exception(\n        \"Shape must be one of TopoDS_Vertex, TopoDS_Edge, TopoDS_Face, TopoDS_Shell, TopoDS_Solid, TopoDS_Compound, TopoDS_CompSolid\"\n    )\n</code></pre>"},{"location":"api/#occwl.shape.Shape.reversed","title":"<code>reversed()</code>","text":"<p>Whether this shape is reversed.</p> <ul> <li>For an edge this is whether the edge is reversed with respect to the curve geometry</li> <li>For a face this is whether the face is reversed with respect to the surface geometry</li> <li>For a vertex this is whether the vertex is at the upper or lower parameter value on the   edges curve</li> </ul> <p>Returns:</p> Name Type Description <code>bool</code> <p>If rational</p> Source code in <code>src/occwl/shape.py</code> <pre><code>def reversed(self):\n    \"\"\"\n    Whether this shape is reversed.\n\n    - For an edge this is whether the edge is reversed with respect to the curve geometry\n    - For a face this is whether the face is reversed with respect to the surface geometry\n    - For a vertex this is whether the vertex is at the upper or lower parameter value on the\n      edges curve\n\n    Returns:\n        bool: If rational\n    \"\"\"\n    return self.topods_shape().Orientation() == TopAbs_REVERSED\n</code></pre>"},{"location":"api/#occwl.shape.Shape.rotate_axis_angle","title":"<code>rotate_axis_angle(axis, angle_radians, origin=np.zeros(3, dtype=(np.float32)))</code>","text":"<p>Rotate the shape about the given axis by the given angle in radians</p> <p>Parameters:</p> Name Type Description Default <code>axis</code> <code>ndarray</code> <p>Rotation axis</p> required <code>angle_radians</code> <code>float</code> <p>Angle in radians</p> required Source code in <code>src/occwl/shape.py</code> <pre><code>def rotate_axis_angle(\n    self, axis, angle_radians, origin=np.zeros(3, dtype=np.float32)\n):\n    \"\"\"\n    Rotate the shape about the given axis by the given angle in radians\n\n    Args:\n        axis (np.ndarray): Rotation axis\n        angle_radians (float): Angle in radians\n    \"\"\"\n    self._shape = rotate_shape(\n        self._shape,\n        gp_Ax1(geom_utils.numpy_to_gp(origin), geom_utils.numpy_to_gp_dir(axis)),\n        angle_radians,\n        unite=\"rad\",\n    )\n</code></pre>"},{"location":"api/#occwl.shape.Shape.rotate_euler_angles","title":"<code>rotate_euler_angles(angles_xyz_radians)</code>","text":"<p>Rotate the shape by the given Euler angles in radians</p> <p>Parameters:</p> Name Type Description Default <code>angle_xyz_radians</code> <code>ndarray</code> <p>3D array with angles to rotate about x-axis, y-axis and z-axis respectively in radians</p> required Source code in <code>src/occwl/shape.py</code> <pre><code>def rotate_euler_angles(self, angles_xyz_radians):\n    \"\"\"\n    Rotate the shape by the given Euler angles in radians\n\n    Args:\n        angle_xyz_radians (np.ndarray): 3D array with angles to rotate about x-axis, y-axis and z-axis respectively in radians\n    \"\"\"\n    self._shape = rotate_shp_3_axis(\n        self._shape,\n        angles_xyz_radians[0],\n        angles_xyz_radians[1],\n        angles_xyz_radians[2],\n        unity=\"rad\",\n    )\n</code></pre>"},{"location":"api/#occwl.shape.Shape.save_shapes_to_occ_native","title":"<code>save_shapes_to_occ_native(filename, shapes, with_triangles=False, with_normals=False, format_version=None)</code>  <code>staticmethod</code>","text":"<p>Save this shape into a native OCC binary .brep file.</p> Saving to and loading from the native file format <p>is between one and two orders of magnitude faster  than loading from STEP, so it is recommended for  large scale data processing</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str or Path</code> <p>.brep filename</p> required <code>with_triangles</code> <code>bool</code> <p>Whether to save triangle data cached in the shape.</p> <code>False</code> <code>with_normals</code> <code>bool</code> <p>Whether to save vertex normals cached in the shape</p> <code>False</code> <code>format_version</code> <code>int</code> <p>Use None to save to the latest version 1 - first revision 2 - added storing of CurveOnSurface UV Points 3 - [OCCT 7.6] added storing of per-vertex normal information                and dropped storing of CurveOnSurface UV Points</p> <code>None</code> Source code in <code>src/occwl/shape.py</code> <pre><code>@staticmethod\ndef save_shapes_to_occ_native(\n        filename, \n        shapes,\n        with_triangles=False,\n        with_normals=False,\n        format_version=None\n    ):\n    \"\"\"\n    Save this shape into a native OCC binary .brep file.\n\n    Note:  Saving to and loading from the native file format \n            is between one and two orders of magnitude faster \n            than loading from STEP, so it is recommended for \n            large scale data processing\n\n    Args:\n        filename (str or pathlib.Path): .brep filename\n\n        with_triangles (bool): Whether to save triangle data cached in the shape.\n        with_normals (bool): Whether to save vertex normals cached in the shape\n        format_version (int):  Use None to save to the latest version\n            1 - first revision\n            2 - added storing of CurveOnSurface UV Points\n            3 - [OCCT 7.6] added storing of per-vertex normal information\n                           and dropped storing of CurveOnSurface UV Points\n    \"\"\"\n    new_api = False\n    shapes_set = BRepTools_ShapeSet(with_triangles)\n    # shapes_set.SetWithNormals(with_normals) # Not in OCC 7.5.0\n\n    for shp in shapes:\n        shapes_set.Add(shp.topods_shape())\n    if format_version is not None:\n        shapes_set.SetFormatNb(format_version)\n\n\n    with open(filename, \"w\") as fp:\n        s = shapes_set.WriteToString()\n        fp.write(s)\n</code></pre>"},{"location":"api/#occwl.shape.Shape.save_to_occ_native","title":"<code>save_to_occ_native(filename, verbosity=False, with_triangles=False, with_normals=False, format_version=None)</code>","text":"<p>Save this shape into a native OCC binary .brep file.</p> Saving to and loading from the native file format <p>is between one and two orders of magnitude faster  than loading from STEP, so it is recommended for  large scale data processing</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str or Path</code> <p>.brep filename</p> required <code>with_triangles</code> <code>bool</code> <p>Whether to save triangle data cached in the shape.</p> <code>False</code> <code>with_normals</code> <code>bool</code> <p>Whether to save vertex normals cached in the shape</p> <code>False</code> <code>format_version</code> <code>int</code> <p>Use None to save to the latest version 1 - first revision 2 - added storing of CurveOnSurface UV Points 3 - [OCCT 7.6] added storing of per-vertex normal information                and dropped storing of CurveOnSurface UV Points</p> <code>None</code> Source code in <code>src/occwl/shape.py</code> <pre><code>def save_to_occ_native(\n        self, \n        filename, \n        verbosity=False,\n        with_triangles=False,\n        with_normals=False,\n        format_version=None\n    ):\n    \"\"\"\n    Save this shape into a native OCC binary .brep file.\n\n    Note:  Saving to and loading from the native file format \n           is between one and two orders of magnitude faster \n           than loading from STEP, so it is recommended for \n           large scale data processing\n\n    Args:\n        filename (str or pathlib.Path): .brep filename\n        with_triangles (bool): Whether to save triangle data cached in the shape.\n        with_normals (bool): Whether to save vertex normals cached in the shape\n        format_version (int):  Use None to save to the latest version\n            1 - first revision\n            2 - added storing of CurveOnSurface UV Points\n            3 - [OCCT 7.6] added storing of per-vertex normal information\n                           and dropped storing of CurveOnSurface UV Points\n    \"\"\"\n    self.save_shapes_to_occ_native(\n        filename, \n        [ self ],\n        with_triangles=with_triangles,\n        with_normals=with_normals,\n        format_version=format_version\n    )\n</code></pre>"},{"location":"api/#occwl.shape.Shape.scale","title":"<code>scale(scale_vector)</code>","text":"<p>Scale the shape by the given 3D vector</p> <p>Parameters:</p> Name Type Description Default <code>scale_vector</code> <code>ndarray</code> <p>3D array with scales to resize the shape along the x-axis, y-axis and z-axis respectively</p> required Source code in <code>src/occwl/shape.py</code> <pre><code>def scale(self, scale_vector):\n    \"\"\"\n    Scale the shape by the given 3D vector\n\n    Args:\n        scale_vector (np.ndarray): 3D array with scales to resize the shape along the x-axis, y-axis and z-axis respectively\n    \"\"\"\n    self._shape = scale_shape(\n        self._shape, scale_vector[0], scale_vector[1], scale_vector[2]\n    )\n</code></pre>"},{"location":"api/#occwl.shape.Shape.set_transform_to_identity","title":"<code>set_transform_to_identity()</code>","text":"<p>When an assembly is loaded from a STEP file the solids will be transformed relative to their local coordinate system.   i.e. they are placed in the assembly root components  coordinate system.</p> <p>When working with individual bodies you often want them to be axis aligned, in which case  you want to remove the assembly transform. This function removes it for you.</p> <p>If however you want to bake the transform into the bodies and suppress the asserts  from parts of occwl which don't cope with transforms then use the transform() function below with copy=True</p> Source code in <code>src/occwl/shape.py</code> <pre><code>def set_transform_to_identity(self):\n    \"\"\"\n    When an assembly is loaded from a STEP file\n    the solids will be transformed relative to\n    their local coordinate system.   i.e. they\n    are placed in the assembly root components \n    coordinate system.\n\n    When working with individual bodies you often\n    want them to be axis aligned, in which case \n    you want to remove the assembly transform.\n    This function removes it for you.\n\n    If however you want to bake the transform\n    into the bodies and suppress the asserts \n    from parts of occwl which don't cope with\n    transforms then use the transform() function\n    below with copy=True\n    \"\"\"\n    identity = TopLoc_Location()\n    self.topods_shape().Location(identity)\n    self._top_exp = TopologyUtils.TopologyExplorer(self.topods_shape(), True)\n    self.convert_geometric_identity_transforms_to_identity()\n</code></pre>"},{"location":"api/#occwl.shape.Shape.topods_shape","title":"<code>topods_shape()</code>","text":"<p>Get the underlying OCC shape</p> <p>Returns:</p> Type Description <p>OCC.Core.TopoDS.TopoDS_Vertex/Edge/Face/Wire/Shell/Solid: OCC TopoDS_*</p> Source code in <code>src/occwl/shape.py</code> <pre><code>def topods_shape(self):\n    \"\"\"\n    Get the underlying OCC shape\n\n    Returns:\n        OCC.Core.TopoDS.TopoDS_Vertex/Edge/Face/Wire/Shell/Solid: OCC TopoDS_*\n    \"\"\"\n    return self._shape\n</code></pre>"},{"location":"api/#occwl.shape.Shape.transform","title":"<code>transform(a, copy=True)</code>","text":"<p>Apply the given 3x4 transform matrix to the solid.</p> <pre><code> copy (bool)    True - Copy entities and apply the transform to\n                       the underlying geometry\n                False - Apply the transform to the topods Locator\n                        if possible\n</code></pre> Source code in <code>src/occwl/shape.py</code> <pre><code>def transform(self, a: np.ndarray, copy=True):\n    \"\"\"\n    Apply the given 3x4 transform matrix to the solid.\n\n    Args: a (nd.array) - Homogeneous transform matrix\n                         The transform that will be applied is\n\n                         x' =  a[0,0]*x + a[0,1]*y + a[0,2]*z + a[0, 3]\n                         y' =  a[1,0]*x + a[1,1]*y + a[1,2]*z + a[1, 3]\n                         z' =  a[2,0]*x + a[2,1]*y + a[2,2]*z + a[2, 3]\n\n         copy (bool)    True - Copy entities and apply the transform to\n                               the underlying geometry\n                        False - Apply the transform to the topods Locator\n                                if possible \n    \"\"\"\n    assert (a.shape == (3, 4)), \"Transform matrix must be 3x4\"\n    a = a.astype(np.float64)\n\n    # Create an identity transform\n    trsf = gp_Trsf()\n\n    # If the matrix is an identity matrix then\n    # we don't want to set the values as this\n    # would give us a geometric identity without\n    # the identity flag set\n    if not np.allclose(a, np.eye(3, 4)):\n        trsf.SetValues(\n            a[0,0], a[0,1], a[0,2], a[0, 3],\n            a[1,0], a[1,1], a[1,2], a[1, 3],\n            a[2,0], a[2,1], a[2,2], a[2, 3]\n        )\n    return self._apply_transform(trsf, copy=copy)\n</code></pre>"},{"location":"api/#occwl.shape.Shape.translate","title":"<code>translate(offset)</code>","text":"<p>Translate the shape by an offset vector</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>ndarray</code> <p>Offset vector</p> required Source code in <code>src/occwl/shape.py</code> <pre><code>def translate(self, offset):\n    \"\"\"\n    Translate the shape by an offset vector\n\n    Args:\n        offset (np.ndarray): Offset vector\n    \"\"\"\n    self._shape = translate_shp(self._shape, geom_utils.numpy_to_gp_vec(offset))\n</code></pre>"},{"location":"api/#occwl.shape.Shape.valid","title":"<code>valid(return_analyzer=False)</code>","text":"<p>Check if the shape is valid</p> <p>Parameters:</p> Name Type Description Default <code>return_analyzer</code> <code>bool</code> <p>Whether to return the BRepCheck_Analyzer object for more inspection</p> <code>False</code> <p>Returns:</p> Name Type Description <code>bool</code> <p>Whether the shape is valid</p> <p>BRepCheck_Analyzer [optional]: if return_analyzer is True</p> Source code in <code>src/occwl/shape.py</code> <pre><code>def valid(self, return_analyzer=False):\n    \"\"\"\n    Check if the shape is valid\n\n    Args:\n        return_analyzer (bool): Whether to return the BRepCheck_Analyzer object for more inspection\n\n    Returns:\n        bool: Whether the shape is valid\n        BRepCheck_Analyzer [optional]: if return_analyzer is True\n    \"\"\"\n    analyzer = BRepCheck_Analyzer(self.topods_shape())\n    if return_analyzer:\n        return analyzer.IsValid(), analyzer\n    return analyzer.IsValid()\n</code></pre>"},{"location":"api/#occwl.shell","title":"<code>shell</code>","text":""},{"location":"api/#occwl.shell.Shell","title":"<code>Shell</code>","text":"<p>               Bases: <code>BottomUpFaceIterator</code>, <code>BottomUpEdgeIterator</code>, <code>BoundingBoxMixin</code>, <code>VertexContainerMixin</code>, <code>EdgeContainerMixin</code>, <code>WireContainerMixin</code>, <code>FaceContainerMixin</code>, <code>SurfacePropertiesMixin</code>, <code>TriangulatorMixin</code>, <code>Shape</code></p> <p>A shell is a sewed set of faces.</p> Source code in <code>src/occwl/shell.py</code> <pre><code>class Shell(BottomUpFaceIterator, BottomUpEdgeIterator,\n    BoundingBoxMixin,  VertexContainerMixin, EdgeContainerMixin, WireContainerMixin, FaceContainerMixin,\n    SurfacePropertiesMixin, TriangulatorMixin, Shape):\n    \"\"\"\n    A shell is a sewed set of faces.\n    \"\"\"\n    def __init__(self, shape):\n        assert isinstance(shape, TopoDS_Shell)\n        super().__init__(shape)\n\n    @staticmethod\n    def make_by_sewing_faces(faces):\n        \"\"\"\n        Make a shell by sewing a set of faces with overlapping edges\n\n        Args:\n            faces (List[occwl.face.Face]): List of faces\n\n        Returns:\n            Shell or None: Sewed shell or None if the output was not a Shell\n        \"\"\"\n        sew = BRepBuilderAPI_Sewing()\n        for f in faces:\n            assert isinstance(f, Face)\n            sew.Add(f.topods_shape())\n        sew.Perform()\n        sewed_shape = sew.SewedShape()\n        if isinstance(sewed_shape, TopoDS_Shell):\n            return Shell(sewed_shape)\n        return None\n</code></pre>"},{"location":"api/#occwl.shell.Shell.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Equality check for the shape</p> <p>NOTE: This function only checks if the shape is the same. It doesn't check the edge orienation for example, so </p> <p>edge1 == edge2</p> <p>does not necessarily mean </p> <p>edge1.reversed() == edge2.reversed()</p> Source code in <code>src/occwl/shape.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"\n    Equality check for the shape\n\n    NOTE: This function only checks if the shape is the same.\n    It doesn't check the edge orienation for example, so \n\n    edge1 == edge2\n\n    does not necessarily mean \n\n    edge1.reversed() == edge2.reversed()\n    \"\"\"\n    return self.topods_shape().__hash__() == other.topods_shape().__hash__()\n</code></pre>"},{"location":"api/#occwl.shell.Shell.__hash__","title":"<code>__hash__()</code>","text":"<p>Hash for the shape</p> <p>Returns:</p> Name Type Description <code>int</code> <p>Hash value</p> Source code in <code>src/occwl/shape.py</code> <pre><code>def __hash__(self):\n    \"\"\"\n    Hash for the shape\n\n    Returns:\n        int: Hash value\n    \"\"\"\n    return self.topods_shape().__hash__()\n</code></pre>"},{"location":"api/#occwl.shell.Shell.area","title":"<code>area()</code>","text":"<p>Compute the area of the Shape</p> <p>Returns:</p> Name Type Description <code>float</code> <p>Area</p> Source code in <code>src/occwl/base.py</code> <pre><code>def area(self):\n    \"\"\"\n    Compute the area of the Shape\n\n    Returns:\n        float: Area\n    \"\"\"\n    geometry_properties = GProp_GProps()\n    brepgprop_SurfaceProperties(self.topods_shape(), geometry_properties)\n    return geometry_properties.Mass()\n</code></pre>"},{"location":"api/#occwl.shell.Shell.box","title":"<code>box()</code>","text":"<p>Get a quick bounding box of the Shape</p> <p>Returns:</p> Name Type Description <code>Box</code> <p>Bounding box</p> Source code in <code>src/occwl/base.py</code> <pre><code>def box(self):\n    \"\"\"\n    Get a quick bounding box of the Shape\n\n    Returns:\n        Box: Bounding box\n    \"\"\"\n    from occwl.geometry import geom_utils\n    b = Bnd_Box()\n    brepbndlib_Add(self.topods_shape(), b)\n    return geom_utils.box_to_geometry(b)\n</code></pre>"},{"location":"api/#occwl.shell.Shell.convert_geometric_identity_transforms_to_identity","title":"<code>convert_geometric_identity_transforms_to_identity()</code>","text":"<p>Open Cascade models sometimes contain transforms which are \"geometrically\" identify transforms, but the identity flag is not set.</p> <p>This function checks each transform and sets the flag if  the appropriate.</p> Source code in <code>src/occwl/shape.py</code> <pre><code>def convert_geometric_identity_transforms_to_identity(self):\n    \"\"\"\n    Open Cascade models sometimes contain transforms which\n    are \"geometrically\" identify transforms, but the identity\n    flag is not set.\n\n    This function checks each transform and sets the flag if \n    the appropriate.\n    \"\"\"\n    identity = TopLoc_Location()\n    if geom_utils.is_geometric_identity(\n        self.topods_shape().Location().Transformation()\n    ):\n        self.topods_shape().Location(identity)\n        self._top_exp = TopologyUtils.TopologyExplorer(self.topods_shape(), True)\n\n    for face in self._top_exp.faces():\n        if geom_utils.is_geometric_identity(face.Location().Transformation()):\n            face.Location(identity)\n\n    for edge in self._top_exp.edges():\n        if geom_utils.is_geometric_identity(edge.Location().Transformation()):\n            edge.Location(identity)\n\n    for vertex in self._top_exp.vertices():\n        if geom_utils.is_geometric_identity(vertex.Location().Transformation()):\n            vertex.Location(identity)\n</code></pre>"},{"location":"api/#occwl.shell.Shell.edge_continuity","title":"<code>edge_continuity(edge)</code>","text":"<p>Get the neighboring faces' continuity at given edge</p> <p>Parameters:</p> Name Type Description Default <code>edge</code> <code>Edge</code> <p>Edge</p> required <p>Returns:</p> Name Type Description <code>GeomAbs_Shape</code> <p>enum describing the continuity order</p> Source code in <code>src/occwl/base.py</code> <pre><code>def edge_continuity(self, edge):\n    \"\"\"\n    Get the neighboring faces' continuity at given edge\n\n    Args:\n        edge (occwl.edge.Edge): Edge\n\n    Returns:\n        GeomAbs_Shape: enum describing the continuity order\n    \"\"\"\n    faces = list(self.faces_from_edge(edge))\n    # Handle seam edges which only have one face around them\n    if len(faces) == 1:\n        faces.append(faces[-1])\n    return edge.continuity(faces[0], faces[1])\n</code></pre>"},{"location":"api/#occwl.shell.Shell.edges","title":"<code>edges()</code>","text":"<p>Get an iterator to go over all edges in the Shape</p> <p>Returns:</p> Type Description <p>Iterator[occwl.edge.Edge]: Edge iterator</p> Source code in <code>src/occwl/base.py</code> <pre><code>def edges(self):\n    \"\"\"\n    Get an iterator to go over all edges in the Shape\n\n    Returns:\n        Iterator[occwl.edge.Edge]: Edge iterator\n    \"\"\"\n    from occwl.edge import Edge\n    return map(Edge, self._top_exp.edges())\n</code></pre>"},{"location":"api/#occwl.shell.Shell.edges_from_face","title":"<code>edges_from_face(face)</code>","text":"<p>Get an iterator to go over the edges in a face</p> <p>Parameters:</p> Name Type Description Default <code>face</code> <code>Face</code> <p>Input face</p> required <p>Returns:</p> Type Description <p>Iterator[occwl.edge.Edge]: Edge iterator</p> Source code in <code>src/occwl/base.py</code> <pre><code>def edges_from_face(self, face):\n    \"\"\"\n    Get an iterator to go over the edges in a face\n\n    Args:\n        face (occwl.face.Face): Input face\n\n    Returns:\n        Iterator[occwl.edge.Edge]: Edge iterator\n    \"\"\"\n    from occwl.edge import Edge\n    from occwl.face import Face\n    assert isinstance(face, Face)\n    return map(Edge, self._top_exp.edges_from_face(face.topods_shape()))\n</code></pre>"},{"location":"api/#occwl.shell.Shell.edges_from_vertex","title":"<code>edges_from_vertex(vertex)</code>","text":"<p>Get an iterator to go over the edges adjacent to a vertex</p> <p>Parameters:</p> Name Type Description Default <code>face</code> <code>Face</code> <p>Input face</p> required <p>Returns:</p> Type Description <p>Iterator[occwl.edge.Edge]: Edge iterator</p> Source code in <code>src/occwl/base.py</code> <pre><code>def edges_from_vertex(self, vertex):\n    \"\"\"\n    Get an iterator to go over the edges adjacent to a vertex\n\n    Args:\n        face (occwl.face.Face): Input face\n\n    Returns:\n        Iterator[occwl.edge.Edge]: Edge iterator\n    \"\"\"\n    from occwl.vertex import Vertex\n    from occwl.edge import Edge\n    assert isinstance(vertex, Vertex)\n    return map(Edge, self._top_exp.edges_from_vertex(vertex.topods_shape()))\n</code></pre>"},{"location":"api/#occwl.shell.Shell.exact_box","title":"<code>exact_box(use_shapetolerance=False)</code>","text":"<p>Get a slow, but accurate box for the Shape.</p> <p>Returns:</p> Name Type Description <code>Box</code> <p>Bounding box</p> Source code in <code>src/occwl/base.py</code> <pre><code>def exact_box(self, use_shapetolerance=False):\n    \"\"\"\n    Get a slow, but accurate box for the Shape.\n\n    Args:\n        use_shapetolerance (bool, optional) Include the tolerance of edges\n                                            and vertices in the box.\n\n    Returns:\n        Box: Bounding box\n    \"\"\"\n    from occwl.geometry import geom_utils\n    b = Bnd_Box()\n    use_triangulation = True\n    brepbndlib_AddOptimal(self.topods_shape(), b, use_triangulation, use_shapetolerance)\n    return geom_utils.box_to_geometry(b)\n</code></pre>"},{"location":"api/#occwl.shell.Shell.faces","title":"<code>faces()</code>","text":"<p>Get an iterator to go over all faces in the Shape</p> <p>Returns:</p> Type Description <p>Iterator[occwl.face.Face]: Face iterator</p> Source code in <code>src/occwl/base.py</code> <pre><code>def faces(self):\n    \"\"\"\n    Get an iterator to go over all faces in the Shape\n\n    Returns:\n        Iterator[occwl.face.Face]: Face iterator\n    \"\"\"\n    from occwl.face import Face\n    return map(Face, self._top_exp.faces())\n</code></pre>"},{"location":"api/#occwl.shell.Shell.faces_from_edge","title":"<code>faces_from_edge(edge)</code>","text":"<p>Get an iterator to go over the faces adjacent to an edge</p> <p>Parameters:</p> Name Type Description Default <code>edge</code> <code>Edge</code> <p>Input edge</p> required <p>Returns:</p> Type Description <p>Iterator[occwl.face.Face]: Face iterator</p> Source code in <code>src/occwl/base.py</code> <pre><code>def faces_from_edge(self, edge):\n    \"\"\"\n    Get an iterator to go over the faces adjacent to an edge\n\n    Args:\n        edge (occwl.edge.Edge): Input edge\n\n    Returns:\n        Iterator[occwl.face.Face]: Face iterator\n    \"\"\"\n    from occwl.edge import Edge\n    from occwl.face import Face\n    assert isinstance(edge, Edge)\n    return map(Face, self._top_exp.faces_from_edge(edge.topods_shape()))\n</code></pre>"},{"location":"api/#occwl.shell.Shell.faces_from_vertex","title":"<code>faces_from_vertex(vertex)</code>","text":"<p>Get an iterator to go over the faces adjacent to a vertex</p> <p>Parameters:</p> Name Type Description Default <code>edge</code> <code>Vertex</code> <p>Input vertex</p> required <p>Returns:</p> Type Description <p>Iterator[occwl.face.Face]: Face iterator</p> Source code in <code>src/occwl/base.py</code> <pre><code>def faces_from_vertex(self, vertex):\n    \"\"\"\n    Get an iterator to go over the faces adjacent to a vertex\n\n    Args:\n        edge (occwl.vertex.Vertex): Input vertex\n\n    Returns:\n        Iterator[occwl.face.Face]: Face iterator\n    \"\"\"\n    from occwl.vertex import Vertex\n    from occwl.face import Face\n    assert isinstance(vertex, Vertex)\n    return map(Face, self._top_exp.faces_from_vertex(vertex.topods_shape()))\n</code></pre>"},{"location":"api/#occwl.shell.Shell.find_closest_edge_slow","title":"<code>find_closest_edge_slow(datum)</code>","text":"<p>Find the closest edge to the given datum point. The function is for testing only.  It will be slow  as it loops over all edges in the Shape. A quick way to find the closest entity is to call Shape.find_closest_point_data(), but then you may get a face, edge or vertex back.</p> <p>Parameters:</p> Name Type Description Default <code>datum</code> <code>ndarray or tuple</code> <p>3D datum point</p> required <p>Returns:</p> Name Type Description <code>Face</code> <p>The closest face in the Shape</p> Source code in <code>src/occwl/base.py</code> <pre><code>def find_closest_edge_slow(self, datum):\n    \"\"\"\n    Find the closest edge to the given datum point.\n    The function is for testing only.  It will be slow \n    as it loops over all edges in the Shape.\n    A quick way to find the closest entity is to call\n    Shape.find_closest_point_data(), but then you\n    may get a face, edge or vertex back.\n\n    Args:\n        datum (np.ndarray or tuple): 3D datum point\n\n    Returns:\n        Face: The closest face in the Shape\n    \"\"\"\n    return _find_closest_shape_in_list(self.edges(), datum)\n</code></pre>"},{"location":"api/#occwl.shell.Shell.find_closest_face_slow","title":"<code>find_closest_face_slow(datum)</code>","text":"<p>Find the closest face to the given datum point. The function is for testing only. It will be slow  as it loops over all faces in the Shape. A quick way to find the closest entity is to call Shape.find_closest_point_data(), but then you may get a face, edge or vertex back.</p> <p>Parameters:</p> Name Type Description Default <code>datum</code> <code>ndarray or tuple</code> <p>3D datum point</p> required <p>Returns:</p> Name Type Description <code>Face</code> <p>The closest face in the Shape</p> Source code in <code>src/occwl/base.py</code> <pre><code>def find_closest_face_slow(self, datum):\n    \"\"\"\n    Find the closest face to the given datum point.\n    The function is for testing only. It will be slow \n    as it loops over all faces in the Shape.\n    A quick way to find the closest entity is to call\n    Shape.find_closest_point_data(), but then you\n    may get a face, edge or vertex back.\n\n    Args:\n        datum (np.ndarray or tuple): 3D datum point\n\n    Returns:\n        Face: The closest face in the Shape\n    \"\"\"\n    return _find_closest_shape_in_list(self.faces(), datum)\n</code></pre>"},{"location":"api/#occwl.shell.Shell.find_closest_point_data","title":"<code>find_closest_point_data(datum)</code>","text":"<p>Find the information about the closest point on this shape</p> <p>Parameters:</p> Name Type Description Default <code>datum</code> <code>ndarray</code> <p>3D Point</p> required <p>Returns:</p> Name Type Description <code>ClosestPointData</code> <p>Data about the closest point on this shape</p> <code>None</code> <p>if error</p> Source code in <code>src/occwl/shape.py</code> <pre><code>def find_closest_point_data(self, datum):\n    \"\"\"\n    Find the information about the closest point on this shape\n\n    Args:\n        datum (np.ndarray): 3D Point\n\n    Returns:\n        ClosestPointData: Data about the closest point on this shape\n        None: if error\n    \"\"\"\n    # Folowing https://dev.opencascade.org/content/how-retrieve-nearest-face-shape-given-gppnt\n    # Create a vertex from the point\n    occ_point = geom_utils.numpy_to_gp(datum)\n    vertex_maker = BRepBuilderAPI_MakeVertex(occ_point)\n    vertex = vertex_maker.Shape()\n    dist_shape_shape = BRepExtrema_DistShapeShape(\n        vertex, self.topods_shape(), Extrema_ExtFlag_MIN\n    )\n    ok = dist_shape_shape.Perform()\n    if not ok:\n        return None\n\n    return ClosestPointData(dist_shape_shape)\n</code></pre>"},{"location":"api/#occwl.shell.Shell.get_triangles","title":"<code>get_triangles(triangle_face_tol=0.01, tol_relative_to_face=True, angle_tol_rads=0.1)</code>","text":"<p>Compute and get the tessellation of the entire shape</p> <p>Parameters:</p> Name Type Description Default <code>triangle_face_tol</code> <code>float</code> <p>Toelrance between triangle and surface. Defaults to 0.01.</p> <code>0.01</code> <code>tol_relative_to_face</code> <code>bool</code> <p>Whether tolerance is relative to face size</p> <code>True</code> <code>angle_tol_rads</code> <code>float</code> <p>Angle tolerance in radians. Defaults to 0.1.</p> <code>0.1</code> <p>Returns:</p> Type Description <p>2D np.ndarray (float): Vertices or None if triangulation failed</p> <p>2D np.ndarray (int): Faces or None if triangulation failed</p> Source code in <code>src/occwl/base.py</code> <pre><code>def get_triangles(\n    self,\n    triangle_face_tol=0.01,  # Tolerance between triangle and surface\n    tol_relative_to_face=True,  # The tolerance value is relative to the face size\n    angle_tol_rads=0.1,  # Angle between normals/tangents at triangle vertices\n):\n    \"\"\"\n    Compute and get the tessellation of the entire shape\n\n    Args:\n        triangle_face_tol (float, optional): Toelrance between triangle and surface. Defaults to 0.01.\n        tol_relative_to_face (bool): Whether tolerance is relative to face size\n        angle_tol_rads (float, optional): Angle tolerance in radians. Defaults to 0.1.\n\n    Returns:\n        2D np.ndarray (float): Vertices or None if triangulation failed\n        2D np.ndarray (int): Faces or None if triangulation failed\n    \"\"\"\n    ok = self.triangulate_all_faces(\n        triangle_face_tol, tol_relative_to_face, angle_tol_rads\n    )\n    if not ok:\n        # Failed to triangulate\n        return None, None\n    verts = []\n    tris = []\n    faces = self.faces()\n    last_vert_index = 0\n    for face in faces:\n        fverts, ftris = face.get_triangles()\n        verts.extend(fverts)\n        for tri in ftris:\n            new_indices = [index + last_vert_index for index in tri]\n            tris.append(new_indices)\n        last_vert_index = len(verts)\n    return np.asarray(verts, dtype=np.float32), np.asarray(tris, dtype=np.int32)\n</code></pre>"},{"location":"api/#occwl.shell.Shell.make_by_sewing_faces","title":"<code>make_by_sewing_faces(faces)</code>  <code>staticmethod</code>","text":"<p>Make a shell by sewing a set of faces with overlapping edges</p> <p>Parameters:</p> Name Type Description Default <code>faces</code> <code>List[Face]</code> <p>List of faces</p> required <p>Returns:</p> Type Description <p>Shell or None: Sewed shell or None if the output was not a Shell</p> Source code in <code>src/occwl/shell.py</code> <pre><code>@staticmethod\ndef make_by_sewing_faces(faces):\n    \"\"\"\n    Make a shell by sewing a set of faces with overlapping edges\n\n    Args:\n        faces (List[occwl.face.Face]): List of faces\n\n    Returns:\n        Shell or None: Sewed shell or None if the output was not a Shell\n    \"\"\"\n    sew = BRepBuilderAPI_Sewing()\n    for f in faces:\n        assert isinstance(f, Face)\n        sew.Add(f.topods_shape())\n    sew.Perform()\n    sewed_shape = sew.SewedShape()\n    if isinstance(sewed_shape, TopoDS_Shell):\n        return Shell(sewed_shape)\n    return None\n</code></pre>"},{"location":"api/#occwl.shell.Shell.num_edges","title":"<code>num_edges()</code>","text":"<p>Number of edges in the Shape</p> <p>Returns:</p> Name Type Description <code>int</code> <p>Number of edges</p> Source code in <code>src/occwl/base.py</code> <pre><code>def num_edges(self):\n    \"\"\"\n    Number of edges in the Shape\n\n    Returns:\n        int: Number of edges\n    \"\"\"\n    return self._top_exp.number_of_edges()\n</code></pre>"},{"location":"api/#occwl.shell.Shell.num_faces","title":"<code>num_faces()</code>","text":"<p>Number of faces in the Shape</p> <p>Returns:</p> Name Type Description <code>int</code> <p>Number of faces</p> Source code in <code>src/occwl/base.py</code> <pre><code>def num_faces(self):\n    \"\"\"\n    Number of faces in the Shape\n\n    Returns:\n        int: Number of faces\n    \"\"\"\n    return self._top_exp.number_of_faces()\n</code></pre>"},{"location":"api/#occwl.shell.Shell.num_vertices","title":"<code>num_vertices()</code>","text":"<p>Number of vertices in the Shape</p> <p>Returns:</p> Name Type Description <code>int</code> <p>Number of vertices</p> Source code in <code>src/occwl/base.py</code> <pre><code>def num_vertices(self):\n    \"\"\"\n    Number of vertices in the Shape\n\n    Returns:\n        int: Number of vertices\n    \"\"\"\n    return self._top_exp.number_of_vertices()\n</code></pre>"},{"location":"api/#occwl.shell.Shell.num_wires","title":"<code>num_wires()</code>","text":"<p>Number of wires in the Shape</p> <p>Returns:</p> Name Type Description <code>int</code> <p>Number of wires</p> Source code in <code>src/occwl/base.py</code> <pre><code>def num_wires(self):\n    \"\"\"\n    Number of wires in the Shape\n\n    Returns:\n        int: Number of wires\n    \"\"\"\n    return self._top_exp.number_of_wires()\n</code></pre>"},{"location":"api/#occwl.shell.Shell.occwl_shape","title":"<code>occwl_shape(topods_shape)</code>  <code>staticmethod</code>","text":"<p>Static method to create an occwl shape of the appropriate  class from the given topods_shape Args:     topods_shape (OCC.Core.TopoDS.TopoDS_Vertex/Edge/Face/Wire/Shell/Solid): TopoDS shape</p> <p>Returns:</p> Type Description <p>One of occwl.compound.Compound occwl.solid.Solid occwl.face.Face occwl.edge.Edge occwl.vertex.Vertex occwl.wire.Wire occwl.shell.Shell</p> <p>Raises:     Exception: [description]</p> Source code in <code>src/occwl/shape.py</code> <pre><code>@staticmethod\ndef occwl_shape(topods_shape):\n    \"\"\"\n    Static method to create an occwl shape of the appropriate \n    class from the given topods_shape\n    Args:\n        topods_shape (OCC.Core.TopoDS.TopoDS_Vertex/Edge/Face/Wire/Shell/Solid): TopoDS shape\n\n    Returns:\n        One of\n            occwl.compound.Compound\n            occwl.solid.Solid\n            occwl.face.Face\n            occwl.edge.Edge\n            occwl.vertex.Vertex\n            occwl.wire.Wire\n            occwl.shell.Shell\n    Raises:\n        Exception: [description]\n    \"\"\"\n    from occwl.compound import Compound\n    from occwl.solid import Solid\n    from occwl.face import Face\n    from occwl.edge import Edge\n    from occwl.vertex import Vertex\n    from occwl.wire import Wire\n    from occwl.shell import Shell\n\n    if isinstance(topods_shape, TopoDS_Vertex):\n        return Vertex(topods_shape)\n    if isinstance(topods_shape, TopoDS_Edge):\n        return Edge(topods_shape)\n    if isinstance(topods_shape, TopoDS_Face):\n        return Face(topods_shape)\n    if isinstance(topods_shape, TopoDS_Wire):\n        return Wire(topods_shape)\n    if isinstance(topods_shape, TopoDS_Shell):\n        return Shell(topods_shape)\n    if isinstance(topods_shape, TopoDS_Solid):\n        return Solid(topods_shape)\n    if isinstance(topods_shape, (TopoDS_Compound, TopoDS_CompSolid)):\n        return Compound(topods_shape)\n    raise Exception(\n        \"Shape must be one of TopoDS_Vertex, TopoDS_Edge, TopoDS_Face, TopoDS_Shell, TopoDS_Solid, TopoDS_Compound, TopoDS_CompSolid\"\n    )\n</code></pre>"},{"location":"api/#occwl.shell.Shell.reversed","title":"<code>reversed()</code>","text":"<p>Whether this shape is reversed.</p> <ul> <li>For an edge this is whether the edge is reversed with respect to the curve geometry</li> <li>For a face this is whether the face is reversed with respect to the surface geometry</li> <li>For a vertex this is whether the vertex is at the upper or lower parameter value on the   edges curve</li> </ul> <p>Returns:</p> Name Type Description <code>bool</code> <p>If rational</p> Source code in <code>src/occwl/shape.py</code> <pre><code>def reversed(self):\n    \"\"\"\n    Whether this shape is reversed.\n\n    - For an edge this is whether the edge is reversed with respect to the curve geometry\n    - For a face this is whether the face is reversed with respect to the surface geometry\n    - For a vertex this is whether the vertex is at the upper or lower parameter value on the\n      edges curve\n\n    Returns:\n        bool: If rational\n    \"\"\"\n    return self.topods_shape().Orientation() == TopAbs_REVERSED\n</code></pre>"},{"location":"api/#occwl.shell.Shell.rotate_axis_angle","title":"<code>rotate_axis_angle(axis, angle_radians, origin=np.zeros(3, dtype=(np.float32)))</code>","text":"<p>Rotate the shape about the given axis by the given angle in radians</p> <p>Parameters:</p> Name Type Description Default <code>axis</code> <code>ndarray</code> <p>Rotation axis</p> required <code>angle_radians</code> <code>float</code> <p>Angle in radians</p> required Source code in <code>src/occwl/shape.py</code> <pre><code>def rotate_axis_angle(\n    self, axis, angle_radians, origin=np.zeros(3, dtype=np.float32)\n):\n    \"\"\"\n    Rotate the shape about the given axis by the given angle in radians\n\n    Args:\n        axis (np.ndarray): Rotation axis\n        angle_radians (float): Angle in radians\n    \"\"\"\n    self._shape = rotate_shape(\n        self._shape,\n        gp_Ax1(geom_utils.numpy_to_gp(origin), geom_utils.numpy_to_gp_dir(axis)),\n        angle_radians,\n        unite=\"rad\",\n    )\n</code></pre>"},{"location":"api/#occwl.shell.Shell.rotate_euler_angles","title":"<code>rotate_euler_angles(angles_xyz_radians)</code>","text":"<p>Rotate the shape by the given Euler angles in radians</p> <p>Parameters:</p> Name Type Description Default <code>angle_xyz_radians</code> <code>ndarray</code> <p>3D array with angles to rotate about x-axis, y-axis and z-axis respectively in radians</p> required Source code in <code>src/occwl/shape.py</code> <pre><code>def rotate_euler_angles(self, angles_xyz_radians):\n    \"\"\"\n    Rotate the shape by the given Euler angles in radians\n\n    Args:\n        angle_xyz_radians (np.ndarray): 3D array with angles to rotate about x-axis, y-axis and z-axis respectively in radians\n    \"\"\"\n    self._shape = rotate_shp_3_axis(\n        self._shape,\n        angles_xyz_radians[0],\n        angles_xyz_radians[1],\n        angles_xyz_radians[2],\n        unity=\"rad\",\n    )\n</code></pre>"},{"location":"api/#occwl.shell.Shell.save_shapes_to_occ_native","title":"<code>save_shapes_to_occ_native(filename, shapes, with_triangles=False, with_normals=False, format_version=None)</code>  <code>staticmethod</code>","text":"<p>Save this shape into a native OCC binary .brep file.</p> Saving to and loading from the native file format <p>is between one and two orders of magnitude faster  than loading from STEP, so it is recommended for  large scale data processing</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str or Path</code> <p>.brep filename</p> required <code>with_triangles</code> <code>bool</code> <p>Whether to save triangle data cached in the shape.</p> <code>False</code> <code>with_normals</code> <code>bool</code> <p>Whether to save vertex normals cached in the shape</p> <code>False</code> <code>format_version</code> <code>int</code> <p>Use None to save to the latest version 1 - first revision 2 - added storing of CurveOnSurface UV Points 3 - [OCCT 7.6] added storing of per-vertex normal information                and dropped storing of CurveOnSurface UV Points</p> <code>None</code> Source code in <code>src/occwl/shape.py</code> <pre><code>@staticmethod\ndef save_shapes_to_occ_native(\n        filename, \n        shapes,\n        with_triangles=False,\n        with_normals=False,\n        format_version=None\n    ):\n    \"\"\"\n    Save this shape into a native OCC binary .brep file.\n\n    Note:  Saving to and loading from the native file format \n            is between one and two orders of magnitude faster \n            than loading from STEP, so it is recommended for \n            large scale data processing\n\n    Args:\n        filename (str or pathlib.Path): .brep filename\n\n        with_triangles (bool): Whether to save triangle data cached in the shape.\n        with_normals (bool): Whether to save vertex normals cached in the shape\n        format_version (int):  Use None to save to the latest version\n            1 - first revision\n            2 - added storing of CurveOnSurface UV Points\n            3 - [OCCT 7.6] added storing of per-vertex normal information\n                           and dropped storing of CurveOnSurface UV Points\n    \"\"\"\n    new_api = False\n    shapes_set = BRepTools_ShapeSet(with_triangles)\n    # shapes_set.SetWithNormals(with_normals) # Not in OCC 7.5.0\n\n    for shp in shapes:\n        shapes_set.Add(shp.topods_shape())\n    if format_version is not None:\n        shapes_set.SetFormatNb(format_version)\n\n\n    with open(filename, \"w\") as fp:\n        s = shapes_set.WriteToString()\n        fp.write(s)\n</code></pre>"},{"location":"api/#occwl.shell.Shell.save_to_occ_native","title":"<code>save_to_occ_native(filename, verbosity=False, with_triangles=False, with_normals=False, format_version=None)</code>","text":"<p>Save this shape into a native OCC binary .brep file.</p> Saving to and loading from the native file format <p>is between one and two orders of magnitude faster  than loading from STEP, so it is recommended for  large scale data processing</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str or Path</code> <p>.brep filename</p> required <code>with_triangles</code> <code>bool</code> <p>Whether to save triangle data cached in the shape.</p> <code>False</code> <code>with_normals</code> <code>bool</code> <p>Whether to save vertex normals cached in the shape</p> <code>False</code> <code>format_version</code> <code>int</code> <p>Use None to save to the latest version 1 - first revision 2 - added storing of CurveOnSurface UV Points 3 - [OCCT 7.6] added storing of per-vertex normal information                and dropped storing of CurveOnSurface UV Points</p> <code>None</code> Source code in <code>src/occwl/shape.py</code> <pre><code>def save_to_occ_native(\n        self, \n        filename, \n        verbosity=False,\n        with_triangles=False,\n        with_normals=False,\n        format_version=None\n    ):\n    \"\"\"\n    Save this shape into a native OCC binary .brep file.\n\n    Note:  Saving to and loading from the native file format \n           is between one and two orders of magnitude faster \n           than loading from STEP, so it is recommended for \n           large scale data processing\n\n    Args:\n        filename (str or pathlib.Path): .brep filename\n        with_triangles (bool): Whether to save triangle data cached in the shape.\n        with_normals (bool): Whether to save vertex normals cached in the shape\n        format_version (int):  Use None to save to the latest version\n            1 - first revision\n            2 - added storing of CurveOnSurface UV Points\n            3 - [OCCT 7.6] added storing of per-vertex normal information\n                           and dropped storing of CurveOnSurface UV Points\n    \"\"\"\n    self.save_shapes_to_occ_native(\n        filename, \n        [ self ],\n        with_triangles=with_triangles,\n        with_normals=with_normals,\n        format_version=format_version\n    )\n</code></pre>"},{"location":"api/#occwl.shell.Shell.scale","title":"<code>scale(scale_vector)</code>","text":"<p>Scale the shape by the given 3D vector</p> <p>Parameters:</p> Name Type Description Default <code>scale_vector</code> <code>ndarray</code> <p>3D array with scales to resize the shape along the x-axis, y-axis and z-axis respectively</p> required Source code in <code>src/occwl/shape.py</code> <pre><code>def scale(self, scale_vector):\n    \"\"\"\n    Scale the shape by the given 3D vector\n\n    Args:\n        scale_vector (np.ndarray): 3D array with scales to resize the shape along the x-axis, y-axis and z-axis respectively\n    \"\"\"\n    self._shape = scale_shape(\n        self._shape, scale_vector[0], scale_vector[1], scale_vector[2]\n    )\n</code></pre>"},{"location":"api/#occwl.shell.Shell.scale_to_box","title":"<code>scale_to_box(box_side, copy=True)</code>","text":"<p>Translate and scale the Shape so it fits exactly  into the [-box_side, box_side]^3 box</p> <p>Returns:</p> Type Description <p>occwl..: The scaled version of this Shape</p> Source code in <code>src/occwl/base.py</code> <pre><code>def scale_to_box(self, box_side, copy=True):\n    \"\"\"\n    Translate and scale the Shape so it fits exactly \n    into the [-box_side, box_side]^3 box\n\n    Args:\n        box_side (float) The side length of the box\n        copy (bool)      True - Copy entities and apply the transform to\n                                the underlying geometry\n                         False - Apply the transform to the topods Locator\n                                 if possible \n\n    Returns:\n        occwl.*.*: The scaled version of this Shape\n    \"\"\"\n    from occwl.geometry import geom_utils\n    # Get an exact box for the Shape\n    box = self.exact_box()\n    center = box.center()\n    longest_length = box.max_box_length()\n\n    orig = gp_Pnt(0.0, 0.0, 0.0)\n    center = geom_utils.numpy_to_gp(center)\n    vec_center_to_orig = gp_Vec(center, orig)\n    move_to_center = gp_Trsf()\n    move_to_center.SetTranslation(vec_center_to_orig)\n\n    scale_trsf = gp_Trsf()\n    scale_trsf.SetScale(orig, (2.0 * box_side) / longest_length)\n    trsf_to_apply = scale_trsf.Multiplied(move_to_center)\n\n    return self._apply_transform(trsf_to_apply, copy=copy)\n</code></pre>"},{"location":"api/#occwl.shell.Shell.scale_to_unit_box","title":"<code>scale_to_unit_box(copy=True)</code>","text":"<p>Translate and scale the Shape so it fits exactly  into the [-1, 1]^3 box</p> <p>Returns:     The scaled version of this shape</p> Source code in <code>src/occwl/base.py</code> <pre><code>def scale_to_unit_box(self, copy=True):\n    \"\"\"\n    Translate and scale the Shape so it fits exactly \n    into the [-1, 1]^3 box\n\n    Args:\n        copy (bool)      True - Copy entities and apply the transform to\n                                    the underlying geometry\n                            False - Apply the transform to the topods Locator\n                                    if possible \n    Returns:\n        The scaled version of this shape\n    \"\"\"\n    return self.scale_to_box(1.0, copy=copy)\n</code></pre>"},{"location":"api/#occwl.shell.Shell.set_transform_to_identity","title":"<code>set_transform_to_identity()</code>","text":"<p>When an assembly is loaded from a STEP file the solids will be transformed relative to their local coordinate system.   i.e. they are placed in the assembly root components  coordinate system.</p> <p>When working with individual bodies you often want them to be axis aligned, in which case  you want to remove the assembly transform. This function removes it for you.</p> <p>If however you want to bake the transform into the bodies and suppress the asserts  from parts of occwl which don't cope with transforms then use the transform() function below with copy=True</p> Source code in <code>src/occwl/shape.py</code> <pre><code>def set_transform_to_identity(self):\n    \"\"\"\n    When an assembly is loaded from a STEP file\n    the solids will be transformed relative to\n    their local coordinate system.   i.e. they\n    are placed in the assembly root components \n    coordinate system.\n\n    When working with individual bodies you often\n    want them to be axis aligned, in which case \n    you want to remove the assembly transform.\n    This function removes it for you.\n\n    If however you want to bake the transform\n    into the bodies and suppress the asserts \n    from parts of occwl which don't cope with\n    transforms then use the transform() function\n    below with copy=True\n    \"\"\"\n    identity = TopLoc_Location()\n    self.topods_shape().Location(identity)\n    self._top_exp = TopologyUtils.TopologyExplorer(self.topods_shape(), True)\n    self.convert_geometric_identity_transforms_to_identity()\n</code></pre>"},{"location":"api/#occwl.shell.Shell.split_all_closed_edges","title":"<code>split_all_closed_edges(max_tol=0.01, precision=0.01, num_splits=1)</code>","text":"<p>Split all the closed edges in this shape</p> <p>Parameters:</p> Name Type Description Default <code>max_tol</code> <code>float</code> <p>Maximum tolerance allowed. Defaults to 0.01.</p> <code>0.01</code> <code>precision</code> <code>float</code> <p>Precision of the tool when splitting. Defaults to 0.01.</p> <code>0.01</code> <code>num_splits</code> <code>int</code> <p>Number of splits to perform. Each split edge will result in num_splits + 1 edges. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Type Description <p>occwl..: Shape with closed edges split</p> Source code in <code>src/occwl/base.py</code> <pre><code>def split_all_closed_edges(self, max_tol=0.01, precision=0.01, num_splits=1):\n    \"\"\"\n    Split all the closed edges in this shape\n\n    Args:\n        max_tol (float, optional): Maximum tolerance allowed. Defaults to 0.01.\n        precision (float, optional): Precision of the tool when splitting. Defaults to 0.01.\n        num_splits (int, optional): Number of splits to perform. Each split edge will result in num_splits + 1 edges. Defaults to 1.\n\n    Returns:\n        occwl.*.*: Shape with closed edges split\n    \"\"\"\n    divider = ShapeUpgrade_ShapeDivideClosedEdges(self.topods_shape())\n    divider.SetPrecision(precision)\n    divider.SetMinTolerance(0.1 * max_tol)\n    divider.SetMaxTolerance(max_tol)\n    divider.SetNbSplitPoints(num_splits)\n    ok = divider.Perform()\n    if not ok:\n        # Splitting failed or there were no closed edges to split\n        # Return the original shape\n        return self\n    return type(self)(divider.Result())\n</code></pre>"},{"location":"api/#occwl.shell.Shell.split_all_closed_faces","title":"<code>split_all_closed_faces(max_tol=0.01, precision=0.01, num_splits=1)</code>","text":"<p>Split all the closed faces in this shape</p> <p>Parameters:</p> Name Type Description Default <code>max_tol</code> <code>float</code> <p>Maximum tolerance allowed. Defaults to 0.01.</p> <code>0.01</code> <code>precision</code> <code>float</code> <p>Precision of the tool when splitting. Defaults to 0.01.</p> <code>0.01</code> <code>num_splits</code> <code>int</code> <p>Number of splits to perform. Each split face will result in num_splits + 1 faces. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Type Description <p>occwl..: Shape with closed faces split</p> Source code in <code>src/occwl/base.py</code> <pre><code>def split_all_closed_faces(self, max_tol=0.01, precision=0.01, num_splits=1):\n    \"\"\"\n    Split all the closed faces in this shape\n\n    Args:\n        max_tol (float, optional): Maximum tolerance allowed. Defaults to 0.01.\n        precision (float, optional): Precision of the tool when splitting. Defaults to 0.01.\n        num_splits (int, optional): Number of splits to perform. Each split face will result in num_splits + 1 faces. Defaults to 1.\n\n    Returns:\n        occwl.*.*: Shape with closed faces split\n    \"\"\"\n    divider = ShapeUpgrade_ShapeDivideClosed(self.topods_shape())\n    divider.SetPrecision(precision)\n    divider.SetMinTolerance(0.1 * max_tol)\n    divider.SetMaxTolerance(max_tol)\n    divider.SetNbSplitPoints(num_splits)\n    ok = divider.Perform()\n    if not ok:\n        # Splitting failed or there were no closed faces to split\n        # Return the original shape\n        return self\n    return type(self)(divider.Result())\n</code></pre>"},{"location":"api/#occwl.shell.Shell.topods_shape","title":"<code>topods_shape()</code>","text":"<p>Get the underlying OCC shape</p> <p>Returns:</p> Type Description <p>OCC.Core.TopoDS.TopoDS_Vertex/Edge/Face/Wire/Shell/Solid: OCC TopoDS_*</p> Source code in <code>src/occwl/shape.py</code> <pre><code>def topods_shape(self):\n    \"\"\"\n    Get the underlying OCC shape\n\n    Returns:\n        OCC.Core.TopoDS.TopoDS_Vertex/Edge/Face/Wire/Shell/Solid: OCC TopoDS_*\n    \"\"\"\n    return self._shape\n</code></pre>"},{"location":"api/#occwl.shell.Shell.transform","title":"<code>transform(a, copy=True)</code>","text":"<p>Apply the given 3x4 transform matrix to the solid.</p> <pre><code> copy (bool)    True - Copy entities and apply the transform to\n                       the underlying geometry\n                False - Apply the transform to the topods Locator\n                        if possible\n</code></pre> Source code in <code>src/occwl/shape.py</code> <pre><code>def transform(self, a: np.ndarray, copy=True):\n    \"\"\"\n    Apply the given 3x4 transform matrix to the solid.\n\n    Args: a (nd.array) - Homogeneous transform matrix\n                         The transform that will be applied is\n\n                         x' =  a[0,0]*x + a[0,1]*y + a[0,2]*z + a[0, 3]\n                         y' =  a[1,0]*x + a[1,1]*y + a[1,2]*z + a[1, 3]\n                         z' =  a[2,0]*x + a[2,1]*y + a[2,2]*z + a[2, 3]\n\n         copy (bool)    True - Copy entities and apply the transform to\n                               the underlying geometry\n                        False - Apply the transform to the topods Locator\n                                if possible \n    \"\"\"\n    assert (a.shape == (3, 4)), \"Transform matrix must be 3x4\"\n    a = a.astype(np.float64)\n\n    # Create an identity transform\n    trsf = gp_Trsf()\n\n    # If the matrix is an identity matrix then\n    # we don't want to set the values as this\n    # would give us a geometric identity without\n    # the identity flag set\n    if not np.allclose(a, np.eye(3, 4)):\n        trsf.SetValues(\n            a[0,0], a[0,1], a[0,2], a[0, 3],\n            a[1,0], a[1,1], a[1,2], a[1, 3],\n            a[2,0], a[2,1], a[2,2], a[2, 3]\n        )\n    return self._apply_transform(trsf, copy=copy)\n</code></pre>"},{"location":"api/#occwl.shell.Shell.translate","title":"<code>translate(offset)</code>","text":"<p>Translate the shape by an offset vector</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>ndarray</code> <p>Offset vector</p> required Source code in <code>src/occwl/shape.py</code> <pre><code>def translate(self, offset):\n    \"\"\"\n    Translate the shape by an offset vector\n\n    Args:\n        offset (np.ndarray): Offset vector\n    \"\"\"\n    self._shape = translate_shp(self._shape, geom_utils.numpy_to_gp_vec(offset))\n</code></pre>"},{"location":"api/#occwl.shell.Shell.triangulate","title":"<code>triangulate(triangle_face_tol=0.01, tol_relative_to_face=True, angle_tol_rads=0.1)</code>","text":"<p>Triangulate all the faces in the shape. You can then get the triangles  from each face separately using face.get_triangles(). If you wanted triangles for the entire shape then call shape.get_triangles() below. For more details see  https://old.opencascade.com/doc/occt-7.1.0/overview/html/occt_user_guides__modeling_algos.html#occt_modalg_11</p> <p>Parameters:</p> Name Type Description Default <code>triangle_face_tol</code> <code>float</code> <p>Tolerance between triangle and surface. Defaults to 0.01.</p> <code>0.01</code> <code>tol_relative_to_face</code> <code>bool</code> <p>Whether tolerance is relative to face size</p> <code>True</code> <code>angle_tol_rads</code> <code>float</code> <p>Angle tolerance in radians. Defaults to 0.1.</p> <code>0.1</code> <p>Returns:</p> Name Type Description <code>bool</code> <p>Is successful</p> Source code in <code>src/occwl/base.py</code> <pre><code>def triangulate(\n    self,\n    triangle_face_tol=0.01,  # Tolerance between triangle and surface\n    tol_relative_to_face=True,  # The tolerance value is relative to the face size\n    angle_tol_rads=0.1,  # Angle between normals/tangents at triangle vertices\n):\n    \"\"\"\n    Triangulate all the faces in the shape. You can then get the triangles \n    from each face separately using face.get_triangles().\n    If you wanted triangles for the entire shape then call\n    shape.get_triangles() below.\n    For more details see \n    https://old.opencascade.com/doc/occt-7.1.0/overview/html/occt_user_guides__modeling_algos.html#occt_modalg_11\n\n    Args:\n        triangle_face_tol (float, optional): Tolerance between triangle and surface. Defaults to 0.01.\n        tol_relative_to_face (bool): Whether tolerance is relative to face size\n        angle_tol_rads (float, optional): Angle tolerance in radians. Defaults to 0.1.\n\n    Returns:\n        bool: Is successful\n    \"\"\"\n    mesh = BRepMesh_IncrementalMesh(\n        self.topods_shape(),\n        triangle_face_tol,\n        tol_relative_to_face,\n        angle_tol_rads,\n        True,\n    )\n    mesh.Perform()\n    return mesh.IsDone()\n</code></pre>"},{"location":"api/#occwl.shell.Shell.valid","title":"<code>valid(return_analyzer=False)</code>","text":"<p>Check if the shape is valid</p> <p>Parameters:</p> Name Type Description Default <code>return_analyzer</code> <code>bool</code> <p>Whether to return the BRepCheck_Analyzer object for more inspection</p> <code>False</code> <p>Returns:</p> Name Type Description <code>bool</code> <p>Whether the shape is valid</p> <p>BRepCheck_Analyzer [optional]: if return_analyzer is True</p> Source code in <code>src/occwl/shape.py</code> <pre><code>def valid(self, return_analyzer=False):\n    \"\"\"\n    Check if the shape is valid\n\n    Args:\n        return_analyzer (bool): Whether to return the BRepCheck_Analyzer object for more inspection\n\n    Returns:\n        bool: Whether the shape is valid\n        BRepCheck_Analyzer [optional]: if return_analyzer is True\n    \"\"\"\n    analyzer = BRepCheck_Analyzer(self.topods_shape())\n    if return_analyzer:\n        return analyzer.IsValid(), analyzer\n    return analyzer.IsValid()\n</code></pre>"},{"location":"api/#occwl.shell.Shell.vertices","title":"<code>vertices()</code>","text":"<p>Get an iterator to go over all vertices in the Shape</p> <p>Returns:</p> Type Description <p>Iterator[occwl.vertex.Vertex]: Vertex iterator</p> Source code in <code>src/occwl/base.py</code> <pre><code>def vertices(self):\n    \"\"\"\n    Get an iterator to go over all vertices in the Shape\n\n    Returns:\n        Iterator[occwl.vertex.Vertex]: Vertex iterator\n    \"\"\"\n    from occwl.vertex import Vertex\n    return map(Vertex, self._top_exp.vertices())\n</code></pre>"},{"location":"api/#occwl.shell.Shell.vertices_from_edge","title":"<code>vertices_from_edge(edge)</code>","text":"<p>Get an iterator to go over the vertices bounding an edge</p> <p>Parameters:</p> Name Type Description Default <code>edge</code> <code>Edge</code> <p>Input edge</p> required <p>Returns:</p> Type Description <p>Iterator[occwl.vertex.Vertex]: Vertex iterator</p> Source code in <code>src/occwl/base.py</code> <pre><code>def vertices_from_edge(self, edge):\n    \"\"\"\n    Get an iterator to go over the vertices bounding an edge\n\n    Args:\n        edge (occwl.edge.Edge): Input edge\n\n    Returns:\n        Iterator[occwl.vertex.Vertex]: Vertex iterator\n    \"\"\"\n    from occwl.vertex import Vertex\n    from occwl.edge import Edge\n    assert isinstance(edge, Edge)\n    return map(Vertex, self._top_exp.vertices_from_edge(edge.topods_shape()))\n</code></pre>"},{"location":"api/#occwl.shell.Shell.vertices_from_face","title":"<code>vertices_from_face(face)</code>","text":"<p>Get an iterator to go over the vertices in a face</p> <p>Parameters:</p> Name Type Description Default <code>face</code> <code>Face</code> <p>Input face</p> required <p>Returns:</p> Type Description <p>Iterator[occwl.vertex.Vertex]: Vertex iterator</p> Source code in <code>src/occwl/base.py</code> <pre><code>def vertices_from_face(self, face):\n    \"\"\"\n    Get an iterator to go over the vertices in a face\n\n    Args:\n        face (occwl.face.Face): Input face\n\n    Returns:\n        Iterator[occwl.vertex.Vertex]: Vertex iterator\n    \"\"\"\n    from occwl.vertex import Vertex\n    from occwl.face import Face\n    assert isinstance(face, Face)\n    return map(Vertex, self._top_exp.vertices_from_face(face.topods_shape()))\n</code></pre>"},{"location":"api/#occwl.shell.Shell.wires","title":"<code>wires()</code>","text":"<p>Get an iterator to go over all wires in the Shape</p> <p>Returns:</p> Type Description <p>Iterator[occwl.wire.Wire]: Wire iterator</p> Source code in <code>src/occwl/base.py</code> <pre><code>def wires(self):\n    \"\"\"\n    Get an iterator to go over all wires in the Shape\n\n    Returns:\n        Iterator[occwl.wire.Wire]: Wire iterator\n    \"\"\"\n    from occwl.wire import Wire\n    return map(Wire, self._top_exp.wires())\n</code></pre>"},{"location":"api/#occwl.shell.Shell.wires_from_face","title":"<code>wires_from_face(face)</code>","text":"<p>Get an iterator to go over the wires bounding a face</p> <p>Parameters:</p> Name Type Description Default <code>face</code> <code>Face</code> <p>Input face</p> required <p>Returns:</p> Type Description <p>Iterator[occwl.wire.Wire]: Wire iterator</p> Source code in <code>src/occwl/base.py</code> <pre><code>def wires_from_face(self, face):\n    \"\"\"\n    Get an iterator to go over the wires bounding a face\n\n    Args:\n        face (occwl.face.Face): Input face\n\n    Returns:\n        Iterator[occwl.wire.Wire]: Wire iterator\n    \"\"\"\n    from occwl.wire import Wire\n    from occwl.face import Face\n    assert isinstance(face, Face)\n    return map(Wire, self._top_exp.wires_from_face(face.topods_shape()))\n</code></pre>"},{"location":"api/#occwl.solid","title":"<code>solid</code>","text":""},{"location":"api/#occwl.solid.Solid","title":"<code>Solid</code>","text":"<p>               Bases: <code>Shape</code>, <code>VertexContainerMixin</code>, <code>EdgeContainerMixin</code>, <code>ShellContainerMixin</code>, <code>WireContainerMixin</code>, <code>FaceContainerMixin</code>, <code>BottomUpFaceIterator</code>, <code>BottomUpEdgeIterator</code>, <code>SurfacePropertiesMixin</code>, <code>VolumePropertiesMixin</code>, <code>BoundingBoxMixin</code>, <code>TriangulatorMixin</code></p> <p>A solid model</p> Source code in <code>src/occwl/solid.py</code> <pre><code>class Solid(Shape, VertexContainerMixin, EdgeContainerMixin, ShellContainerMixin, \\\n            WireContainerMixin, FaceContainerMixin, BottomUpFaceIterator, \\\n            BottomUpEdgeIterator, SurfacePropertiesMixin, VolumePropertiesMixin, \\\n            BoundingBoxMixin, TriangulatorMixin):\n    \"\"\"\n    A solid model\n    \"\"\"\n\n    def __init__(self, shape, allow_compound=False):\n        if allow_compound:\n            assert (isinstance(shape, TopoDS_Solid) or \n                isinstance(shape, TopoDS_Compound) or \n                isinstance(shape, TopoDS_CompSolid))\n        else:\n            assert isinstance(shape, TopoDS_Solid)\n        super().__init__(shape)\n\n    @staticmethod\n    def make_box(width, height, depth):\n        from OCC.Core.BRepPrimAPI import BRepPrimAPI_MakeBox\n\n        return Solid(\n            BRepPrimAPI_MakeBox(float(width), float(height), float(depth)).Shape()\n        )\n\n    @staticmethod\n    def make_sphere(radius, center=(0, 0, 0)):\n        from OCC.Core.BRepPrimAPI import BRepPrimAPI_MakeSphere\n\n        return Solid(\n            BRepPrimAPI_MakeSphere(geom_utils.to_gp_pnt(center), float(radius)).Shape()\n        )\n\n    @staticmethod\n    def make_spherical_wedge(radius, center=(0, 0, 0), longitudinal_angle=2 * math.pi):\n        from OCC.Core.BRepPrimAPI import BRepPrimAPI_MakeSphere\n\n        return Solid(\n            BRepPrimAPI_MakeSphere(\n                geom_utils.to_gp_pnt(center), float(radius), float(longitudinal_angle)\n            ).Shape()\n        )\n\n    @staticmethod\n    def make_cone(\n        radius_bottom,\n        radius_top,\n        height,\n        apex_angle=2 * math.pi,\n        base_point=(0, 0, 0),\n        up_dir=(0, 0, 1),\n    ):\n        from OCC.Core.BRepPrimAPI import BRepPrimAPI_MakeCone\n\n        return Solid(\n            BRepPrimAPI_MakeCone(\n                gp_Ax2(geom_utils.to_gp_pnt(base_point), geom_utils.to_gp_dir(up_dir)),\n                float(radius_bottom),\n                float(radius_top),\n                float(height),\n                float(apex_angle),\n            ).Shape()\n        )\n\n    @staticmethod\n    def make_cylinder(\n        radius, height, angle=2 * math.pi, base_point=(0, 0, 0), up_dir=(0, 0, 1)\n    ):\n        from OCC.Core.BRepPrimAPI import BRepPrimAPI_MakeCylinder\n\n        return Solid(\n            BRepPrimAPI_MakeCylinder(\n                gp_Ax2(geom_utils.to_gp_pnt(base_point), geom_utils.to_gp_dir(up_dir)),\n                float(radius),\n                float(height),\n                float(angle),\n            ).Shape()\n        )\n\n    def is_closed(self):\n        \"\"\"\n        Checks and returns if the solid is closed (has no holes)\n\n        Returns:\n            bool: If closed\n        \"\"\"\n        # In Open Cascade, unlinked (open) edges can be identified\n        # as they appear in the edges iterator when ignore_orientation=False\n        # but are not present in any wire\n        ordered_edges = set()\n        for wire in self.wires():\n            for edge in wire.ordered_edges():\n                ordered_edges.add(edge.topods_shape())\n        unordered_edges = set([edge.topods_shape() for edge  in self.edges()])\n        missing_edges = unordered_edges - ordered_edges\n        return len(missing_edges) == 0\n\n    def check_unique_oriented_edges(self):\n        ordered_edges = set()\n        for wire in self.wires():\n            for oriented_edge in wire.ordered_edges():\n                is_reversed = oriented_edge.reversed()\n                tup = (oriented_edge, is_reversed)\n\n                # We want to detect the case where the oriented\n                # edges are not unique\n                if tup in ordered_edges:\n                    # Here we see the same oriented edges\n                    # appears twice in the solid.  This is the \n                    # failure case we need to flag \n                    return False\n\n                ordered_edges.add(tup)\n\n        return True\n</code></pre>"},{"location":"api/#occwl.solid.Solid.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Equality check for the shape</p> <p>NOTE: This function only checks if the shape is the same. It doesn't check the edge orienation for example, so </p> <p>edge1 == edge2</p> <p>does not necessarily mean </p> <p>edge1.reversed() == edge2.reversed()</p> Source code in <code>src/occwl/shape.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"\n    Equality check for the shape\n\n    NOTE: This function only checks if the shape is the same.\n    It doesn't check the edge orienation for example, so \n\n    edge1 == edge2\n\n    does not necessarily mean \n\n    edge1.reversed() == edge2.reversed()\n    \"\"\"\n    return self.topods_shape().__hash__() == other.topods_shape().__hash__()\n</code></pre>"},{"location":"api/#occwl.solid.Solid.__hash__","title":"<code>__hash__()</code>","text":"<p>Hash for the shape</p> <p>Returns:</p> Name Type Description <code>int</code> <p>Hash value</p> Source code in <code>src/occwl/shape.py</code> <pre><code>def __hash__(self):\n    \"\"\"\n    Hash for the shape\n\n    Returns:\n        int: Hash value\n    \"\"\"\n    return self.topods_shape().__hash__()\n</code></pre>"},{"location":"api/#occwl.solid.Solid.area","title":"<code>area()</code>","text":"<p>Compute the area of the Shape</p> <p>Returns:</p> Name Type Description <code>float</code> <p>Area</p> Source code in <code>src/occwl/base.py</code> <pre><code>def area(self):\n    \"\"\"\n    Compute the area of the Shape\n\n    Returns:\n        float: Area\n    \"\"\"\n    geometry_properties = GProp_GProps()\n    brepgprop_SurfaceProperties(self.topods_shape(), geometry_properties)\n    return geometry_properties.Mass()\n</code></pre>"},{"location":"api/#occwl.solid.Solid.box","title":"<code>box()</code>","text":"<p>Get a quick bounding box of the Shape</p> <p>Returns:</p> Name Type Description <code>Box</code> <p>Bounding box</p> Source code in <code>src/occwl/base.py</code> <pre><code>def box(self):\n    \"\"\"\n    Get a quick bounding box of the Shape\n\n    Returns:\n        Box: Bounding box\n    \"\"\"\n    from occwl.geometry import geom_utils\n    b = Bnd_Box()\n    brepbndlib_Add(self.topods_shape(), b)\n    return geom_utils.box_to_geometry(b)\n</code></pre>"},{"location":"api/#occwl.solid.Solid.center_of_mass","title":"<code>center_of_mass(tolerance=1e-09)</code>","text":"<p>Compute the center of mass of the Shape</p> <p>Parameters:</p> Name Type Description Default <code>tolerance</code> <code>float</code> <p>Tolerance. Defaults to 1e-9.</p> <code>1e-09</code> <p>Returns:</p> Type Description <p>np.ndarray: 3D point</p> Source code in <code>src/occwl/base.py</code> <pre><code>def center_of_mass(self, tolerance=1e-9):\n    \"\"\"\n    Compute the center of mass of the Shape\n\n    Args:\n        tolerance (float, optional): Tolerance. Defaults to 1e-9.\n\n    Returns:\n        np.ndarray: 3D point\n    \"\"\"\n    from occwl.geometry import geom_utils\n    props = GProp_GProps()\n    brepgprop_VolumeProperties(self.topods_shape(), props, tolerance)\n    com = props.CentreOfMass()\n    return geom_utils.gp_to_numpy(com)\n</code></pre>"},{"location":"api/#occwl.solid.Solid.convert_geometric_identity_transforms_to_identity","title":"<code>convert_geometric_identity_transforms_to_identity()</code>","text":"<p>Open Cascade models sometimes contain transforms which are \"geometrically\" identify transforms, but the identity flag is not set.</p> <p>This function checks each transform and sets the flag if  the appropriate.</p> Source code in <code>src/occwl/shape.py</code> <pre><code>def convert_geometric_identity_transforms_to_identity(self):\n    \"\"\"\n    Open Cascade models sometimes contain transforms which\n    are \"geometrically\" identify transforms, but the identity\n    flag is not set.\n\n    This function checks each transform and sets the flag if \n    the appropriate.\n    \"\"\"\n    identity = TopLoc_Location()\n    if geom_utils.is_geometric_identity(\n        self.topods_shape().Location().Transformation()\n    ):\n        self.topods_shape().Location(identity)\n        self._top_exp = TopologyUtils.TopologyExplorer(self.topods_shape(), True)\n\n    for face in self._top_exp.faces():\n        if geom_utils.is_geometric_identity(face.Location().Transformation()):\n            face.Location(identity)\n\n    for edge in self._top_exp.edges():\n        if geom_utils.is_geometric_identity(edge.Location().Transformation()):\n            edge.Location(identity)\n\n    for vertex in self._top_exp.vertices():\n        if geom_utils.is_geometric_identity(vertex.Location().Transformation()):\n            vertex.Location(identity)\n</code></pre>"},{"location":"api/#occwl.solid.Solid.edge_continuity","title":"<code>edge_continuity(edge)</code>","text":"<p>Get the neighboring faces' continuity at given edge</p> <p>Parameters:</p> Name Type Description Default <code>edge</code> <code>Edge</code> <p>Edge</p> required <p>Returns:</p> Name Type Description <code>GeomAbs_Shape</code> <p>enum describing the continuity order</p> Source code in <code>src/occwl/base.py</code> <pre><code>def edge_continuity(self, edge):\n    \"\"\"\n    Get the neighboring faces' continuity at given edge\n\n    Args:\n        edge (occwl.edge.Edge): Edge\n\n    Returns:\n        GeomAbs_Shape: enum describing the continuity order\n    \"\"\"\n    faces = list(self.faces_from_edge(edge))\n    # Handle seam edges which only have one face around them\n    if len(faces) == 1:\n        faces.append(faces[-1])\n    return edge.continuity(faces[0], faces[1])\n</code></pre>"},{"location":"api/#occwl.solid.Solid.edges","title":"<code>edges()</code>","text":"<p>Get an iterator to go over all edges in the Shape</p> <p>Returns:</p> Type Description <p>Iterator[occwl.edge.Edge]: Edge iterator</p> Source code in <code>src/occwl/base.py</code> <pre><code>def edges(self):\n    \"\"\"\n    Get an iterator to go over all edges in the Shape\n\n    Returns:\n        Iterator[occwl.edge.Edge]: Edge iterator\n    \"\"\"\n    from occwl.edge import Edge\n    return map(Edge, self._top_exp.edges())\n</code></pre>"},{"location":"api/#occwl.solid.Solid.edges_from_face","title":"<code>edges_from_face(face)</code>","text":"<p>Get an iterator to go over the edges in a face</p> <p>Parameters:</p> Name Type Description Default <code>face</code> <code>Face</code> <p>Input face</p> required <p>Returns:</p> Type Description <p>Iterator[occwl.edge.Edge]: Edge iterator</p> Source code in <code>src/occwl/base.py</code> <pre><code>def edges_from_face(self, face):\n    \"\"\"\n    Get an iterator to go over the edges in a face\n\n    Args:\n        face (occwl.face.Face): Input face\n\n    Returns:\n        Iterator[occwl.edge.Edge]: Edge iterator\n    \"\"\"\n    from occwl.edge import Edge\n    from occwl.face import Face\n    assert isinstance(face, Face)\n    return map(Edge, self._top_exp.edges_from_face(face.topods_shape()))\n</code></pre>"},{"location":"api/#occwl.solid.Solid.edges_from_vertex","title":"<code>edges_from_vertex(vertex)</code>","text":"<p>Get an iterator to go over the edges adjacent to a vertex</p> <p>Parameters:</p> Name Type Description Default <code>face</code> <code>Face</code> <p>Input face</p> required <p>Returns:</p> Type Description <p>Iterator[occwl.edge.Edge]: Edge iterator</p> Source code in <code>src/occwl/base.py</code> <pre><code>def edges_from_vertex(self, vertex):\n    \"\"\"\n    Get an iterator to go over the edges adjacent to a vertex\n\n    Args:\n        face (occwl.face.Face): Input face\n\n    Returns:\n        Iterator[occwl.edge.Edge]: Edge iterator\n    \"\"\"\n    from occwl.vertex import Vertex\n    from occwl.edge import Edge\n    assert isinstance(vertex, Vertex)\n    return map(Edge, self._top_exp.edges_from_vertex(vertex.topods_shape()))\n</code></pre>"},{"location":"api/#occwl.solid.Solid.exact_box","title":"<code>exact_box(use_shapetolerance=False)</code>","text":"<p>Get a slow, but accurate box for the Shape.</p> <p>Returns:</p> Name Type Description <code>Box</code> <p>Bounding box</p> Source code in <code>src/occwl/base.py</code> <pre><code>def exact_box(self, use_shapetolerance=False):\n    \"\"\"\n    Get a slow, but accurate box for the Shape.\n\n    Args:\n        use_shapetolerance (bool, optional) Include the tolerance of edges\n                                            and vertices in the box.\n\n    Returns:\n        Box: Bounding box\n    \"\"\"\n    from occwl.geometry import geom_utils\n    b = Bnd_Box()\n    use_triangulation = True\n    brepbndlib_AddOptimal(self.topods_shape(), b, use_triangulation, use_shapetolerance)\n    return geom_utils.box_to_geometry(b)\n</code></pre>"},{"location":"api/#occwl.solid.Solid.faces","title":"<code>faces()</code>","text":"<p>Get an iterator to go over all faces in the Shape</p> <p>Returns:</p> Type Description <p>Iterator[occwl.face.Face]: Face iterator</p> Source code in <code>src/occwl/base.py</code> <pre><code>def faces(self):\n    \"\"\"\n    Get an iterator to go over all faces in the Shape\n\n    Returns:\n        Iterator[occwl.face.Face]: Face iterator\n    \"\"\"\n    from occwl.face import Face\n    return map(Face, self._top_exp.faces())\n</code></pre>"},{"location":"api/#occwl.solid.Solid.faces_from_edge","title":"<code>faces_from_edge(edge)</code>","text":"<p>Get an iterator to go over the faces adjacent to an edge</p> <p>Parameters:</p> Name Type Description Default <code>edge</code> <code>Edge</code> <p>Input edge</p> required <p>Returns:</p> Type Description <p>Iterator[occwl.face.Face]: Face iterator</p> Source code in <code>src/occwl/base.py</code> <pre><code>def faces_from_edge(self, edge):\n    \"\"\"\n    Get an iterator to go over the faces adjacent to an edge\n\n    Args:\n        edge (occwl.edge.Edge): Input edge\n\n    Returns:\n        Iterator[occwl.face.Face]: Face iterator\n    \"\"\"\n    from occwl.edge import Edge\n    from occwl.face import Face\n    assert isinstance(edge, Edge)\n    return map(Face, self._top_exp.faces_from_edge(edge.topods_shape()))\n</code></pre>"},{"location":"api/#occwl.solid.Solid.faces_from_vertex","title":"<code>faces_from_vertex(vertex)</code>","text":"<p>Get an iterator to go over the faces adjacent to a vertex</p> <p>Parameters:</p> Name Type Description Default <code>edge</code> <code>Vertex</code> <p>Input vertex</p> required <p>Returns:</p> Type Description <p>Iterator[occwl.face.Face]: Face iterator</p> Source code in <code>src/occwl/base.py</code> <pre><code>def faces_from_vertex(self, vertex):\n    \"\"\"\n    Get an iterator to go over the faces adjacent to a vertex\n\n    Args:\n        edge (occwl.vertex.Vertex): Input vertex\n\n    Returns:\n        Iterator[occwl.face.Face]: Face iterator\n    \"\"\"\n    from occwl.vertex import Vertex\n    from occwl.face import Face\n    assert isinstance(vertex, Vertex)\n    return map(Face, self._top_exp.faces_from_vertex(vertex.topods_shape()))\n</code></pre>"},{"location":"api/#occwl.solid.Solid.find_closest_edge_slow","title":"<code>find_closest_edge_slow(datum)</code>","text":"<p>Find the closest edge to the given datum point. The function is for testing only.  It will be slow  as it loops over all edges in the Shape. A quick way to find the closest entity is to call Shape.find_closest_point_data(), but then you may get a face, edge or vertex back.</p> <p>Parameters:</p> Name Type Description Default <code>datum</code> <code>ndarray or tuple</code> <p>3D datum point</p> required <p>Returns:</p> Name Type Description <code>Face</code> <p>The closest face in the Shape</p> Source code in <code>src/occwl/base.py</code> <pre><code>def find_closest_edge_slow(self, datum):\n    \"\"\"\n    Find the closest edge to the given datum point.\n    The function is for testing only.  It will be slow \n    as it loops over all edges in the Shape.\n    A quick way to find the closest entity is to call\n    Shape.find_closest_point_data(), but then you\n    may get a face, edge or vertex back.\n\n    Args:\n        datum (np.ndarray or tuple): 3D datum point\n\n    Returns:\n        Face: The closest face in the Shape\n    \"\"\"\n    return _find_closest_shape_in_list(self.edges(), datum)\n</code></pre>"},{"location":"api/#occwl.solid.Solid.find_closest_face_slow","title":"<code>find_closest_face_slow(datum)</code>","text":"<p>Find the closest face to the given datum point. The function is for testing only. It will be slow  as it loops over all faces in the Shape. A quick way to find the closest entity is to call Shape.find_closest_point_data(), but then you may get a face, edge or vertex back.</p> <p>Parameters:</p> Name Type Description Default <code>datum</code> <code>ndarray or tuple</code> <p>3D datum point</p> required <p>Returns:</p> Name Type Description <code>Face</code> <p>The closest face in the Shape</p> Source code in <code>src/occwl/base.py</code> <pre><code>def find_closest_face_slow(self, datum):\n    \"\"\"\n    Find the closest face to the given datum point.\n    The function is for testing only. It will be slow \n    as it loops over all faces in the Shape.\n    A quick way to find the closest entity is to call\n    Shape.find_closest_point_data(), but then you\n    may get a face, edge or vertex back.\n\n    Args:\n        datum (np.ndarray or tuple): 3D datum point\n\n    Returns:\n        Face: The closest face in the Shape\n    \"\"\"\n    return _find_closest_shape_in_list(self.faces(), datum)\n</code></pre>"},{"location":"api/#occwl.solid.Solid.find_closest_point_data","title":"<code>find_closest_point_data(datum)</code>","text":"<p>Find the information about the closest point on this shape</p> <p>Parameters:</p> Name Type Description Default <code>datum</code> <code>ndarray</code> <p>3D Point</p> required <p>Returns:</p> Name Type Description <code>ClosestPointData</code> <p>Data about the closest point on this shape</p> <code>None</code> <p>if error</p> Source code in <code>src/occwl/shape.py</code> <pre><code>def find_closest_point_data(self, datum):\n    \"\"\"\n    Find the information about the closest point on this shape\n\n    Args:\n        datum (np.ndarray): 3D Point\n\n    Returns:\n        ClosestPointData: Data about the closest point on this shape\n        None: if error\n    \"\"\"\n    # Folowing https://dev.opencascade.org/content/how-retrieve-nearest-face-shape-given-gppnt\n    # Create a vertex from the point\n    occ_point = geom_utils.numpy_to_gp(datum)\n    vertex_maker = BRepBuilderAPI_MakeVertex(occ_point)\n    vertex = vertex_maker.Shape()\n    dist_shape_shape = BRepExtrema_DistShapeShape(\n        vertex, self.topods_shape(), Extrema_ExtFlag_MIN\n    )\n    ok = dist_shape_shape.Perform()\n    if not ok:\n        return None\n\n    return ClosestPointData(dist_shape_shape)\n</code></pre>"},{"location":"api/#occwl.solid.Solid.get_triangles","title":"<code>get_triangles(triangle_face_tol=0.01, tol_relative_to_face=True, angle_tol_rads=0.1)</code>","text":"<p>Compute and get the tessellation of the entire shape</p> <p>Parameters:</p> Name Type Description Default <code>triangle_face_tol</code> <code>float</code> <p>Toelrance between triangle and surface. Defaults to 0.01.</p> <code>0.01</code> <code>tol_relative_to_face</code> <code>bool</code> <p>Whether tolerance is relative to face size</p> <code>True</code> <code>angle_tol_rads</code> <code>float</code> <p>Angle tolerance in radians. Defaults to 0.1.</p> <code>0.1</code> <p>Returns:</p> Type Description <p>2D np.ndarray (float): Vertices or None if triangulation failed</p> <p>2D np.ndarray (int): Faces or None if triangulation failed</p> Source code in <code>src/occwl/base.py</code> <pre><code>def get_triangles(\n    self,\n    triangle_face_tol=0.01,  # Tolerance between triangle and surface\n    tol_relative_to_face=True,  # The tolerance value is relative to the face size\n    angle_tol_rads=0.1,  # Angle between normals/tangents at triangle vertices\n):\n    \"\"\"\n    Compute and get the tessellation of the entire shape\n\n    Args:\n        triangle_face_tol (float, optional): Toelrance between triangle and surface. Defaults to 0.01.\n        tol_relative_to_face (bool): Whether tolerance is relative to face size\n        angle_tol_rads (float, optional): Angle tolerance in radians. Defaults to 0.1.\n\n    Returns:\n        2D np.ndarray (float): Vertices or None if triangulation failed\n        2D np.ndarray (int): Faces or None if triangulation failed\n    \"\"\"\n    ok = self.triangulate_all_faces(\n        triangle_face_tol, tol_relative_to_face, angle_tol_rads\n    )\n    if not ok:\n        # Failed to triangulate\n        return None, None\n    verts = []\n    tris = []\n    faces = self.faces()\n    last_vert_index = 0\n    for face in faces:\n        fverts, ftris = face.get_triangles()\n        verts.extend(fverts)\n        for tri in ftris:\n            new_indices = [index + last_vert_index for index in tri]\n            tris.append(new_indices)\n        last_vert_index = len(verts)\n    return np.asarray(verts, dtype=np.float32), np.asarray(tris, dtype=np.int32)\n</code></pre>"},{"location":"api/#occwl.solid.Solid.is_closed","title":"<code>is_closed()</code>","text":"<p>Checks and returns if the solid is closed (has no holes)</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>If closed</p> Source code in <code>src/occwl/solid.py</code> <pre><code>def is_closed(self):\n    \"\"\"\n    Checks and returns if the solid is closed (has no holes)\n\n    Returns:\n        bool: If closed\n    \"\"\"\n    # In Open Cascade, unlinked (open) edges can be identified\n    # as they appear in the edges iterator when ignore_orientation=False\n    # but are not present in any wire\n    ordered_edges = set()\n    for wire in self.wires():\n        for edge in wire.ordered_edges():\n            ordered_edges.add(edge.topods_shape())\n    unordered_edges = set([edge.topods_shape() for edge  in self.edges()])\n    missing_edges = unordered_edges - ordered_edges\n    return len(missing_edges) == 0\n</code></pre>"},{"location":"api/#occwl.solid.Solid.moment_of_inertia","title":"<code>moment_of_inertia(point, direction, tolerance=1e-09)</code>","text":"<p>Compute the moment of inertia about an axis</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>ndarray</code> <p>3D point (origin of the axis)</p> required <code>direction</code> <code>ndarray</code> <p>3D direction of the axis</p> required <code>tolerance</code> <code>float</code> <p>Tolerance. Defaults to 1e-9.</p> <code>1e-09</code> <p>Returns:</p> Name Type Description <code>float</code> <p>Moment of inertia</p> Source code in <code>src/occwl/base.py</code> <pre><code>def moment_of_inertia(self, point, direction, tolerance=1e-9):\n    \"\"\"\n    Compute the moment of inertia about an axis\n\n    Args:\n        point (np.ndarray): 3D point (origin of the axis)\n        direction (np.ndarray): 3D direction of the axis\n        tolerance (float, optional): Tolerance. Defaults to 1e-9.\n\n    Returns:\n        float: Moment of inertia\n    \"\"\"\n    from occwl.geometry import geom_utils\n    props = GProp_GProps()\n    brepgprop_VolumeProperties(self.topods_shape(), props, tolerance)\n    axis = gp_Ax1(\n        geom_utils.numpy_to_gp(point), geom_utils.numpy_to_gp_dir(direction)\n    )\n    return props.MomentOfInertia(axis)\n</code></pre>"},{"location":"api/#occwl.solid.Solid.num_edges","title":"<code>num_edges()</code>","text":"<p>Number of edges in the Shape</p> <p>Returns:</p> Name Type Description <code>int</code> <p>Number of edges</p> Source code in <code>src/occwl/base.py</code> <pre><code>def num_edges(self):\n    \"\"\"\n    Number of edges in the Shape\n\n    Returns:\n        int: Number of edges\n    \"\"\"\n    return self._top_exp.number_of_edges()\n</code></pre>"},{"location":"api/#occwl.solid.Solid.num_faces","title":"<code>num_faces()</code>","text":"<p>Number of faces in the Shape</p> <p>Returns:</p> Name Type Description <code>int</code> <p>Number of faces</p> Source code in <code>src/occwl/base.py</code> <pre><code>def num_faces(self):\n    \"\"\"\n    Number of faces in the Shape\n\n    Returns:\n        int: Number of faces\n    \"\"\"\n    return self._top_exp.number_of_faces()\n</code></pre>"},{"location":"api/#occwl.solid.Solid.num_shells","title":"<code>num_shells()</code>","text":"<p>Number of shells in the Shape</p> <p>Returns:</p> Name Type Description <code>int</code> <p>Number of shells</p> Source code in <code>src/occwl/base.py</code> <pre><code>def num_shells(self):\n    \"\"\"\n    Number of shells in the Shape\n\n    Returns:\n        int: Number of shells\n    \"\"\"\n    return self._top_exp.number_of_shells()\n</code></pre>"},{"location":"api/#occwl.solid.Solid.num_vertices","title":"<code>num_vertices()</code>","text":"<p>Number of vertices in the Shape</p> <p>Returns:</p> Name Type Description <code>int</code> <p>Number of vertices</p> Source code in <code>src/occwl/base.py</code> <pre><code>def num_vertices(self):\n    \"\"\"\n    Number of vertices in the Shape\n\n    Returns:\n        int: Number of vertices\n    \"\"\"\n    return self._top_exp.number_of_vertices()\n</code></pre>"},{"location":"api/#occwl.solid.Solid.num_wires","title":"<code>num_wires()</code>","text":"<p>Number of wires in the Shape</p> <p>Returns:</p> Name Type Description <code>int</code> <p>Number of wires</p> Source code in <code>src/occwl/base.py</code> <pre><code>def num_wires(self):\n    \"\"\"\n    Number of wires in the Shape\n\n    Returns:\n        int: Number of wires\n    \"\"\"\n    return self._top_exp.number_of_wires()\n</code></pre>"},{"location":"api/#occwl.solid.Solid.occwl_shape","title":"<code>occwl_shape(topods_shape)</code>  <code>staticmethod</code>","text":"<p>Static method to create an occwl shape of the appropriate  class from the given topods_shape Args:     topods_shape (OCC.Core.TopoDS.TopoDS_Vertex/Edge/Face/Wire/Shell/Solid): TopoDS shape</p> <p>Returns:</p> Type Description <p>One of occwl.compound.Compound occwl.solid.Solid occwl.face.Face occwl.edge.Edge occwl.vertex.Vertex occwl.wire.Wire occwl.shell.Shell</p> <p>Raises:     Exception: [description]</p> Source code in <code>src/occwl/shape.py</code> <pre><code>@staticmethod\ndef occwl_shape(topods_shape):\n    \"\"\"\n    Static method to create an occwl shape of the appropriate \n    class from the given topods_shape\n    Args:\n        topods_shape (OCC.Core.TopoDS.TopoDS_Vertex/Edge/Face/Wire/Shell/Solid): TopoDS shape\n\n    Returns:\n        One of\n            occwl.compound.Compound\n            occwl.solid.Solid\n            occwl.face.Face\n            occwl.edge.Edge\n            occwl.vertex.Vertex\n            occwl.wire.Wire\n            occwl.shell.Shell\n    Raises:\n        Exception: [description]\n    \"\"\"\n    from occwl.compound import Compound\n    from occwl.solid import Solid\n    from occwl.face import Face\n    from occwl.edge import Edge\n    from occwl.vertex import Vertex\n    from occwl.wire import Wire\n    from occwl.shell import Shell\n\n    if isinstance(topods_shape, TopoDS_Vertex):\n        return Vertex(topods_shape)\n    if isinstance(topods_shape, TopoDS_Edge):\n        return Edge(topods_shape)\n    if isinstance(topods_shape, TopoDS_Face):\n        return Face(topods_shape)\n    if isinstance(topods_shape, TopoDS_Wire):\n        return Wire(topods_shape)\n    if isinstance(topods_shape, TopoDS_Shell):\n        return Shell(topods_shape)\n    if isinstance(topods_shape, TopoDS_Solid):\n        return Solid(topods_shape)\n    if isinstance(topods_shape, (TopoDS_Compound, TopoDS_CompSolid)):\n        return Compound(topods_shape)\n    raise Exception(\n        \"Shape must be one of TopoDS_Vertex, TopoDS_Edge, TopoDS_Face, TopoDS_Shell, TopoDS_Solid, TopoDS_Compound, TopoDS_CompSolid\"\n    )\n</code></pre>"},{"location":"api/#occwl.solid.Solid.reversed","title":"<code>reversed()</code>","text":"<p>Whether this shape is reversed.</p> <ul> <li>For an edge this is whether the edge is reversed with respect to the curve geometry</li> <li>For a face this is whether the face is reversed with respect to the surface geometry</li> <li>For a vertex this is whether the vertex is at the upper or lower parameter value on the   edges curve</li> </ul> <p>Returns:</p> Name Type Description <code>bool</code> <p>If rational</p> Source code in <code>src/occwl/shape.py</code> <pre><code>def reversed(self):\n    \"\"\"\n    Whether this shape is reversed.\n\n    - For an edge this is whether the edge is reversed with respect to the curve geometry\n    - For a face this is whether the face is reversed with respect to the surface geometry\n    - For a vertex this is whether the vertex is at the upper or lower parameter value on the\n      edges curve\n\n    Returns:\n        bool: If rational\n    \"\"\"\n    return self.topods_shape().Orientation() == TopAbs_REVERSED\n</code></pre>"},{"location":"api/#occwl.solid.Solid.rotate_axis_angle","title":"<code>rotate_axis_angle(axis, angle_radians, origin=np.zeros(3, dtype=(np.float32)))</code>","text":"<p>Rotate the shape about the given axis by the given angle in radians</p> <p>Parameters:</p> Name Type Description Default <code>axis</code> <code>ndarray</code> <p>Rotation axis</p> required <code>angle_radians</code> <code>float</code> <p>Angle in radians</p> required Source code in <code>src/occwl/shape.py</code> <pre><code>def rotate_axis_angle(\n    self, axis, angle_radians, origin=np.zeros(3, dtype=np.float32)\n):\n    \"\"\"\n    Rotate the shape about the given axis by the given angle in radians\n\n    Args:\n        axis (np.ndarray): Rotation axis\n        angle_radians (float): Angle in radians\n    \"\"\"\n    self._shape = rotate_shape(\n        self._shape,\n        gp_Ax1(geom_utils.numpy_to_gp(origin), geom_utils.numpy_to_gp_dir(axis)),\n        angle_radians,\n        unite=\"rad\",\n    )\n</code></pre>"},{"location":"api/#occwl.solid.Solid.rotate_euler_angles","title":"<code>rotate_euler_angles(angles_xyz_radians)</code>","text":"<p>Rotate the shape by the given Euler angles in radians</p> <p>Parameters:</p> Name Type Description Default <code>angle_xyz_radians</code> <code>ndarray</code> <p>3D array with angles to rotate about x-axis, y-axis and z-axis respectively in radians</p> required Source code in <code>src/occwl/shape.py</code> <pre><code>def rotate_euler_angles(self, angles_xyz_radians):\n    \"\"\"\n    Rotate the shape by the given Euler angles in radians\n\n    Args:\n        angle_xyz_radians (np.ndarray): 3D array with angles to rotate about x-axis, y-axis and z-axis respectively in radians\n    \"\"\"\n    self._shape = rotate_shp_3_axis(\n        self._shape,\n        angles_xyz_radians[0],\n        angles_xyz_radians[1],\n        angles_xyz_radians[2],\n        unity=\"rad\",\n    )\n</code></pre>"},{"location":"api/#occwl.solid.Solid.save_shapes_to_occ_native","title":"<code>save_shapes_to_occ_native(filename, shapes, with_triangles=False, with_normals=False, format_version=None)</code>  <code>staticmethod</code>","text":"<p>Save this shape into a native OCC binary .brep file.</p> Saving to and loading from the native file format <p>is between one and two orders of magnitude faster  than loading from STEP, so it is recommended for  large scale data processing</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str or Path</code> <p>.brep filename</p> required <code>with_triangles</code> <code>bool</code> <p>Whether to save triangle data cached in the shape.</p> <code>False</code> <code>with_normals</code> <code>bool</code> <p>Whether to save vertex normals cached in the shape</p> <code>False</code> <code>format_version</code> <code>int</code> <p>Use None to save to the latest version 1 - first revision 2 - added storing of CurveOnSurface UV Points 3 - [OCCT 7.6] added storing of per-vertex normal information                and dropped storing of CurveOnSurface UV Points</p> <code>None</code> Source code in <code>src/occwl/shape.py</code> <pre><code>@staticmethod\ndef save_shapes_to_occ_native(\n        filename, \n        shapes,\n        with_triangles=False,\n        with_normals=False,\n        format_version=None\n    ):\n    \"\"\"\n    Save this shape into a native OCC binary .brep file.\n\n    Note:  Saving to and loading from the native file format \n            is between one and two orders of magnitude faster \n            than loading from STEP, so it is recommended for \n            large scale data processing\n\n    Args:\n        filename (str or pathlib.Path): .brep filename\n\n        with_triangles (bool): Whether to save triangle data cached in the shape.\n        with_normals (bool): Whether to save vertex normals cached in the shape\n        format_version (int):  Use None to save to the latest version\n            1 - first revision\n            2 - added storing of CurveOnSurface UV Points\n            3 - [OCCT 7.6] added storing of per-vertex normal information\n                           and dropped storing of CurveOnSurface UV Points\n    \"\"\"\n    new_api = False\n    shapes_set = BRepTools_ShapeSet(with_triangles)\n    # shapes_set.SetWithNormals(with_normals) # Not in OCC 7.5.0\n\n    for shp in shapes:\n        shapes_set.Add(shp.topods_shape())\n    if format_version is not None:\n        shapes_set.SetFormatNb(format_version)\n\n\n    with open(filename, \"w\") as fp:\n        s = shapes_set.WriteToString()\n        fp.write(s)\n</code></pre>"},{"location":"api/#occwl.solid.Solid.save_to_occ_native","title":"<code>save_to_occ_native(filename, verbosity=False, with_triangles=False, with_normals=False, format_version=None)</code>","text":"<p>Save this shape into a native OCC binary .brep file.</p> Saving to and loading from the native file format <p>is between one and two orders of magnitude faster  than loading from STEP, so it is recommended for  large scale data processing</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str or Path</code> <p>.brep filename</p> required <code>with_triangles</code> <code>bool</code> <p>Whether to save triangle data cached in the shape.</p> <code>False</code> <code>with_normals</code> <code>bool</code> <p>Whether to save vertex normals cached in the shape</p> <code>False</code> <code>format_version</code> <code>int</code> <p>Use None to save to the latest version 1 - first revision 2 - added storing of CurveOnSurface UV Points 3 - [OCCT 7.6] added storing of per-vertex normal information                and dropped storing of CurveOnSurface UV Points</p> <code>None</code> Source code in <code>src/occwl/shape.py</code> <pre><code>def save_to_occ_native(\n        self, \n        filename, \n        verbosity=False,\n        with_triangles=False,\n        with_normals=False,\n        format_version=None\n    ):\n    \"\"\"\n    Save this shape into a native OCC binary .brep file.\n\n    Note:  Saving to and loading from the native file format \n           is between one and two orders of magnitude faster \n           than loading from STEP, so it is recommended for \n           large scale data processing\n\n    Args:\n        filename (str or pathlib.Path): .brep filename\n        with_triangles (bool): Whether to save triangle data cached in the shape.\n        with_normals (bool): Whether to save vertex normals cached in the shape\n        format_version (int):  Use None to save to the latest version\n            1 - first revision\n            2 - added storing of CurveOnSurface UV Points\n            3 - [OCCT 7.6] added storing of per-vertex normal information\n                           and dropped storing of CurveOnSurface UV Points\n    \"\"\"\n    self.save_shapes_to_occ_native(\n        filename, \n        [ self ],\n        with_triangles=with_triangles,\n        with_normals=with_normals,\n        format_version=format_version\n    )\n</code></pre>"},{"location":"api/#occwl.solid.Solid.scale","title":"<code>scale(scale_vector)</code>","text":"<p>Scale the shape by the given 3D vector</p> <p>Parameters:</p> Name Type Description Default <code>scale_vector</code> <code>ndarray</code> <p>3D array with scales to resize the shape along the x-axis, y-axis and z-axis respectively</p> required Source code in <code>src/occwl/shape.py</code> <pre><code>def scale(self, scale_vector):\n    \"\"\"\n    Scale the shape by the given 3D vector\n\n    Args:\n        scale_vector (np.ndarray): 3D array with scales to resize the shape along the x-axis, y-axis and z-axis respectively\n    \"\"\"\n    self._shape = scale_shape(\n        self._shape, scale_vector[0], scale_vector[1], scale_vector[2]\n    )\n</code></pre>"},{"location":"api/#occwl.solid.Solid.scale_to_box","title":"<code>scale_to_box(box_side, copy=True)</code>","text":"<p>Translate and scale the Shape so it fits exactly  into the [-box_side, box_side]^3 box</p> <p>Returns:</p> Type Description <p>occwl..: The scaled version of this Shape</p> Source code in <code>src/occwl/base.py</code> <pre><code>def scale_to_box(self, box_side, copy=True):\n    \"\"\"\n    Translate and scale the Shape so it fits exactly \n    into the [-box_side, box_side]^3 box\n\n    Args:\n        box_side (float) The side length of the box\n        copy (bool)      True - Copy entities and apply the transform to\n                                the underlying geometry\n                         False - Apply the transform to the topods Locator\n                                 if possible \n\n    Returns:\n        occwl.*.*: The scaled version of this Shape\n    \"\"\"\n    from occwl.geometry import geom_utils\n    # Get an exact box for the Shape\n    box = self.exact_box()\n    center = box.center()\n    longest_length = box.max_box_length()\n\n    orig = gp_Pnt(0.0, 0.0, 0.0)\n    center = geom_utils.numpy_to_gp(center)\n    vec_center_to_orig = gp_Vec(center, orig)\n    move_to_center = gp_Trsf()\n    move_to_center.SetTranslation(vec_center_to_orig)\n\n    scale_trsf = gp_Trsf()\n    scale_trsf.SetScale(orig, (2.0 * box_side) / longest_length)\n    trsf_to_apply = scale_trsf.Multiplied(move_to_center)\n\n    return self._apply_transform(trsf_to_apply, copy=copy)\n</code></pre>"},{"location":"api/#occwl.solid.Solid.scale_to_unit_box","title":"<code>scale_to_unit_box(copy=True)</code>","text":"<p>Translate and scale the Shape so it fits exactly  into the [-1, 1]^3 box</p> <p>Returns:     The scaled version of this shape</p> Source code in <code>src/occwl/base.py</code> <pre><code>def scale_to_unit_box(self, copy=True):\n    \"\"\"\n    Translate and scale the Shape so it fits exactly \n    into the [-1, 1]^3 box\n\n    Args:\n        copy (bool)      True - Copy entities and apply the transform to\n                                    the underlying geometry\n                            False - Apply the transform to the topods Locator\n                                    if possible \n    Returns:\n        The scaled version of this shape\n    \"\"\"\n    return self.scale_to_box(1.0, copy=copy)\n</code></pre>"},{"location":"api/#occwl.solid.Solid.set_transform_to_identity","title":"<code>set_transform_to_identity()</code>","text":"<p>When an assembly is loaded from a STEP file the solids will be transformed relative to their local coordinate system.   i.e. they are placed in the assembly root components  coordinate system.</p> <p>When working with individual bodies you often want them to be axis aligned, in which case  you want to remove the assembly transform. This function removes it for you.</p> <p>If however you want to bake the transform into the bodies and suppress the asserts  from parts of occwl which don't cope with transforms then use the transform() function below with copy=True</p> Source code in <code>src/occwl/shape.py</code> <pre><code>def set_transform_to_identity(self):\n    \"\"\"\n    When an assembly is loaded from a STEP file\n    the solids will be transformed relative to\n    their local coordinate system.   i.e. they\n    are placed in the assembly root components \n    coordinate system.\n\n    When working with individual bodies you often\n    want them to be axis aligned, in which case \n    you want to remove the assembly transform.\n    This function removes it for you.\n\n    If however you want to bake the transform\n    into the bodies and suppress the asserts \n    from parts of occwl which don't cope with\n    transforms then use the transform() function\n    below with copy=True\n    \"\"\"\n    identity = TopLoc_Location()\n    self.topods_shape().Location(identity)\n    self._top_exp = TopologyUtils.TopologyExplorer(self.topods_shape(), True)\n    self.convert_geometric_identity_transforms_to_identity()\n</code></pre>"},{"location":"api/#occwl.solid.Solid.shells","title":"<code>shells()</code>","text":"<p>Get an iterator to go over all shells in the Shape</p> <p>Returns:</p> Type Description <p>Iterator[occwl.shell.Shell]: Shell iterator</p> Source code in <code>src/occwl/base.py</code> <pre><code>def shells(self):\n    \"\"\"\n    Get an iterator to go over all shells in the Shape\n\n    Returns:\n        Iterator[occwl.shell.Shell]: Shell iterator\n    \"\"\"\n    from occwl.shell import Shell\n    return map(Shell, self._top_exp.shells())\n</code></pre>"},{"location":"api/#occwl.solid.Solid.split_all_closed_edges","title":"<code>split_all_closed_edges(max_tol=0.01, precision=0.01, num_splits=1)</code>","text":"<p>Split all the closed edges in this shape</p> <p>Parameters:</p> Name Type Description Default <code>max_tol</code> <code>float</code> <p>Maximum tolerance allowed. Defaults to 0.01.</p> <code>0.01</code> <code>precision</code> <code>float</code> <p>Precision of the tool when splitting. Defaults to 0.01.</p> <code>0.01</code> <code>num_splits</code> <code>int</code> <p>Number of splits to perform. Each split edge will result in num_splits + 1 edges. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Type Description <p>occwl..: Shape with closed edges split</p> Source code in <code>src/occwl/base.py</code> <pre><code>def split_all_closed_edges(self, max_tol=0.01, precision=0.01, num_splits=1):\n    \"\"\"\n    Split all the closed edges in this shape\n\n    Args:\n        max_tol (float, optional): Maximum tolerance allowed. Defaults to 0.01.\n        precision (float, optional): Precision of the tool when splitting. Defaults to 0.01.\n        num_splits (int, optional): Number of splits to perform. Each split edge will result in num_splits + 1 edges. Defaults to 1.\n\n    Returns:\n        occwl.*.*: Shape with closed edges split\n    \"\"\"\n    divider = ShapeUpgrade_ShapeDivideClosedEdges(self.topods_shape())\n    divider.SetPrecision(precision)\n    divider.SetMinTolerance(0.1 * max_tol)\n    divider.SetMaxTolerance(max_tol)\n    divider.SetNbSplitPoints(num_splits)\n    ok = divider.Perform()\n    if not ok:\n        # Splitting failed or there were no closed edges to split\n        # Return the original shape\n        return self\n    return type(self)(divider.Result())\n</code></pre>"},{"location":"api/#occwl.solid.Solid.split_all_closed_faces","title":"<code>split_all_closed_faces(max_tol=0.01, precision=0.01, num_splits=1)</code>","text":"<p>Split all the closed faces in this shape</p> <p>Parameters:</p> Name Type Description Default <code>max_tol</code> <code>float</code> <p>Maximum tolerance allowed. Defaults to 0.01.</p> <code>0.01</code> <code>precision</code> <code>float</code> <p>Precision of the tool when splitting. Defaults to 0.01.</p> <code>0.01</code> <code>num_splits</code> <code>int</code> <p>Number of splits to perform. Each split face will result in num_splits + 1 faces. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Type Description <p>occwl..: Shape with closed faces split</p> Source code in <code>src/occwl/base.py</code> <pre><code>def split_all_closed_faces(self, max_tol=0.01, precision=0.01, num_splits=1):\n    \"\"\"\n    Split all the closed faces in this shape\n\n    Args:\n        max_tol (float, optional): Maximum tolerance allowed. Defaults to 0.01.\n        precision (float, optional): Precision of the tool when splitting. Defaults to 0.01.\n        num_splits (int, optional): Number of splits to perform. Each split face will result in num_splits + 1 faces. Defaults to 1.\n\n    Returns:\n        occwl.*.*: Shape with closed faces split\n    \"\"\"\n    divider = ShapeUpgrade_ShapeDivideClosed(self.topods_shape())\n    divider.SetPrecision(precision)\n    divider.SetMinTolerance(0.1 * max_tol)\n    divider.SetMaxTolerance(max_tol)\n    divider.SetNbSplitPoints(num_splits)\n    ok = divider.Perform()\n    if not ok:\n        # Splitting failed or there were no closed faces to split\n        # Return the original shape\n        return self\n    return type(self)(divider.Result())\n</code></pre>"},{"location":"api/#occwl.solid.Solid.topods_shape","title":"<code>topods_shape()</code>","text":"<p>Get the underlying OCC shape</p> <p>Returns:</p> Type Description <p>OCC.Core.TopoDS.TopoDS_Vertex/Edge/Face/Wire/Shell/Solid: OCC TopoDS_*</p> Source code in <code>src/occwl/shape.py</code> <pre><code>def topods_shape(self):\n    \"\"\"\n    Get the underlying OCC shape\n\n    Returns:\n        OCC.Core.TopoDS.TopoDS_Vertex/Edge/Face/Wire/Shell/Solid: OCC TopoDS_*\n    \"\"\"\n    return self._shape\n</code></pre>"},{"location":"api/#occwl.solid.Solid.transform","title":"<code>transform(a, copy=True)</code>","text":"<p>Apply the given 3x4 transform matrix to the solid.</p> <pre><code> copy (bool)    True - Copy entities and apply the transform to\n                       the underlying geometry\n                False - Apply the transform to the topods Locator\n                        if possible\n</code></pre> Source code in <code>src/occwl/shape.py</code> <pre><code>def transform(self, a: np.ndarray, copy=True):\n    \"\"\"\n    Apply the given 3x4 transform matrix to the solid.\n\n    Args: a (nd.array) - Homogeneous transform matrix\n                         The transform that will be applied is\n\n                         x' =  a[0,0]*x + a[0,1]*y + a[0,2]*z + a[0, 3]\n                         y' =  a[1,0]*x + a[1,1]*y + a[1,2]*z + a[1, 3]\n                         z' =  a[2,0]*x + a[2,1]*y + a[2,2]*z + a[2, 3]\n\n         copy (bool)    True - Copy entities and apply the transform to\n                               the underlying geometry\n                        False - Apply the transform to the topods Locator\n                                if possible \n    \"\"\"\n    assert (a.shape == (3, 4)), \"Transform matrix must be 3x4\"\n    a = a.astype(np.float64)\n\n    # Create an identity transform\n    trsf = gp_Trsf()\n\n    # If the matrix is an identity matrix then\n    # we don't want to set the values as this\n    # would give us a geometric identity without\n    # the identity flag set\n    if not np.allclose(a, np.eye(3, 4)):\n        trsf.SetValues(\n            a[0,0], a[0,1], a[0,2], a[0, 3],\n            a[1,0], a[1,1], a[1,2], a[1, 3],\n            a[2,0], a[2,1], a[2,2], a[2, 3]\n        )\n    return self._apply_transform(trsf, copy=copy)\n</code></pre>"},{"location":"api/#occwl.solid.Solid.translate","title":"<code>translate(offset)</code>","text":"<p>Translate the shape by an offset vector</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>ndarray</code> <p>Offset vector</p> required Source code in <code>src/occwl/shape.py</code> <pre><code>def translate(self, offset):\n    \"\"\"\n    Translate the shape by an offset vector\n\n    Args:\n        offset (np.ndarray): Offset vector\n    \"\"\"\n    self._shape = translate_shp(self._shape, geom_utils.numpy_to_gp_vec(offset))\n</code></pre>"},{"location":"api/#occwl.solid.Solid.triangulate","title":"<code>triangulate(triangle_face_tol=0.01, tol_relative_to_face=True, angle_tol_rads=0.1)</code>","text":"<p>Triangulate all the faces in the shape. You can then get the triangles  from each face separately using face.get_triangles(). If you wanted triangles for the entire shape then call shape.get_triangles() below. For more details see  https://old.opencascade.com/doc/occt-7.1.0/overview/html/occt_user_guides__modeling_algos.html#occt_modalg_11</p> <p>Parameters:</p> Name Type Description Default <code>triangle_face_tol</code> <code>float</code> <p>Tolerance between triangle and surface. Defaults to 0.01.</p> <code>0.01</code> <code>tol_relative_to_face</code> <code>bool</code> <p>Whether tolerance is relative to face size</p> <code>True</code> <code>angle_tol_rads</code> <code>float</code> <p>Angle tolerance in radians. Defaults to 0.1.</p> <code>0.1</code> <p>Returns:</p> Name Type Description <code>bool</code> <p>Is successful</p> Source code in <code>src/occwl/base.py</code> <pre><code>def triangulate(\n    self,\n    triangle_face_tol=0.01,  # Tolerance between triangle and surface\n    tol_relative_to_face=True,  # The tolerance value is relative to the face size\n    angle_tol_rads=0.1,  # Angle between normals/tangents at triangle vertices\n):\n    \"\"\"\n    Triangulate all the faces in the shape. You can then get the triangles \n    from each face separately using face.get_triangles().\n    If you wanted triangles for the entire shape then call\n    shape.get_triangles() below.\n    For more details see \n    https://old.opencascade.com/doc/occt-7.1.0/overview/html/occt_user_guides__modeling_algos.html#occt_modalg_11\n\n    Args:\n        triangle_face_tol (float, optional): Tolerance between triangle and surface. Defaults to 0.01.\n        tol_relative_to_face (bool): Whether tolerance is relative to face size\n        angle_tol_rads (float, optional): Angle tolerance in radians. Defaults to 0.1.\n\n    Returns:\n        bool: Is successful\n    \"\"\"\n    mesh = BRepMesh_IncrementalMesh(\n        self.topods_shape(),\n        triangle_face_tol,\n        tol_relative_to_face,\n        angle_tol_rads,\n        True,\n    )\n    mesh.Perform()\n    return mesh.IsDone()\n</code></pre>"},{"location":"api/#occwl.solid.Solid.valid","title":"<code>valid(return_analyzer=False)</code>","text":"<p>Check if the shape is valid</p> <p>Parameters:</p> Name Type Description Default <code>return_analyzer</code> <code>bool</code> <p>Whether to return the BRepCheck_Analyzer object for more inspection</p> <code>False</code> <p>Returns:</p> Name Type Description <code>bool</code> <p>Whether the shape is valid</p> <p>BRepCheck_Analyzer [optional]: if return_analyzer is True</p> Source code in <code>src/occwl/shape.py</code> <pre><code>def valid(self, return_analyzer=False):\n    \"\"\"\n    Check if the shape is valid\n\n    Args:\n        return_analyzer (bool): Whether to return the BRepCheck_Analyzer object for more inspection\n\n    Returns:\n        bool: Whether the shape is valid\n        BRepCheck_Analyzer [optional]: if return_analyzer is True\n    \"\"\"\n    analyzer = BRepCheck_Analyzer(self.topods_shape())\n    if return_analyzer:\n        return analyzer.IsValid(), analyzer\n    return analyzer.IsValid()\n</code></pre>"},{"location":"api/#occwl.solid.Solid.vertices","title":"<code>vertices()</code>","text":"<p>Get an iterator to go over all vertices in the Shape</p> <p>Returns:</p> Type Description <p>Iterator[occwl.vertex.Vertex]: Vertex iterator</p> Source code in <code>src/occwl/base.py</code> <pre><code>def vertices(self):\n    \"\"\"\n    Get an iterator to go over all vertices in the Shape\n\n    Returns:\n        Iterator[occwl.vertex.Vertex]: Vertex iterator\n    \"\"\"\n    from occwl.vertex import Vertex\n    return map(Vertex, self._top_exp.vertices())\n</code></pre>"},{"location":"api/#occwl.solid.Solid.vertices_from_edge","title":"<code>vertices_from_edge(edge)</code>","text":"<p>Get an iterator to go over the vertices bounding an edge</p> <p>Parameters:</p> Name Type Description Default <code>edge</code> <code>Edge</code> <p>Input edge</p> required <p>Returns:</p> Type Description <p>Iterator[occwl.vertex.Vertex]: Vertex iterator</p> Source code in <code>src/occwl/base.py</code> <pre><code>def vertices_from_edge(self, edge):\n    \"\"\"\n    Get an iterator to go over the vertices bounding an edge\n\n    Args:\n        edge (occwl.edge.Edge): Input edge\n\n    Returns:\n        Iterator[occwl.vertex.Vertex]: Vertex iterator\n    \"\"\"\n    from occwl.vertex import Vertex\n    from occwl.edge import Edge\n    assert isinstance(edge, Edge)\n    return map(Vertex, self._top_exp.vertices_from_edge(edge.topods_shape()))\n</code></pre>"},{"location":"api/#occwl.solid.Solid.vertices_from_face","title":"<code>vertices_from_face(face)</code>","text":"<p>Get an iterator to go over the vertices in a face</p> <p>Parameters:</p> Name Type Description Default <code>face</code> <code>Face</code> <p>Input face</p> required <p>Returns:</p> Type Description <p>Iterator[occwl.vertex.Vertex]: Vertex iterator</p> Source code in <code>src/occwl/base.py</code> <pre><code>def vertices_from_face(self, face):\n    \"\"\"\n    Get an iterator to go over the vertices in a face\n\n    Args:\n        face (occwl.face.Face): Input face\n\n    Returns:\n        Iterator[occwl.vertex.Vertex]: Vertex iterator\n    \"\"\"\n    from occwl.vertex import Vertex\n    from occwl.face import Face\n    assert isinstance(face, Face)\n    return map(Vertex, self._top_exp.vertices_from_face(face.topods_shape()))\n</code></pre>"},{"location":"api/#occwl.solid.Solid.volume","title":"<code>volume(tolerance=1e-09)</code>","text":"<p>Compute the volume of the Shape</p> <p>Parameters:</p> Name Type Description Default <code>tolerance</code> <code>float</code> <p>Tolerance. Defaults to 1e-9.</p> <code>1e-09</code> <p>Returns:</p> Name Type Description <code>float</code> <p>Volume</p> Source code in <code>src/occwl/base.py</code> <pre><code>def volume(self, tolerance=1e-9):\n    \"\"\"\n    Compute the volume of the Shape\n\n    Args:\n        tolerance (float, optional): Tolerance. Defaults to 1e-9.\n\n    Returns:\n        float: Volume\n    \"\"\"\n    props = GProp_GProps()\n    brepgprop_VolumeProperties(self.topods_shape(), props, tolerance)\n    return props.Mass()\n</code></pre>"},{"location":"api/#occwl.solid.Solid.wires","title":"<code>wires()</code>","text":"<p>Get an iterator to go over all wires in the Shape</p> <p>Returns:</p> Type Description <p>Iterator[occwl.wire.Wire]: Wire iterator</p> Source code in <code>src/occwl/base.py</code> <pre><code>def wires(self):\n    \"\"\"\n    Get an iterator to go over all wires in the Shape\n\n    Returns:\n        Iterator[occwl.wire.Wire]: Wire iterator\n    \"\"\"\n    from occwl.wire import Wire\n    return map(Wire, self._top_exp.wires())\n</code></pre>"},{"location":"api/#occwl.solid.Solid.wires_from_face","title":"<code>wires_from_face(face)</code>","text":"<p>Get an iterator to go over the wires bounding a face</p> <p>Parameters:</p> Name Type Description Default <code>face</code> <code>Face</code> <p>Input face</p> required <p>Returns:</p> Type Description <p>Iterator[occwl.wire.Wire]: Wire iterator</p> Source code in <code>src/occwl/base.py</code> <pre><code>def wires_from_face(self, face):\n    \"\"\"\n    Get an iterator to go over the wires bounding a face\n\n    Args:\n        face (occwl.face.Face): Input face\n\n    Returns:\n        Iterator[occwl.wire.Wire]: Wire iterator\n    \"\"\"\n    from occwl.wire import Wire\n    from occwl.face import Face\n    assert isinstance(face, Face)\n    return map(Wire, self._top_exp.wires_from_face(face.topods_shape()))\n</code></pre>"},{"location":"api/#occwl.uvgrid","title":"<code>uvgrid</code>","text":""},{"location":"api/#occwl.uvgrid.ugrid","title":"<code>ugrid(edge, num_u=10, us=False, method='point', reverse_order_with_edge=True)</code>","text":"<p>Creates a 1D UV-grid of samples from the given edge     edge (occwl.edge.Edge): A B-rep edge     num_u (int): Number of samples along the curve. Defaults to 10/     us (bool): Return the u values at which the quantity were evaluated     method (str): Name of the method in the occwl.edge.Edge object to be called                    (the method has to accept the u value as argument). Defaults to \"point\". Returns:     np.ndarray: 1D array of quantity evaluated on the edge geometry     np.ndarray (optional): 1D array of u-values where evaluation was done</p> Source code in <code>src/occwl/uvgrid.py</code> <pre><code>def ugrid(edge, num_u: int = 10, us=False, method=\"point\", reverse_order_with_edge=True):\n    \"\"\" \n    Creates a 1D UV-grid of samples from the given edge\n        edge (occwl.edge.Edge): A B-rep edge\n        num_u (int): Number of samples along the curve. Defaults to 10/\n        us (bool): Return the u values at which the quantity were evaluated\n        method (str): Name of the method in the occwl.edge.Edge object to be called \n                      (the method has to accept the u value as argument). Defaults to \"point\".\n    Returns:\n        np.ndarray: 1D array of quantity evaluated on the edge geometry\n        np.ndarray (optional): 1D array of u-values where evaluation was done\n    \"\"\"\n    assert num_u &gt;= 2\n    ugrid = []\n    u_values = np.zeros((num_u), dtype=np.float32)\n\n    if type(edge.curve()) is float:\n        # Can't get an curve for this edge.\n        if us:\n            return None, u_values\n        return None\n\n    bound = edge.u_bounds()\n    fn = getattr(edge, method)\n\n    for i in range(num_u):\n        u = bound.interpolate(float(i) / (num_u - 1))\n        u_values[i] = u\n        val = fn(u)\n        ugrid.append(val)\n\n    ugrid = np.asarray(ugrid).reshape((num_u, -1))\n    if reverse_order_with_edge:\n        if edge.reversed():\n            ugrid = _ugrid_reverse_u(ugrid)\n            u_values = u_values[::-1]\n    if us:\n        return ugrid, u_values\n    return ugrid\n</code></pre>"},{"location":"api/#occwl.uvgrid.uvgrid","title":"<code>uvgrid(face, num_u=10, num_v=10, uvs=False, method='point', reverse_order_with_face=True)</code>","text":"<p>Creates a 2D UV-grid of samples from the given face</p> <p>Parameters:</p> Name Type Description Default <code>face</code> <code>Face</code> <p>A B-rep face</p> required <code>num_u</code> <code>int</code> <p>Number of samples along u-direction. Defaults to 10.</p> <code>10</code> <code>num_v</code> <code>int</code> <p>Number of samples along v-direction. Defaults to 10.</p> <code>10</code> <code>uvs</code> <code>bool</code> <p>Return the surface UVs where quantities are evaluated. Defaults to False.</p> <code>False</code> <code>method</code> <code>str</code> <p>Name of the method in the occwl.face.Face object to be called            (the method has to accept the uv value as argument). Defaults to \"point\".</p> <code>'point'</code> <p>Returns:</p> Type Description <p>np.ndarray: 2D array of quantity evaluated on the face geometry</p> <p>np.ndarray (optional): 2D array of uv-values where evaluation was done</p> Source code in <code>src/occwl/uvgrid.py</code> <pre><code>def uvgrid(face, num_u=10, num_v=10, uvs=False, method=\"point\", reverse_order_with_face=True):\n    \"\"\" \n    Creates a 2D UV-grid of samples from the given face\n\n    Args:\n        face (occwl.face.Face): A B-rep face\n        num_u (int): Number of samples along u-direction. Defaults to 10.\n        num_v (int): Number of samples along v-direction. Defaults to 10.\n        uvs (bool): Return the surface UVs where quantities are evaluated. Defaults to False.\n        method (str): Name of the method in the occwl.face.Face object to be called \n                      (the method has to accept the uv value as argument). Defaults to \"point\".\n\n    Returns:\n        np.ndarray: 2D array of quantity evaluated on the face geometry\n        np.ndarray (optional): 2D array of uv-values where evaluation was done\n    \"\"\"\n    assert num_u &gt;= 2\n    assert num_v &gt;= 2\n    uv_box = face.uv_bounds()\n\n    fn = getattr(face, method)\n\n    uvgrid = []\n    uv_values = np.zeros((num_u, num_v, 2), dtype=np.float32)\n\n    if type(face.surface()) is float:\n        # Can't get an curve for this face.\n        if uvs:\n            return None, uv_values\n        return None\n\n    for i in range(num_u):\n        u = uv_box.intervals[0].interpolate(float(i) / (num_u - 1))\n        for j in range(num_v):\n            v = uv_box.intervals[1].interpolate(float(j) / (num_v - 1))\n            uv = np.array([u, v])\n            uv_values[i, j] = uv\n            val = fn(uv)\n            uvgrid.append(val)\n    uvgrid = np.asarray(uvgrid).reshape((num_u, num_v, -1))\n\n    if reverse_order_with_face:\n        if face.reversed():\n            uvgrid = _uvgrid_reverse_u(uvgrid)\n            uv_values = _uvgrid_reverse_u(uv_values)\n\n    if uvs:\n        return uvgrid, uv_values\n    return uvgrid\n</code></pre>"},{"location":"api/#occwl.vertex","title":"<code>vertex</code>","text":""},{"location":"api/#occwl.vertex.Vertex","title":"<code>Vertex</code>","text":"<p>               Bases: <code>Shape</code></p> <p>A topological vertex in a solid model Represents a 3D geometric point</p> Source code in <code>src/occwl/vertex.py</code> <pre><code>class Vertex(Shape):\n    \"\"\"\n    A topological vertex in a solid model\n    Represents a 3D geometric point\n    \"\"\"\n\n    def __init__(self, topods_vertex):\n        \"\"\"\n        Constructor to initialize a vertex from a TodoDS_Vertex\n\n        Args:\n            topods_vertex (OCC.Core.TopoDS.TopoDS_Vertex): OCC Vertex\n        \"\"\"\n        assert isinstance(topods_vertex, TopoDS_Vertex)\n        super().__init__(topods_vertex)\n\n    @staticmethod\n    def make_vertex(point):\n        \"\"\"\n        Create a vertex from a 3D point\n\n        Args:\n            point (np.ndarray): 3D Point\n\n        Returns:\n            occwl.Vertex: Vertex representing the 3D point\n        \"\"\"\n        occ_point = geom_utils.numpy_to_gp(point)\n        vertex_maker = BRepBuilderAPI_MakeVertex(occ_point)\n        vertex = vertex_maker.Shape()\n        return Vertex(vertex)\n\n    def point(self):\n        \"\"\"\n        3D point stored in this vertex\n\n        Returns:\n            np.ndarray: 3D Point\n        \"\"\"\n        pt = BRep_Tool.Pnt(self.topods_shape())\n        return geom_utils.gp_to_numpy(pt)\n</code></pre>"},{"location":"api/#occwl.vertex.Vertex.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Equality check for the shape</p> <p>NOTE: This function only checks if the shape is the same. It doesn't check the edge orienation for example, so </p> <p>edge1 == edge2</p> <p>does not necessarily mean </p> <p>edge1.reversed() == edge2.reversed()</p> Source code in <code>src/occwl/shape.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"\n    Equality check for the shape\n\n    NOTE: This function only checks if the shape is the same.\n    It doesn't check the edge orienation for example, so \n\n    edge1 == edge2\n\n    does not necessarily mean \n\n    edge1.reversed() == edge2.reversed()\n    \"\"\"\n    return self.topods_shape().__hash__() == other.topods_shape().__hash__()\n</code></pre>"},{"location":"api/#occwl.vertex.Vertex.__hash__","title":"<code>__hash__()</code>","text":"<p>Hash for the shape</p> <p>Returns:</p> Name Type Description <code>int</code> <p>Hash value</p> Source code in <code>src/occwl/shape.py</code> <pre><code>def __hash__(self):\n    \"\"\"\n    Hash for the shape\n\n    Returns:\n        int: Hash value\n    \"\"\"\n    return self.topods_shape().__hash__()\n</code></pre>"},{"location":"api/#occwl.vertex.Vertex.__init__","title":"<code>__init__(topods_vertex)</code>","text":"<p>Constructor to initialize a vertex from a TodoDS_Vertex</p> <p>Parameters:</p> Name Type Description Default <code>topods_vertex</code> <code>TopoDS_Vertex</code> <p>OCC Vertex</p> required Source code in <code>src/occwl/vertex.py</code> <pre><code>def __init__(self, topods_vertex):\n    \"\"\"\n    Constructor to initialize a vertex from a TodoDS_Vertex\n\n    Args:\n        topods_vertex (OCC.Core.TopoDS.TopoDS_Vertex): OCC Vertex\n    \"\"\"\n    assert isinstance(topods_vertex, TopoDS_Vertex)\n    super().__init__(topods_vertex)\n</code></pre>"},{"location":"api/#occwl.vertex.Vertex.convert_geometric_identity_transforms_to_identity","title":"<code>convert_geometric_identity_transforms_to_identity()</code>","text":"<p>Open Cascade models sometimes contain transforms which are \"geometrically\" identify transforms, but the identity flag is not set.</p> <p>This function checks each transform and sets the flag if  the appropriate.</p> Source code in <code>src/occwl/shape.py</code> <pre><code>def convert_geometric_identity_transforms_to_identity(self):\n    \"\"\"\n    Open Cascade models sometimes contain transforms which\n    are \"geometrically\" identify transforms, but the identity\n    flag is not set.\n\n    This function checks each transform and sets the flag if \n    the appropriate.\n    \"\"\"\n    identity = TopLoc_Location()\n    if geom_utils.is_geometric_identity(\n        self.topods_shape().Location().Transformation()\n    ):\n        self.topods_shape().Location(identity)\n        self._top_exp = TopologyUtils.TopologyExplorer(self.topods_shape(), True)\n\n    for face in self._top_exp.faces():\n        if geom_utils.is_geometric_identity(face.Location().Transformation()):\n            face.Location(identity)\n\n    for edge in self._top_exp.edges():\n        if geom_utils.is_geometric_identity(edge.Location().Transformation()):\n            edge.Location(identity)\n\n    for vertex in self._top_exp.vertices():\n        if geom_utils.is_geometric_identity(vertex.Location().Transformation()):\n            vertex.Location(identity)\n</code></pre>"},{"location":"api/#occwl.vertex.Vertex.find_closest_point_data","title":"<code>find_closest_point_data(datum)</code>","text":"<p>Find the information about the closest point on this shape</p> <p>Parameters:</p> Name Type Description Default <code>datum</code> <code>ndarray</code> <p>3D Point</p> required <p>Returns:</p> Name Type Description <code>ClosestPointData</code> <p>Data about the closest point on this shape</p> <code>None</code> <p>if error</p> Source code in <code>src/occwl/shape.py</code> <pre><code>def find_closest_point_data(self, datum):\n    \"\"\"\n    Find the information about the closest point on this shape\n\n    Args:\n        datum (np.ndarray): 3D Point\n\n    Returns:\n        ClosestPointData: Data about the closest point on this shape\n        None: if error\n    \"\"\"\n    # Folowing https://dev.opencascade.org/content/how-retrieve-nearest-face-shape-given-gppnt\n    # Create a vertex from the point\n    occ_point = geom_utils.numpy_to_gp(datum)\n    vertex_maker = BRepBuilderAPI_MakeVertex(occ_point)\n    vertex = vertex_maker.Shape()\n    dist_shape_shape = BRepExtrema_DistShapeShape(\n        vertex, self.topods_shape(), Extrema_ExtFlag_MIN\n    )\n    ok = dist_shape_shape.Perform()\n    if not ok:\n        return None\n\n    return ClosestPointData(dist_shape_shape)\n</code></pre>"},{"location":"api/#occwl.vertex.Vertex.make_vertex","title":"<code>make_vertex(point)</code>  <code>staticmethod</code>","text":"<p>Create a vertex from a 3D point</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>ndarray</code> <p>3D Point</p> required <p>Returns:</p> Type Description <p>occwl.Vertex: Vertex representing the 3D point</p> Source code in <code>src/occwl/vertex.py</code> <pre><code>@staticmethod\ndef make_vertex(point):\n    \"\"\"\n    Create a vertex from a 3D point\n\n    Args:\n        point (np.ndarray): 3D Point\n\n    Returns:\n        occwl.Vertex: Vertex representing the 3D point\n    \"\"\"\n    occ_point = geom_utils.numpy_to_gp(point)\n    vertex_maker = BRepBuilderAPI_MakeVertex(occ_point)\n    vertex = vertex_maker.Shape()\n    return Vertex(vertex)\n</code></pre>"},{"location":"api/#occwl.vertex.Vertex.occwl_shape","title":"<code>occwl_shape(topods_shape)</code>  <code>staticmethod</code>","text":"<p>Static method to create an occwl shape of the appropriate  class from the given topods_shape Args:     topods_shape (OCC.Core.TopoDS.TopoDS_Vertex/Edge/Face/Wire/Shell/Solid): TopoDS shape</p> <p>Returns:</p> Type Description <p>One of occwl.compound.Compound occwl.solid.Solid occwl.face.Face occwl.edge.Edge occwl.vertex.Vertex occwl.wire.Wire occwl.shell.Shell</p> <p>Raises:     Exception: [description]</p> Source code in <code>src/occwl/shape.py</code> <pre><code>@staticmethod\ndef occwl_shape(topods_shape):\n    \"\"\"\n    Static method to create an occwl shape of the appropriate \n    class from the given topods_shape\n    Args:\n        topods_shape (OCC.Core.TopoDS.TopoDS_Vertex/Edge/Face/Wire/Shell/Solid): TopoDS shape\n\n    Returns:\n        One of\n            occwl.compound.Compound\n            occwl.solid.Solid\n            occwl.face.Face\n            occwl.edge.Edge\n            occwl.vertex.Vertex\n            occwl.wire.Wire\n            occwl.shell.Shell\n    Raises:\n        Exception: [description]\n    \"\"\"\n    from occwl.compound import Compound\n    from occwl.solid import Solid\n    from occwl.face import Face\n    from occwl.edge import Edge\n    from occwl.vertex import Vertex\n    from occwl.wire import Wire\n    from occwl.shell import Shell\n\n    if isinstance(topods_shape, TopoDS_Vertex):\n        return Vertex(topods_shape)\n    if isinstance(topods_shape, TopoDS_Edge):\n        return Edge(topods_shape)\n    if isinstance(topods_shape, TopoDS_Face):\n        return Face(topods_shape)\n    if isinstance(topods_shape, TopoDS_Wire):\n        return Wire(topods_shape)\n    if isinstance(topods_shape, TopoDS_Shell):\n        return Shell(topods_shape)\n    if isinstance(topods_shape, TopoDS_Solid):\n        return Solid(topods_shape)\n    if isinstance(topods_shape, (TopoDS_Compound, TopoDS_CompSolid)):\n        return Compound(topods_shape)\n    raise Exception(\n        \"Shape must be one of TopoDS_Vertex, TopoDS_Edge, TopoDS_Face, TopoDS_Shell, TopoDS_Solid, TopoDS_Compound, TopoDS_CompSolid\"\n    )\n</code></pre>"},{"location":"api/#occwl.vertex.Vertex.point","title":"<code>point()</code>","text":"<p>3D point stored in this vertex</p> <p>Returns:</p> Type Description <p>np.ndarray: 3D Point</p> Source code in <code>src/occwl/vertex.py</code> <pre><code>def point(self):\n    \"\"\"\n    3D point stored in this vertex\n\n    Returns:\n        np.ndarray: 3D Point\n    \"\"\"\n    pt = BRep_Tool.Pnt(self.topods_shape())\n    return geom_utils.gp_to_numpy(pt)\n</code></pre>"},{"location":"api/#occwl.vertex.Vertex.reversed","title":"<code>reversed()</code>","text":"<p>Whether this shape is reversed.</p> <ul> <li>For an edge this is whether the edge is reversed with respect to the curve geometry</li> <li>For a face this is whether the face is reversed with respect to the surface geometry</li> <li>For a vertex this is whether the vertex is at the upper or lower parameter value on the   edges curve</li> </ul> <p>Returns:</p> Name Type Description <code>bool</code> <p>If rational</p> Source code in <code>src/occwl/shape.py</code> <pre><code>def reversed(self):\n    \"\"\"\n    Whether this shape is reversed.\n\n    - For an edge this is whether the edge is reversed with respect to the curve geometry\n    - For a face this is whether the face is reversed with respect to the surface geometry\n    - For a vertex this is whether the vertex is at the upper or lower parameter value on the\n      edges curve\n\n    Returns:\n        bool: If rational\n    \"\"\"\n    return self.topods_shape().Orientation() == TopAbs_REVERSED\n</code></pre>"},{"location":"api/#occwl.vertex.Vertex.rotate_axis_angle","title":"<code>rotate_axis_angle(axis, angle_radians, origin=np.zeros(3, dtype=(np.float32)))</code>","text":"<p>Rotate the shape about the given axis by the given angle in radians</p> <p>Parameters:</p> Name Type Description Default <code>axis</code> <code>ndarray</code> <p>Rotation axis</p> required <code>angle_radians</code> <code>float</code> <p>Angle in radians</p> required Source code in <code>src/occwl/shape.py</code> <pre><code>def rotate_axis_angle(\n    self, axis, angle_radians, origin=np.zeros(3, dtype=np.float32)\n):\n    \"\"\"\n    Rotate the shape about the given axis by the given angle in radians\n\n    Args:\n        axis (np.ndarray): Rotation axis\n        angle_radians (float): Angle in radians\n    \"\"\"\n    self._shape = rotate_shape(\n        self._shape,\n        gp_Ax1(geom_utils.numpy_to_gp(origin), geom_utils.numpy_to_gp_dir(axis)),\n        angle_radians,\n        unite=\"rad\",\n    )\n</code></pre>"},{"location":"api/#occwl.vertex.Vertex.rotate_euler_angles","title":"<code>rotate_euler_angles(angles_xyz_radians)</code>","text":"<p>Rotate the shape by the given Euler angles in radians</p> <p>Parameters:</p> Name Type Description Default <code>angle_xyz_radians</code> <code>ndarray</code> <p>3D array with angles to rotate about x-axis, y-axis and z-axis respectively in radians</p> required Source code in <code>src/occwl/shape.py</code> <pre><code>def rotate_euler_angles(self, angles_xyz_radians):\n    \"\"\"\n    Rotate the shape by the given Euler angles in radians\n\n    Args:\n        angle_xyz_radians (np.ndarray): 3D array with angles to rotate about x-axis, y-axis and z-axis respectively in radians\n    \"\"\"\n    self._shape = rotate_shp_3_axis(\n        self._shape,\n        angles_xyz_radians[0],\n        angles_xyz_radians[1],\n        angles_xyz_radians[2],\n        unity=\"rad\",\n    )\n</code></pre>"},{"location":"api/#occwl.vertex.Vertex.save_shapes_to_occ_native","title":"<code>save_shapes_to_occ_native(filename, shapes, with_triangles=False, with_normals=False, format_version=None)</code>  <code>staticmethod</code>","text":"<p>Save this shape into a native OCC binary .brep file.</p> Saving to and loading from the native file format <p>is between one and two orders of magnitude faster  than loading from STEP, so it is recommended for  large scale data processing</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str or Path</code> <p>.brep filename</p> required <code>with_triangles</code> <code>bool</code> <p>Whether to save triangle data cached in the shape.</p> <code>False</code> <code>with_normals</code> <code>bool</code> <p>Whether to save vertex normals cached in the shape</p> <code>False</code> <code>format_version</code> <code>int</code> <p>Use None to save to the latest version 1 - first revision 2 - added storing of CurveOnSurface UV Points 3 - [OCCT 7.6] added storing of per-vertex normal information                and dropped storing of CurveOnSurface UV Points</p> <code>None</code> Source code in <code>src/occwl/shape.py</code> <pre><code>@staticmethod\ndef save_shapes_to_occ_native(\n        filename, \n        shapes,\n        with_triangles=False,\n        with_normals=False,\n        format_version=None\n    ):\n    \"\"\"\n    Save this shape into a native OCC binary .brep file.\n\n    Note:  Saving to and loading from the native file format \n            is between one and two orders of magnitude faster \n            than loading from STEP, so it is recommended for \n            large scale data processing\n\n    Args:\n        filename (str or pathlib.Path): .brep filename\n\n        with_triangles (bool): Whether to save triangle data cached in the shape.\n        with_normals (bool): Whether to save vertex normals cached in the shape\n        format_version (int):  Use None to save to the latest version\n            1 - first revision\n            2 - added storing of CurveOnSurface UV Points\n            3 - [OCCT 7.6] added storing of per-vertex normal information\n                           and dropped storing of CurveOnSurface UV Points\n    \"\"\"\n    new_api = False\n    shapes_set = BRepTools_ShapeSet(with_triangles)\n    # shapes_set.SetWithNormals(with_normals) # Not in OCC 7.5.0\n\n    for shp in shapes:\n        shapes_set.Add(shp.topods_shape())\n    if format_version is not None:\n        shapes_set.SetFormatNb(format_version)\n\n\n    with open(filename, \"w\") as fp:\n        s = shapes_set.WriteToString()\n        fp.write(s)\n</code></pre>"},{"location":"api/#occwl.vertex.Vertex.save_to_occ_native","title":"<code>save_to_occ_native(filename, verbosity=False, with_triangles=False, with_normals=False, format_version=None)</code>","text":"<p>Save this shape into a native OCC binary .brep file.</p> Saving to and loading from the native file format <p>is between one and two orders of magnitude faster  than loading from STEP, so it is recommended for  large scale data processing</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str or Path</code> <p>.brep filename</p> required <code>with_triangles</code> <code>bool</code> <p>Whether to save triangle data cached in the shape.</p> <code>False</code> <code>with_normals</code> <code>bool</code> <p>Whether to save vertex normals cached in the shape</p> <code>False</code> <code>format_version</code> <code>int</code> <p>Use None to save to the latest version 1 - first revision 2 - added storing of CurveOnSurface UV Points 3 - [OCCT 7.6] added storing of per-vertex normal information                and dropped storing of CurveOnSurface UV Points</p> <code>None</code> Source code in <code>src/occwl/shape.py</code> <pre><code>def save_to_occ_native(\n        self, \n        filename, \n        verbosity=False,\n        with_triangles=False,\n        with_normals=False,\n        format_version=None\n    ):\n    \"\"\"\n    Save this shape into a native OCC binary .brep file.\n\n    Note:  Saving to and loading from the native file format \n           is between one and two orders of magnitude faster \n           than loading from STEP, so it is recommended for \n           large scale data processing\n\n    Args:\n        filename (str or pathlib.Path): .brep filename\n        with_triangles (bool): Whether to save triangle data cached in the shape.\n        with_normals (bool): Whether to save vertex normals cached in the shape\n        format_version (int):  Use None to save to the latest version\n            1 - first revision\n            2 - added storing of CurveOnSurface UV Points\n            3 - [OCCT 7.6] added storing of per-vertex normal information\n                           and dropped storing of CurveOnSurface UV Points\n    \"\"\"\n    self.save_shapes_to_occ_native(\n        filename, \n        [ self ],\n        with_triangles=with_triangles,\n        with_normals=with_normals,\n        format_version=format_version\n    )\n</code></pre>"},{"location":"api/#occwl.vertex.Vertex.scale","title":"<code>scale(scale_vector)</code>","text":"<p>Scale the shape by the given 3D vector</p> <p>Parameters:</p> Name Type Description Default <code>scale_vector</code> <code>ndarray</code> <p>3D array with scales to resize the shape along the x-axis, y-axis and z-axis respectively</p> required Source code in <code>src/occwl/shape.py</code> <pre><code>def scale(self, scale_vector):\n    \"\"\"\n    Scale the shape by the given 3D vector\n\n    Args:\n        scale_vector (np.ndarray): 3D array with scales to resize the shape along the x-axis, y-axis and z-axis respectively\n    \"\"\"\n    self._shape = scale_shape(\n        self._shape, scale_vector[0], scale_vector[1], scale_vector[2]\n    )\n</code></pre>"},{"location":"api/#occwl.vertex.Vertex.set_transform_to_identity","title":"<code>set_transform_to_identity()</code>","text":"<p>When an assembly is loaded from a STEP file the solids will be transformed relative to their local coordinate system.   i.e. they are placed in the assembly root components  coordinate system.</p> <p>When working with individual bodies you often want them to be axis aligned, in which case  you want to remove the assembly transform. This function removes it for you.</p> <p>If however you want to bake the transform into the bodies and suppress the asserts  from parts of occwl which don't cope with transforms then use the transform() function below with copy=True</p> Source code in <code>src/occwl/shape.py</code> <pre><code>def set_transform_to_identity(self):\n    \"\"\"\n    When an assembly is loaded from a STEP file\n    the solids will be transformed relative to\n    their local coordinate system.   i.e. they\n    are placed in the assembly root components \n    coordinate system.\n\n    When working with individual bodies you often\n    want them to be axis aligned, in which case \n    you want to remove the assembly transform.\n    This function removes it for you.\n\n    If however you want to bake the transform\n    into the bodies and suppress the asserts \n    from parts of occwl which don't cope with\n    transforms then use the transform() function\n    below with copy=True\n    \"\"\"\n    identity = TopLoc_Location()\n    self.topods_shape().Location(identity)\n    self._top_exp = TopologyUtils.TopologyExplorer(self.topods_shape(), True)\n    self.convert_geometric_identity_transforms_to_identity()\n</code></pre>"},{"location":"api/#occwl.vertex.Vertex.topods_shape","title":"<code>topods_shape()</code>","text":"<p>Get the underlying OCC shape</p> <p>Returns:</p> Type Description <p>OCC.Core.TopoDS.TopoDS_Vertex/Edge/Face/Wire/Shell/Solid: OCC TopoDS_*</p> Source code in <code>src/occwl/shape.py</code> <pre><code>def topods_shape(self):\n    \"\"\"\n    Get the underlying OCC shape\n\n    Returns:\n        OCC.Core.TopoDS.TopoDS_Vertex/Edge/Face/Wire/Shell/Solid: OCC TopoDS_*\n    \"\"\"\n    return self._shape\n</code></pre>"},{"location":"api/#occwl.vertex.Vertex.transform","title":"<code>transform(a, copy=True)</code>","text":"<p>Apply the given 3x4 transform matrix to the solid.</p> <pre><code> copy (bool)    True - Copy entities and apply the transform to\n                       the underlying geometry\n                False - Apply the transform to the topods Locator\n                        if possible\n</code></pre> Source code in <code>src/occwl/shape.py</code> <pre><code>def transform(self, a: np.ndarray, copy=True):\n    \"\"\"\n    Apply the given 3x4 transform matrix to the solid.\n\n    Args: a (nd.array) - Homogeneous transform matrix\n                         The transform that will be applied is\n\n                         x' =  a[0,0]*x + a[0,1]*y + a[0,2]*z + a[0, 3]\n                         y' =  a[1,0]*x + a[1,1]*y + a[1,2]*z + a[1, 3]\n                         z' =  a[2,0]*x + a[2,1]*y + a[2,2]*z + a[2, 3]\n\n         copy (bool)    True - Copy entities and apply the transform to\n                               the underlying geometry\n                        False - Apply the transform to the topods Locator\n                                if possible \n    \"\"\"\n    assert (a.shape == (3, 4)), \"Transform matrix must be 3x4\"\n    a = a.astype(np.float64)\n\n    # Create an identity transform\n    trsf = gp_Trsf()\n\n    # If the matrix is an identity matrix then\n    # we don't want to set the values as this\n    # would give us a geometric identity without\n    # the identity flag set\n    if not np.allclose(a, np.eye(3, 4)):\n        trsf.SetValues(\n            a[0,0], a[0,1], a[0,2], a[0, 3],\n            a[1,0], a[1,1], a[1,2], a[1, 3],\n            a[2,0], a[2,1], a[2,2], a[2, 3]\n        )\n    return self._apply_transform(trsf, copy=copy)\n</code></pre>"},{"location":"api/#occwl.vertex.Vertex.translate","title":"<code>translate(offset)</code>","text":"<p>Translate the shape by an offset vector</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>ndarray</code> <p>Offset vector</p> required Source code in <code>src/occwl/shape.py</code> <pre><code>def translate(self, offset):\n    \"\"\"\n    Translate the shape by an offset vector\n\n    Args:\n        offset (np.ndarray): Offset vector\n    \"\"\"\n    self._shape = translate_shp(self._shape, geom_utils.numpy_to_gp_vec(offset))\n</code></pre>"},{"location":"api/#occwl.vertex.Vertex.valid","title":"<code>valid(return_analyzer=False)</code>","text":"<p>Check if the shape is valid</p> <p>Parameters:</p> Name Type Description Default <code>return_analyzer</code> <code>bool</code> <p>Whether to return the BRepCheck_Analyzer object for more inspection</p> <code>False</code> <p>Returns:</p> Name Type Description <code>bool</code> <p>Whether the shape is valid</p> <p>BRepCheck_Analyzer [optional]: if return_analyzer is True</p> Source code in <code>src/occwl/shape.py</code> <pre><code>def valid(self, return_analyzer=False):\n    \"\"\"\n    Check if the shape is valid\n\n    Args:\n        return_analyzer (bool): Whether to return the BRepCheck_Analyzer object for more inspection\n\n    Returns:\n        bool: Whether the shape is valid\n        BRepCheck_Analyzer [optional]: if return_analyzer is True\n    \"\"\"\n    analyzer = BRepCheck_Analyzer(self.topods_shape())\n    if return_analyzer:\n        return analyzer.IsValid(), analyzer\n    return analyzer.IsValid()\n</code></pre>"},{"location":"api/#occwl.viewer","title":"<code>viewer</code>","text":""},{"location":"api/#occwl.viewer.OffscreenRenderer","title":"<code>OffscreenRenderer</code>","text":"<p>               Bases: <code>_BaseViewer</code></p> <p>Offscreen renderer that doesn't create a window. Useful for batch rendering.</p> Source code in <code>src/occwl/viewer.py</code> <pre><code>class OffscreenRenderer(_BaseViewer):\n    \"\"\"\n    Offscreen renderer that doesn't create a window. Useful for batch rendering.\n    \"\"\"\n    def __init__(self, size: Optional[Tuple[int, int]] = (1024, 768),\n        axes: Optional[bool] = True,\n        background_top_color: Optional[List[int]] = [206, 215, 222],\n        background_bottom_color: Optional[List[int]] = [128, 128, 128]\n    ):\n        \"\"\"        \n        Construct the OffscreenRenderer\n\n        Args:\n            size (Optional[Tuple[int, int]], optional): Size of the viewer window. Defaults to (1024, 768).\n            axes (Optional[bool], optional): Show arrows for coordinate axes. Defaults to True.\n            background_top_color (Optional[List[int]], optional): Background color at the top. Defaults to [206, 215, 222].\n            background_bottom_color (Optional[List[int]], optional): Background color at the bottom. Defaults to [128, 128, 128].\n        \"\"\"\n        super().__init__()\n        self._display = Viewer3d()\n        self._display.Create()\n        if axes:\n            self.show_axes()\n        else:\n            self.hide_axes()\n        self.set_size(*size)\n        self.set_background_color(background_top_color, background_bottom_color)\n        self.shaded()\n</code></pre>"},{"location":"api/#occwl.viewer.OffscreenRenderer.__init__","title":"<code>__init__(size=(1024, 768), axes=True, background_top_color=[206, 215, 222], background_bottom_color=[128, 128, 128])</code>","text":"<p>Construct the OffscreenRenderer</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>Optional[Tuple[int, int]]</code> <p>Size of the viewer window. Defaults to (1024, 768).</p> <code>(1024, 768)</code> <code>axes</code> <code>Optional[bool]</code> <p>Show arrows for coordinate axes. Defaults to True.</p> <code>True</code> <code>background_top_color</code> <code>Optional[List[int]]</code> <p>Background color at the top. Defaults to [206, 215, 222].</p> <code>[206, 215, 222]</code> <code>background_bottom_color</code> <code>Optional[List[int]]</code> <p>Background color at the bottom. Defaults to [128, 128, 128].</p> <code>[128, 128, 128]</code> Source code in <code>src/occwl/viewer.py</code> <pre><code>def __init__(self, size: Optional[Tuple[int, int]] = (1024, 768),\n    axes: Optional[bool] = True,\n    background_top_color: Optional[List[int]] = [206, 215, 222],\n    background_bottom_color: Optional[List[int]] = [128, 128, 128]\n):\n    \"\"\"        \n    Construct the OffscreenRenderer\n\n    Args:\n        size (Optional[Tuple[int, int]], optional): Size of the viewer window. Defaults to (1024, 768).\n        axes (Optional[bool], optional): Show arrows for coordinate axes. Defaults to True.\n        background_top_color (Optional[List[int]], optional): Background color at the top. Defaults to [206, 215, 222].\n        background_bottom_color (Optional[List[int]], optional): Background color at the bottom. Defaults to [128, 128, 128].\n    \"\"\"\n    super().__init__()\n    self._display = Viewer3d()\n    self._display.Create()\n    if axes:\n        self.show_axes()\n    else:\n        self.hide_axes()\n    self.set_size(*size)\n    self.set_background_color(background_top_color, background_bottom_color)\n    self.shaded()\n</code></pre>"},{"location":"api/#occwl.viewer.OffscreenRenderer.clear","title":"<code>clear()</code>","text":"<p>Clear all shapes from the viewer</p> Source code in <code>src/occwl/viewer.py</code> <pre><code>def clear(self):\n    \"\"\"\n    Clear all shapes from the viewer\n    \"\"\"\n    self._display.EraseAll()\n</code></pre>"},{"location":"api/#occwl.viewer.OffscreenRenderer.disable_antialiasing","title":"<code>disable_antialiasing()</code>","text":"<p>Disable antialiasing</p> Source code in <code>src/occwl/viewer.py</code> <pre><code>def disable_antialiasing(self):\n    \"\"\"\n    Disable antialiasing\n    \"\"\"\n    self._display.DisableAntiAliasing()\n</code></pre>"},{"location":"api/#occwl.viewer.OffscreenRenderer.display","title":"<code>display(shape, update=False, color=None, transparency=0.0)</code>","text":"<p>Display a shape (must be a Solid, Face, or Edge)</p> <p>Parameters:</p> Name Type Description Default <code>shape</code> <code>Solid, Face, or Edge</code> <p>Shape to display</p> required <code>update</code> <code>bool</code> <p>Whether to update and repaint. Defaults to False.</p> <code>False</code> <code>color</code> <code>str or tuple</code> <p>Color of the shape.                             If str, can be 'WHITE', 'BLUE', 'RED', 'GREEN', 'YELLOW',                            'CYAN', 'BLACK', or 'ORANGE'. Defaults to None.</p> <code>None</code> <code>transparency</code> <code>float</code> <p>How transparent the shape is. Defaults to 0.0.</p> <code>0.0</code> Source code in <code>src/occwl/viewer.py</code> <pre><code>def display(self, shape, update=False, color=None, transparency=0.0):\n    \"\"\"\n    Display a shape (must be a Solid, Face, or Edge)\n\n    Args:\n        shape (Solid, Face, or Edge): Shape to display\n        update (bool, optional): Whether to update and repaint. Defaults to False.\n        color (str or tuple, optional): Color of the shape.\n                                        If str, can be 'WHITE', 'BLUE', 'RED', 'GREEN', 'YELLOW',\n                                       'CYAN', 'BLACK', or 'ORANGE'. Defaults to None.\n        transparency (float, optional): How transparent the shape is. Defaults to 0.0.\n    \"\"\"\n    if isinstance(shape, (Compound, Solid, Shell, Face, Edge, Wire, Vertex)):\n        shape = shape.topods_shape()\n    if color and not isinstance(color, (str, tuple)):\n        color = \"BLACK\"\n    if isinstance(color, (tuple, list)):\n        assert len(color) == 3, \"Expected a 3-tuple/list when color is specified as RGB\"\n        color = Quantity_Color(\n            float(color[0]), float(color[1]), float(color[2]), Quantity_TOC_RGB\n        )\n    return self._display.DisplayShape(\n        shape, update=update, color=color, transparency=transparency\n    )\n</code></pre>"},{"location":"api/#occwl.viewer.OffscreenRenderer.display_lines","title":"<code>display_lines(origins, directions, color=None, thickness=1, style='solid')</code>","text":"<p>Display a set of lines</p> <p>Parameters:</p> Name Type Description Default <code>origins</code> <code>2D np.ndarray of size #points x 3</code> <p>Origin points of the arrows</p> required <code>directions</code> <code>2D np.ndarray of size #points x 3</code> <p>Unit vectors for directions of the arrows</p> required <code>color</code> <code>tuple of 3 floats or 2D np.ndarray of size #points x 3 or str</code> <p>RGB color (can be a single color or per-point colors). Defaults to None.</p> <code>None</code> <code>thickness</code> <code>float</code> <p>Thickness of the lines</p> <code>1</code> <code>style</code> <code>str</code> <p>Style for the lines. Must be one of ('solid', 'dash', 'dot', 'dotdash'). Defaults to 'solid'.</p> <code>'solid'</code> Source code in <code>src/occwl/viewer.py</code> <pre><code>def display_lines(\n    self, origins, directions, color=None, thickness=1, style=\"solid\",\n):\n    \"\"\"\n    Display a set of lines\n\n    Args:\n        origins (2D np.ndarray of size #points x 3): Origin points of the arrows\n        directions (2D np.ndarray of size #points x 3): Unit vectors for directions of the arrows\n        color (tuple of 3 floats or 2D np.ndarray of size #points x 3 or str, optional): RGB color (can be a single color or per-point colors). Defaults to None.\n        thickness (float, optional): Thickness of the lines\n        style (str, optional): Style for the lines. Must be one of ('solid', 'dash', 'dot', 'dotdash'). Defaults to 'solid'.\n    \"\"\"\n    assert (\n        origins.shape[0] == directions.shape[0]\n    ), \"origins and directions must match in size (#points x 3)\"\n    if color is None:\n        color = (0, 0, 0)\n\n    if style == \"solid\":\n        type_of_line = Aspect_TOL_SOLID\n    elif style == \"dash\":\n        type_of_line = Aspect_TOL_DASH\n    elif style == \"dot\":\n        type_of_line = Aspect_TOL_DOT\n    elif style == \"dotdash\":\n        type_of_line = Aspect_TOL_DOTDASH\n    else:\n        type_of_line = Aspect_TOL_SOLID\n        print(\n            f\"Unknown style {style}. Expected one of ('solid', 'dash', 'dot', 'dotdash'). Setting to 'solid'.\"\n        )\n\n    line_entities = []\n    for idx in range(origins.shape[0]):\n        if isinstance(color, tuple):\n            quantity_color = Quantity_Color(color[0], color[1], color[2], Quantity_TOC_RGB)\n        elif isinstance(color, np.ndarray):\n            assert (\n                origins.shape[0] == color.shape[0]\n            ), \"pts and color must match in size (#points x 3)\"\n            quantity_color = Quantity_Color(\n                color[idx, 0], color[idx, 1], color[idx, 2], Quantity_TOC_RGB\n            )\n        elif isinstance(color, str):\n            quantity_color = get_color_from_name(color)\n\n        line = Geom_Line(\n            geom_utils.to_gp_pnt(origins[idx, :]),\n            geom_utils.to_gp_dir(directions[idx, :]),\n        )\n        ais_line = AIS_Line(line)\n        attr = ais_line.Attributes()\n        asp = Prs3d_LineAspect(quantity_color, type_of_line, thickness)\n        attr.SetLineAspect(asp)\n        ais_line.SetAttributes(attr)\n        self._display.Context.Display(ais_line, False)\n        line_entities.append(ais_line)\n    return line_entities\n</code></pre>"},{"location":"api/#occwl.viewer.OffscreenRenderer.display_points","title":"<code>display_points(pts, color=None, scale=10, marker='ball')</code>","text":"<p>Display a set of points</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>ndarray</code> <p>Points to display</p> required <code>color</code> <code>tuple of 3 floats or np.ndarray of size #points x 3 or str</code> <p>RGB color (can be a single color or per-point colors). Defaults to None.</p> <code>None</code> <code>scale</code> <code>float</code> <p>Scale of the points</p> <code>10</code> <code>marker</code> <code>str</code> <p>Marker type for the point. Must be one of ('point', 'star', 'ball', 'x', 'o'). Defaults to 'ball'.</p> <code>'ball'</code> Source code in <code>src/occwl/viewer.py</code> <pre><code>def display_points(self, pts, color=None, scale=10, marker=\"ball\"):\n    \"\"\"\n    Display a set of points\n\n    Args:\n        points (np.ndarray #points x 3): Points to display\n        color (tuple of 3 floats or np.ndarray of size #points x 3 or str, optional): RGB color (can be a single color or per-point colors). Defaults to None.\n        scale (float, optional): Scale of the points\n        marker (str, optional): Marker type for the point. Must be one of ('point', 'star', 'ball', 'x', 'o'). Defaults to 'ball'.\n    \"\"\"\n    if color is None:\n        color = (0, 0, 0)\n    if marker == \"point\":\n        marker_type = Aspect_TOM_POINT\n    elif marker == \"o\":\n        marker_type = Aspect_TOM_O\n    elif marker == \"star\":\n        marker_type = Aspect_TOM_STAR\n    elif marker == \"x\":\n        marker_type = Aspect_TOM_X\n    elif marker == \"ball\":\n        marker_type = Aspect_TOM_BALL\n    else:\n        marker_type = Aspect_TOM_POINT\n        print(\n            \"Unknown marker type {}. Expected one of ('point', 'star', 'ball', 'o', 'x'). Setting to 'point'.\"\n        )\n    point_entities = []\n    for idx in range(pts.shape[0]):\n        if isinstance(color, tuple):\n            quantity_color = Quantity_Color(color[0], color[1], color[2], Quantity_TOC_RGB)\n        elif isinstance(color, np.ndarray):\n            assert (\n                pts.shape[0] == color.shape[0]\n            ), \"pts and color must match in size (#points x 3)\"\n            quantity_color = Quantity_Color(\n                color[idx, 0], color[idx, 1], color[idx, 2], Quantity_TOC_RGB\n            )\n        elif isinstance(color, str):\n            quantity_color = get_color_from_name(color)\n        p = Geom_CartesianPoint(geom_utils.to_gp_pnt(pts[idx, :]))\n        ais_point = AIS_Point(p)\n        attr = ais_point.Attributes()\n        asp = Prs3d_PointAspect(marker_type, quantity_color, float(scale))\n        attr.SetPointAspect(asp)\n        ais_point.SetAttributes(attr)\n        self._display.Context.Display(ais_point, False)\n        point_entities.append(ais_point)\n    return point_entities\n</code></pre>"},{"location":"api/#occwl.viewer.OffscreenRenderer.display_text","title":"<code>display_text(xyz, text, height=None, color=None)</code>","text":"<p>Display a text</p> <p>Parameters:</p> Name Type Description Default <code>xyz</code> <code>tuple of floats or 1D np.ndarray of 2 or 3</code> <p>Coordinate in model space where text would appear</p> required <code>text</code> <code>str</code> <p>Text to display</p> required <code>height</code> <code>float</code> <p>Height of the text font. Defaults to None.</p> <code>None</code> <code>color</code> <code>tuple of 3 floats</code> <p>RGB color. Defaults to None.</p> <code>None</code> Source code in <code>src/occwl/viewer.py</code> <pre><code>def display_text(self, xyz, text, height=None, color=None):\n    \"\"\"\n    Display a text\n\n    Args:\n        xyz (tuple of floats or 1D np.ndarray of 2 or 3): Coordinate in model space where text would appear\n        text (str): Text to display\n        height (float, optional): Height of the text font. Defaults to None.\n        color (tuple of 3 floats, optional): RGB color. Defaults to None.\n    \"\"\"\n    return self._display.DisplayMessage(\n        geom_utils.to_gp_pnt(xyz), text, height=height, message_color=color\n    )\n</code></pre>"},{"location":"api/#occwl.viewer.OffscreenRenderer.enable_antialiasing","title":"<code>enable_antialiasing()</code>","text":"<p>Enable antialiasing</p> Source code in <code>src/occwl/viewer.py</code> <pre><code>def enable_antialiasing(self):\n    \"\"\"\n    Enable antialiasing\n    \"\"\"\n    self._display.EnableAntiAliasing()\n</code></pre>"},{"location":"api/#occwl.viewer.OffscreenRenderer.fit","title":"<code>fit()</code>","text":"<p>Fit the camera to the scene</p> Source code in <code>src/occwl/viewer.py</code> <pre><code>def fit(self):\n    \"\"\"\n    Fit the camera to the scene\n    \"\"\"\n    self._display.FitAll()\n</code></pre>"},{"location":"api/#occwl.viewer.OffscreenRenderer.hide_axes","title":"<code>hide_axes()</code>","text":"<p>Hide the XYZ-axes widget</p> Source code in <code>src/occwl/viewer.py</code> <pre><code>def hide_axes(self):\n    \"\"\"\n    Hide the XYZ-axes widget\n    \"\"\"\n    self._display.hide_triedron()\n</code></pre>"},{"location":"api/#occwl.viewer.OffscreenRenderer.hide_face_boundary","title":"<code>hide_face_boundary()</code>","text":"<p>Hide the edges bounding each face</p> Source code in <code>src/occwl/viewer.py</code> <pre><code>def hide_face_boundary(self):\n    \"\"\"\n    Hide the edges bounding each face\n    \"\"\"\n    self._display.default_drawer.SetFaceBoundaryDraw(False)\n</code></pre>"},{"location":"api/#occwl.viewer.OffscreenRenderer.orthographic","title":"<code>orthographic()</code>","text":"<p>Set orthographic camera projection</p> Source code in <code>src/occwl/viewer.py</code> <pre><code>def orthographic(self):\n    \"\"\"\n    Set orthographic camera projection\n    \"\"\"\n    self._display.SetOrthographicProjection()\n    self._display.FitAll()\n</code></pre>"},{"location":"api/#occwl.viewer.OffscreenRenderer.perspective","title":"<code>perspective()</code>","text":"<p>Set perspective camera projection</p> Source code in <code>src/occwl/viewer.py</code> <pre><code>def perspective(self):\n    \"\"\"\n    Set perspective camera projection\n    \"\"\"\n    self._display.SetPerspectiveProjection()\n    self._display.FitAll()\n</code></pre>"},{"location":"api/#occwl.viewer.OffscreenRenderer.save_image","title":"<code>save_image(filename=None)</code>","text":"<p>Save a screenshot of the viewer</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str or Path</code> <p>Image file to save the screenshot. Defaults to None.                                       If None, writes a PNG file named with the current timestamp</p> <code>None</code> Source code in <code>src/occwl/viewer.py</code> <pre><code>def save_image(self, filename=None):\n    \"\"\"\n    Save a screenshot of the viewer\n\n    Args:\n        filename (str or pathlib.Path, optional): Image file to save the screenshot. Defaults to None.\n                                                  If None, writes a PNG file named with the current timestamp\n    \"\"\"\n    if filename is None:\n        now = datetime.now()\n        current_time = str(now)\n        filename = current_time + \".png\"\n    self._display.View.Dump(str(filename))\n</code></pre>"},{"location":"api/#occwl.viewer.OffscreenRenderer.selected_shapes","title":"<code>selected_shapes()</code>","text":"<p>Get the selected shapes</p> <p>Returns:</p> Type Description <p>List[TopoDS_Shape]: List of selected shapes</p> Source code in <code>src/occwl/viewer.py</code> <pre><code>def selected_shapes(self):\n    \"\"\"\n    Get the selected shapes\n\n    Returns:\n        List[TopoDS_Shape]: List of selected shapes\n    \"\"\"\n    shapes = self._display.GetSelectedShapes()\n    shapes = self._convert_to_occwl_types(shapes)\n    return shapes\n</code></pre>"},{"location":"api/#occwl.viewer.OffscreenRenderer.set_background_color","title":"<code>set_background_color(top_color, bottom_color)</code>","text":"<p>Set the background gradient color</p> <p>Parameters:</p> Name Type Description Default <code>top_color</code> <code>List / Tuple[int, int, int]</code> <p>Top color</p> required <code>bottom_color</code> <code>List / Tuple[int, int, int]</code> <p>Bottom color</p> required Source code in <code>src/occwl/viewer.py</code> <pre><code>def set_background_color(self, top_color, bottom_color):\n    \"\"\"\n    Set the background gradient color\n\n    Args:\n        top_color (List/Tuple[int, int, int]): Top color\n        bottom_color (List/Tuple[int, int, int]): Bottom color\n    \"\"\"\n    assert isinstance(top_color, (tuple, list))\n    assert isinstance(bottom_color, (tuple, list))\n    self._display.set_bg_gradient_color(top_color, bottom_color)\n</code></pre>"},{"location":"api/#occwl.viewer.OffscreenRenderer.set_size","title":"<code>set_size(width, height)</code>","text":"<p>Set the size of the framebuffer</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>Width of the framebuffer</p> required <code>height</code> <code>int</code> <p>Height of the framebuffer</p> required Source code in <code>src/occwl/viewer.py</code> <pre><code>def set_size(self, width, height):\n    \"\"\"\n    Set the size of the framebuffer\n\n    Args:\n        width (int): Width of the framebuffer\n        height (int): Height of the framebuffer\n    \"\"\"\n    self._display.SetSize(width, height)\n</code></pre>"},{"location":"api/#occwl.viewer.OffscreenRenderer.shaded","title":"<code>shaded()</code>","text":"<p>Shade all shapes</p> Source code in <code>src/occwl/viewer.py</code> <pre><code>def shaded(self):\n    \"\"\"\n    Shade all shapes\n    \"\"\"\n    self._display.View.SetComputedMode(False)\n    self._display.Context.SetDisplayMode(AIS_Shaded, True)\n</code></pre>"},{"location":"api/#occwl.viewer.OffscreenRenderer.show_axes","title":"<code>show_axes()</code>","text":"<p>Show the XYZ-axes widget</p> Source code in <code>src/occwl/viewer.py</code> <pre><code>def show_axes(self):\n    \"\"\"\n    Show the XYZ-axes widget\n    \"\"\"\n    self._display.display_triedron()\n</code></pre>"},{"location":"api/#occwl.viewer.OffscreenRenderer.show_face_boundary","title":"<code>show_face_boundary()</code>","text":"<p>Show the edges bounding each face</p> Source code in <code>src/occwl/viewer.py</code> <pre><code>def show_face_boundary(self):\n    \"\"\"\n    Show the edges bounding each face\n    \"\"\"\n    self._display.default_drawer.SetFaceBoundaryDraw(True)\n</code></pre>"},{"location":"api/#occwl.viewer.OffscreenRenderer.use_flat_shading","title":"<code>use_flat_shading()</code>","text":"<p>Use no interpolation when computing color for fragments in a triangle</p> Source code in <code>src/occwl/viewer.py</code> <pre><code>def use_flat_shading(self):\n    \"\"\"\n    Use no interpolation when computing color for fragments in a triangle\n    \"\"\"\n    self._display.View.SetShadingModel(Graphic3d_TOSM_FACET)\n</code></pre>"},{"location":"api/#occwl.viewer.OffscreenRenderer.use_gouraud_shading","title":"<code>use_gouraud_shading()</code>","text":"<p>Compute colors per vertex and interpolate</p> Source code in <code>src/occwl/viewer.py</code> <pre><code>def use_gouraud_shading(self):\n    \"\"\"\n    Compute colors per vertex and interpolate\n    \"\"\"\n    self._display.View.SetShadingModel(Graphic3d_TOSM_VERTEX)\n</code></pre>"},{"location":"api/#occwl.viewer.OffscreenRenderer.use_phong_shading","title":"<code>use_phong_shading()</code>","text":"<p>Compute colors per fragment</p> Source code in <code>src/occwl/viewer.py</code> <pre><code>def use_phong_shading(self):\n    \"\"\"\n    Compute colors per fragment\n    \"\"\"\n    self._display.View.SetShadingModel(Graphic3d_TOSM_FRAGMENT)\n</code></pre>"},{"location":"api/#occwl.viewer.OffscreenRenderer.use_rasterization","title":"<code>use_rasterization()</code>","text":"<p>Render using rasterization</p> Source code in <code>src/occwl/viewer.py</code> <pre><code>def use_rasterization(self):\n    \"\"\"\n    Render using rasterization\n    \"\"\"\n    self._display.SetRasterizationMode()\n</code></pre>"},{"location":"api/#occwl.viewer.OffscreenRenderer.use_raytracing","title":"<code>use_raytracing(depth=3)</code>","text":"<p>Render using raytracing</p> <p>Parameters:</p> Name Type Description Default <code>depth</code> <code>int</code> <p>Number of bounces for rays Defaults to 3.</p> <code>3</code> Source code in <code>src/occwl/viewer.py</code> <pre><code>def use_raytracing(self, depth=3):\n    \"\"\"\n    Render using raytracing\n\n    Args:\n        depth (int, optional): Number of bounces for rays Defaults to 3.\n    \"\"\"\n    self._display.SetRaytracingMode(depth=depth)\n</code></pre>"},{"location":"api/#occwl.viewer.OffscreenRenderer.wireframe","title":"<code>wireframe()</code>","text":"<p>Set all shapes to appear as wireframes</p> Source code in <code>src/occwl/viewer.py</code> <pre><code>def wireframe(self):\n    \"\"\"\n    Set all shapes to appear as wireframes\n    \"\"\"\n    self._display.View.SetComputedMode(False)\n    self._display.Context.SetDisplayMode(AIS_WireFrame, True)\n</code></pre>"},{"location":"api/#occwl.viewer.Viewer","title":"<code>Viewer</code>","text":"<p>               Bases: <code>_BaseViewer</code></p> <p>A Viewer for topological entities</p> Source code in <code>src/occwl/viewer.py</code> <pre><code>class Viewer(_BaseViewer):\n    \"\"\"\n    A Viewer for topological entities\n    \"\"\"\n\n    def __init__(\n        self,\n        backend: str = None,\n        size: Optional[Tuple[int, int]] = (1024, 768),\n        axes: Optional[bool] = True,\n        background_gradient_color1: Optional[List[int]] = [206, 215, 222],\n        background_gradient_color2: Optional[List[int]] = [128, 128, 128],\n    ):\n        \"\"\"\n        Construct the Viewer\n\n        Args:\n            backend (str, optional): Backend use to create the viewer. Must be one of wx, pyqt4, pyqt5 or pyside. Defaults to None.\n            size (Optional[Tuple[int, int]], optional): Size of the viewer window. Defaults to (1024, 768).\n            axes (Optional[bool], optional): Show arrows for coordinate axes. Defaults to True.\n            background_gradient_color1 (Optional[List[int]], optional): Background color at the top. Defaults to [206, 215, 222].\n            background_gradient_color2 (Optional[List[int]], optional): Background color at the bottom. Defaults to [128, 128, 128].\n        \"\"\"\n        (\n            self._display,\n            self._start_display,\n            self._add_menu,\n            self._add_function_to_menu,\n        ) = init_display(\n            backend_str=backend,\n            size=size,\n            display_triedron=axes,\n            background_gradient_color1=background_gradient_color1,\n            background_gradient_color2=background_gradient_color2,\n        )\n\n    def on_select(self, callback):\n        \"\"\"\n        Callback to execute when a selection is made\n\n        Args:\n            callback (function): Called when a selection is made. Must have signature:\n                                 def callback(selected_shapes, mouse_x, mouse_y)\n        \"\"\"\n\n        def wrapped_callback(selected_shapes, x, y):\n            selected_shapes = self._convert_to_occwl_types(selected_shapes)\n            return callback(selected_shapes, x, y)\n\n        self._display.register_select_callback(wrapped_callback)\n\n    def _convert_to_occwl_types(self, shapes):\n        for i in range(len(shapes)):\n            if type(shapes[i]) == TopoDS_Vertex:\n                shapes[i] = Vertex(shapes[i])\n            elif type(shapes[i]) == TopoDS_Edge:\n                shapes[i] = Edge(shapes[i])\n            elif type(shapes[i]) == TopoDS_Face:\n                shapes[i] = Face(shapes[i])\n            elif type(shapes[i]) == TopoDS_Shell:\n                shapes[i] = Shell(shapes[i])\n            elif type(shapes[i]) == TopoDS_Solid:\n                shapes[i] = Solid(shapes[i])\n            elif type(shapes[i]) == TopoDS_Compound:\n                shapes[i] = Compound(shapes[i])\n        return shapes\n\n    def selected_shapes(self):\n        \"\"\"\n        Get the selected shapes\n\n        Returns:\n            List[TopoDS_Shape]: List of selected shapes\n        \"\"\"\n        shapes = self._display.GetSelectedShapes()\n        shapes = self._convert_to_occwl_types(shapes)\n        return shapes\n\n    def show(self):\n        \"\"\"\n        Show the viewer\n        \"\"\"\n        self._start_display()\n\n    def add_menu(self, name):\n        \"\"\"\n        Add a custom menu to the viewer\n\n        Args:\n            name (str): Name of the menu\n        \"\"\"\n        self._add_menu(name)\n\n    def add_submenu(self, menu, callback):\n        \"\"\"\n        Add a sub-menu to an existing menu\n\n        Args:\n            menu (str): Name of the menu\n            callback (function): Function to be added as a sub-menu. The name of the function will appear under menu.\n        \"\"\"\n        self._add_function_to_menu(menu, callback)\n\n    def exit(self):\n        \"\"\"\n        Exit the viewer\n        \"\"\"\n        import sys\n\n        sys.exit()\n\n    def selection_mode_vertex(self):\n        \"\"\"\n        Allow vertices to be selected\n        \"\"\"\n        self._display.SetSelectionMode(TopAbs_VERTEX)\n\n    def selection_mode_edge(self):\n        \"\"\"\n        Allow edges to be selected\n        \"\"\"\n        self._display.SetSelectionMode(TopAbs_EDGE)\n\n    def selection_mode_face(self):\n        \"\"\"\n        Allow faces to be selected\n        \"\"\"\n        self._display.SetSelectionMode(TopAbs_FACE)\n\n    def selection_mode_shell(self):\n        \"\"\"\n        Allow all shapes to be selected\n        \"\"\"\n        self._display.SetSelectionMode(TopAbs_SHELL)\n\n    def selection_mode_solid(self):\n        \"\"\"\n        Allow no shapes to be selected\n        \"\"\"\n        self._display.SetSelectionMode(TopAbs_SOLID)\n\n    def selection_mode_none(self):\n        \"\"\"\n        Allow no shapes to be selected\n        \"\"\"\n        self._display.SetSelectionModeShape()\n</code></pre>"},{"location":"api/#occwl.viewer.Viewer.__init__","title":"<code>__init__(backend=None, size=(1024, 768), axes=True, background_gradient_color1=[206, 215, 222], background_gradient_color2=[128, 128, 128])</code>","text":"<p>Construct the Viewer</p> <p>Parameters:</p> Name Type Description Default <code>backend</code> <code>str</code> <p>Backend use to create the viewer. Must be one of wx, pyqt4, pyqt5 or pyside. Defaults to None.</p> <code>None</code> <code>size</code> <code>Optional[Tuple[int, int]]</code> <p>Size of the viewer window. Defaults to (1024, 768).</p> <code>(1024, 768)</code> <code>axes</code> <code>Optional[bool]</code> <p>Show arrows for coordinate axes. Defaults to True.</p> <code>True</code> <code>background_gradient_color1</code> <code>Optional[List[int]]</code> <p>Background color at the top. Defaults to [206, 215, 222].</p> <code>[206, 215, 222]</code> <code>background_gradient_color2</code> <code>Optional[List[int]]</code> <p>Background color at the bottom. Defaults to [128, 128, 128].</p> <code>[128, 128, 128]</code> Source code in <code>src/occwl/viewer.py</code> <pre><code>def __init__(\n    self,\n    backend: str = None,\n    size: Optional[Tuple[int, int]] = (1024, 768),\n    axes: Optional[bool] = True,\n    background_gradient_color1: Optional[List[int]] = [206, 215, 222],\n    background_gradient_color2: Optional[List[int]] = [128, 128, 128],\n):\n    \"\"\"\n    Construct the Viewer\n\n    Args:\n        backend (str, optional): Backend use to create the viewer. Must be one of wx, pyqt4, pyqt5 or pyside. Defaults to None.\n        size (Optional[Tuple[int, int]], optional): Size of the viewer window. Defaults to (1024, 768).\n        axes (Optional[bool], optional): Show arrows for coordinate axes. Defaults to True.\n        background_gradient_color1 (Optional[List[int]], optional): Background color at the top. Defaults to [206, 215, 222].\n        background_gradient_color2 (Optional[List[int]], optional): Background color at the bottom. Defaults to [128, 128, 128].\n    \"\"\"\n    (\n        self._display,\n        self._start_display,\n        self._add_menu,\n        self._add_function_to_menu,\n    ) = init_display(\n        backend_str=backend,\n        size=size,\n        display_triedron=axes,\n        background_gradient_color1=background_gradient_color1,\n        background_gradient_color2=background_gradient_color2,\n    )\n</code></pre>"},{"location":"api/#occwl.viewer.Viewer.add_menu","title":"<code>add_menu(name)</code>","text":"<p>Add a custom menu to the viewer</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the menu</p> required Source code in <code>src/occwl/viewer.py</code> <pre><code>def add_menu(self, name):\n    \"\"\"\n    Add a custom menu to the viewer\n\n    Args:\n        name (str): Name of the menu\n    \"\"\"\n    self._add_menu(name)\n</code></pre>"},{"location":"api/#occwl.viewer.Viewer.add_submenu","title":"<code>add_submenu(menu, callback)</code>","text":"<p>Add a sub-menu to an existing menu</p> <p>Parameters:</p> Name Type Description Default <code>menu</code> <code>str</code> <p>Name of the menu</p> required <code>callback</code> <code>function</code> <p>Function to be added as a sub-menu. The name of the function will appear under menu.</p> required Source code in <code>src/occwl/viewer.py</code> <pre><code>def add_submenu(self, menu, callback):\n    \"\"\"\n    Add a sub-menu to an existing menu\n\n    Args:\n        menu (str): Name of the menu\n        callback (function): Function to be added as a sub-menu. The name of the function will appear under menu.\n    \"\"\"\n    self._add_function_to_menu(menu, callback)\n</code></pre>"},{"location":"api/#occwl.viewer.Viewer.clear","title":"<code>clear()</code>","text":"<p>Clear all shapes from the viewer</p> Source code in <code>src/occwl/viewer.py</code> <pre><code>def clear(self):\n    \"\"\"\n    Clear all shapes from the viewer\n    \"\"\"\n    self._display.EraseAll()\n</code></pre>"},{"location":"api/#occwl.viewer.Viewer.disable_antialiasing","title":"<code>disable_antialiasing()</code>","text":"<p>Disable antialiasing</p> Source code in <code>src/occwl/viewer.py</code> <pre><code>def disable_antialiasing(self):\n    \"\"\"\n    Disable antialiasing\n    \"\"\"\n    self._display.DisableAntiAliasing()\n</code></pre>"},{"location":"api/#occwl.viewer.Viewer.display","title":"<code>display(shape, update=False, color=None, transparency=0.0)</code>","text":"<p>Display a shape (must be a Solid, Face, or Edge)</p> <p>Parameters:</p> Name Type Description Default <code>shape</code> <code>Solid, Face, or Edge</code> <p>Shape to display</p> required <code>update</code> <code>bool</code> <p>Whether to update and repaint. Defaults to False.</p> <code>False</code> <code>color</code> <code>str or tuple</code> <p>Color of the shape.                             If str, can be 'WHITE', 'BLUE', 'RED', 'GREEN', 'YELLOW',                            'CYAN', 'BLACK', or 'ORANGE'. Defaults to None.</p> <code>None</code> <code>transparency</code> <code>float</code> <p>How transparent the shape is. Defaults to 0.0.</p> <code>0.0</code> Source code in <code>src/occwl/viewer.py</code> <pre><code>def display(self, shape, update=False, color=None, transparency=0.0):\n    \"\"\"\n    Display a shape (must be a Solid, Face, or Edge)\n\n    Args:\n        shape (Solid, Face, or Edge): Shape to display\n        update (bool, optional): Whether to update and repaint. Defaults to False.\n        color (str or tuple, optional): Color of the shape.\n                                        If str, can be 'WHITE', 'BLUE', 'RED', 'GREEN', 'YELLOW',\n                                       'CYAN', 'BLACK', or 'ORANGE'. Defaults to None.\n        transparency (float, optional): How transparent the shape is. Defaults to 0.0.\n    \"\"\"\n    if isinstance(shape, (Compound, Solid, Shell, Face, Edge, Wire, Vertex)):\n        shape = shape.topods_shape()\n    if color and not isinstance(color, (str, tuple)):\n        color = \"BLACK\"\n    if isinstance(color, (tuple, list)):\n        assert len(color) == 3, \"Expected a 3-tuple/list when color is specified as RGB\"\n        color = Quantity_Color(\n            float(color[0]), float(color[1]), float(color[2]), Quantity_TOC_RGB\n        )\n    return self._display.DisplayShape(\n        shape, update=update, color=color, transparency=transparency\n    )\n</code></pre>"},{"location":"api/#occwl.viewer.Viewer.display_lines","title":"<code>display_lines(origins, directions, color=None, thickness=1, style='solid')</code>","text":"<p>Display a set of lines</p> <p>Parameters:</p> Name Type Description Default <code>origins</code> <code>2D np.ndarray of size #points x 3</code> <p>Origin points of the arrows</p> required <code>directions</code> <code>2D np.ndarray of size #points x 3</code> <p>Unit vectors for directions of the arrows</p> required <code>color</code> <code>tuple of 3 floats or 2D np.ndarray of size #points x 3 or str</code> <p>RGB color (can be a single color or per-point colors). Defaults to None.</p> <code>None</code> <code>thickness</code> <code>float</code> <p>Thickness of the lines</p> <code>1</code> <code>style</code> <code>str</code> <p>Style for the lines. Must be one of ('solid', 'dash', 'dot', 'dotdash'). Defaults to 'solid'.</p> <code>'solid'</code> Source code in <code>src/occwl/viewer.py</code> <pre><code>def display_lines(\n    self, origins, directions, color=None, thickness=1, style=\"solid\",\n):\n    \"\"\"\n    Display a set of lines\n\n    Args:\n        origins (2D np.ndarray of size #points x 3): Origin points of the arrows\n        directions (2D np.ndarray of size #points x 3): Unit vectors for directions of the arrows\n        color (tuple of 3 floats or 2D np.ndarray of size #points x 3 or str, optional): RGB color (can be a single color or per-point colors). Defaults to None.\n        thickness (float, optional): Thickness of the lines\n        style (str, optional): Style for the lines. Must be one of ('solid', 'dash', 'dot', 'dotdash'). Defaults to 'solid'.\n    \"\"\"\n    assert (\n        origins.shape[0] == directions.shape[0]\n    ), \"origins and directions must match in size (#points x 3)\"\n    if color is None:\n        color = (0, 0, 0)\n\n    if style == \"solid\":\n        type_of_line = Aspect_TOL_SOLID\n    elif style == \"dash\":\n        type_of_line = Aspect_TOL_DASH\n    elif style == \"dot\":\n        type_of_line = Aspect_TOL_DOT\n    elif style == \"dotdash\":\n        type_of_line = Aspect_TOL_DOTDASH\n    else:\n        type_of_line = Aspect_TOL_SOLID\n        print(\n            f\"Unknown style {style}. Expected one of ('solid', 'dash', 'dot', 'dotdash'). Setting to 'solid'.\"\n        )\n\n    line_entities = []\n    for idx in range(origins.shape[0]):\n        if isinstance(color, tuple):\n            quantity_color = Quantity_Color(color[0], color[1], color[2], Quantity_TOC_RGB)\n        elif isinstance(color, np.ndarray):\n            assert (\n                origins.shape[0] == color.shape[0]\n            ), \"pts and color must match in size (#points x 3)\"\n            quantity_color = Quantity_Color(\n                color[idx, 0], color[idx, 1], color[idx, 2], Quantity_TOC_RGB\n            )\n        elif isinstance(color, str):\n            quantity_color = get_color_from_name(color)\n\n        line = Geom_Line(\n            geom_utils.to_gp_pnt(origins[idx, :]),\n            geom_utils.to_gp_dir(directions[idx, :]),\n        )\n        ais_line = AIS_Line(line)\n        attr = ais_line.Attributes()\n        asp = Prs3d_LineAspect(quantity_color, type_of_line, thickness)\n        attr.SetLineAspect(asp)\n        ais_line.SetAttributes(attr)\n        self._display.Context.Display(ais_line, False)\n        line_entities.append(ais_line)\n    return line_entities\n</code></pre>"},{"location":"api/#occwl.viewer.Viewer.display_points","title":"<code>display_points(pts, color=None, scale=10, marker='ball')</code>","text":"<p>Display a set of points</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>ndarray</code> <p>Points to display</p> required <code>color</code> <code>tuple of 3 floats or np.ndarray of size #points x 3 or str</code> <p>RGB color (can be a single color or per-point colors). Defaults to None.</p> <code>None</code> <code>scale</code> <code>float</code> <p>Scale of the points</p> <code>10</code> <code>marker</code> <code>str</code> <p>Marker type for the point. Must be one of ('point', 'star', 'ball', 'x', 'o'). Defaults to 'ball'.</p> <code>'ball'</code> Source code in <code>src/occwl/viewer.py</code> <pre><code>def display_points(self, pts, color=None, scale=10, marker=\"ball\"):\n    \"\"\"\n    Display a set of points\n\n    Args:\n        points (np.ndarray #points x 3): Points to display\n        color (tuple of 3 floats or np.ndarray of size #points x 3 or str, optional): RGB color (can be a single color or per-point colors). Defaults to None.\n        scale (float, optional): Scale of the points\n        marker (str, optional): Marker type for the point. Must be one of ('point', 'star', 'ball', 'x', 'o'). Defaults to 'ball'.\n    \"\"\"\n    if color is None:\n        color = (0, 0, 0)\n    if marker == \"point\":\n        marker_type = Aspect_TOM_POINT\n    elif marker == \"o\":\n        marker_type = Aspect_TOM_O\n    elif marker == \"star\":\n        marker_type = Aspect_TOM_STAR\n    elif marker == \"x\":\n        marker_type = Aspect_TOM_X\n    elif marker == \"ball\":\n        marker_type = Aspect_TOM_BALL\n    else:\n        marker_type = Aspect_TOM_POINT\n        print(\n            \"Unknown marker type {}. Expected one of ('point', 'star', 'ball', 'o', 'x'). Setting to 'point'.\"\n        )\n    point_entities = []\n    for idx in range(pts.shape[0]):\n        if isinstance(color, tuple):\n            quantity_color = Quantity_Color(color[0], color[1], color[2], Quantity_TOC_RGB)\n        elif isinstance(color, np.ndarray):\n            assert (\n                pts.shape[0] == color.shape[0]\n            ), \"pts and color must match in size (#points x 3)\"\n            quantity_color = Quantity_Color(\n                color[idx, 0], color[idx, 1], color[idx, 2], Quantity_TOC_RGB\n            )\n        elif isinstance(color, str):\n            quantity_color = get_color_from_name(color)\n        p = Geom_CartesianPoint(geom_utils.to_gp_pnt(pts[idx, :]))\n        ais_point = AIS_Point(p)\n        attr = ais_point.Attributes()\n        asp = Prs3d_PointAspect(marker_type, quantity_color, float(scale))\n        attr.SetPointAspect(asp)\n        ais_point.SetAttributes(attr)\n        self._display.Context.Display(ais_point, False)\n        point_entities.append(ais_point)\n    return point_entities\n</code></pre>"},{"location":"api/#occwl.viewer.Viewer.display_text","title":"<code>display_text(xyz, text, height=None, color=None)</code>","text":"<p>Display a text</p> <p>Parameters:</p> Name Type Description Default <code>xyz</code> <code>tuple of floats or 1D np.ndarray of 2 or 3</code> <p>Coordinate in model space where text would appear</p> required <code>text</code> <code>str</code> <p>Text to display</p> required <code>height</code> <code>float</code> <p>Height of the text font. Defaults to None.</p> <code>None</code> <code>color</code> <code>tuple of 3 floats</code> <p>RGB color. Defaults to None.</p> <code>None</code> Source code in <code>src/occwl/viewer.py</code> <pre><code>def display_text(self, xyz, text, height=None, color=None):\n    \"\"\"\n    Display a text\n\n    Args:\n        xyz (tuple of floats or 1D np.ndarray of 2 or 3): Coordinate in model space where text would appear\n        text (str): Text to display\n        height (float, optional): Height of the text font. Defaults to None.\n        color (tuple of 3 floats, optional): RGB color. Defaults to None.\n    \"\"\"\n    return self._display.DisplayMessage(\n        geom_utils.to_gp_pnt(xyz), text, height=height, message_color=color\n    )\n</code></pre>"},{"location":"api/#occwl.viewer.Viewer.enable_antialiasing","title":"<code>enable_antialiasing()</code>","text":"<p>Enable antialiasing</p> Source code in <code>src/occwl/viewer.py</code> <pre><code>def enable_antialiasing(self):\n    \"\"\"\n    Enable antialiasing\n    \"\"\"\n    self._display.EnableAntiAliasing()\n</code></pre>"},{"location":"api/#occwl.viewer.Viewer.exit","title":"<code>exit()</code>","text":"<p>Exit the viewer</p> Source code in <code>src/occwl/viewer.py</code> <pre><code>def exit(self):\n    \"\"\"\n    Exit the viewer\n    \"\"\"\n    import sys\n\n    sys.exit()\n</code></pre>"},{"location":"api/#occwl.viewer.Viewer.fit","title":"<code>fit()</code>","text":"<p>Fit the camera to the scene</p> Source code in <code>src/occwl/viewer.py</code> <pre><code>def fit(self):\n    \"\"\"\n    Fit the camera to the scene\n    \"\"\"\n    self._display.FitAll()\n</code></pre>"},{"location":"api/#occwl.viewer.Viewer.hide_axes","title":"<code>hide_axes()</code>","text":"<p>Hide the XYZ-axes widget</p> Source code in <code>src/occwl/viewer.py</code> <pre><code>def hide_axes(self):\n    \"\"\"\n    Hide the XYZ-axes widget\n    \"\"\"\n    self._display.hide_triedron()\n</code></pre>"},{"location":"api/#occwl.viewer.Viewer.hide_face_boundary","title":"<code>hide_face_boundary()</code>","text":"<p>Hide the edges bounding each face</p> Source code in <code>src/occwl/viewer.py</code> <pre><code>def hide_face_boundary(self):\n    \"\"\"\n    Hide the edges bounding each face\n    \"\"\"\n    self._display.default_drawer.SetFaceBoundaryDraw(False)\n</code></pre>"},{"location":"api/#occwl.viewer.Viewer.on_select","title":"<code>on_select(callback)</code>","text":"<p>Callback to execute when a selection is made</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>function</code> <p>Called when a selection is made. Must have signature:                  def callback(selected_shapes, mouse_x, mouse_y)</p> required Source code in <code>src/occwl/viewer.py</code> <pre><code>def on_select(self, callback):\n    \"\"\"\n    Callback to execute when a selection is made\n\n    Args:\n        callback (function): Called when a selection is made. Must have signature:\n                             def callback(selected_shapes, mouse_x, mouse_y)\n    \"\"\"\n\n    def wrapped_callback(selected_shapes, x, y):\n        selected_shapes = self._convert_to_occwl_types(selected_shapes)\n        return callback(selected_shapes, x, y)\n\n    self._display.register_select_callback(wrapped_callback)\n</code></pre>"},{"location":"api/#occwl.viewer.Viewer.orthographic","title":"<code>orthographic()</code>","text":"<p>Set orthographic camera projection</p> Source code in <code>src/occwl/viewer.py</code> <pre><code>def orthographic(self):\n    \"\"\"\n    Set orthographic camera projection\n    \"\"\"\n    self._display.SetOrthographicProjection()\n    self._display.FitAll()\n</code></pre>"},{"location":"api/#occwl.viewer.Viewer.perspective","title":"<code>perspective()</code>","text":"<p>Set perspective camera projection</p> Source code in <code>src/occwl/viewer.py</code> <pre><code>def perspective(self):\n    \"\"\"\n    Set perspective camera projection\n    \"\"\"\n    self._display.SetPerspectiveProjection()\n    self._display.FitAll()\n</code></pre>"},{"location":"api/#occwl.viewer.Viewer.save_image","title":"<code>save_image(filename=None)</code>","text":"<p>Save a screenshot of the viewer</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str or Path</code> <p>Image file to save the screenshot. Defaults to None.                                       If None, writes a PNG file named with the current timestamp</p> <code>None</code> Source code in <code>src/occwl/viewer.py</code> <pre><code>def save_image(self, filename=None):\n    \"\"\"\n    Save a screenshot of the viewer\n\n    Args:\n        filename (str or pathlib.Path, optional): Image file to save the screenshot. Defaults to None.\n                                                  If None, writes a PNG file named with the current timestamp\n    \"\"\"\n    if filename is None:\n        now = datetime.now()\n        current_time = str(now)\n        filename = current_time + \".png\"\n    self._display.View.Dump(str(filename))\n</code></pre>"},{"location":"api/#occwl.viewer.Viewer.selected_shapes","title":"<code>selected_shapes()</code>","text":"<p>Get the selected shapes</p> <p>Returns:</p> Type Description <p>List[TopoDS_Shape]: List of selected shapes</p> Source code in <code>src/occwl/viewer.py</code> <pre><code>def selected_shapes(self):\n    \"\"\"\n    Get the selected shapes\n\n    Returns:\n        List[TopoDS_Shape]: List of selected shapes\n    \"\"\"\n    shapes = self._display.GetSelectedShapes()\n    shapes = self._convert_to_occwl_types(shapes)\n    return shapes\n</code></pre>"},{"location":"api/#occwl.viewer.Viewer.selection_mode_edge","title":"<code>selection_mode_edge()</code>","text":"<p>Allow edges to be selected</p> Source code in <code>src/occwl/viewer.py</code> <pre><code>def selection_mode_edge(self):\n    \"\"\"\n    Allow edges to be selected\n    \"\"\"\n    self._display.SetSelectionMode(TopAbs_EDGE)\n</code></pre>"},{"location":"api/#occwl.viewer.Viewer.selection_mode_face","title":"<code>selection_mode_face()</code>","text":"<p>Allow faces to be selected</p> Source code in <code>src/occwl/viewer.py</code> <pre><code>def selection_mode_face(self):\n    \"\"\"\n    Allow faces to be selected\n    \"\"\"\n    self._display.SetSelectionMode(TopAbs_FACE)\n</code></pre>"},{"location":"api/#occwl.viewer.Viewer.selection_mode_none","title":"<code>selection_mode_none()</code>","text":"<p>Allow no shapes to be selected</p> Source code in <code>src/occwl/viewer.py</code> <pre><code>def selection_mode_none(self):\n    \"\"\"\n    Allow no shapes to be selected\n    \"\"\"\n    self._display.SetSelectionModeShape()\n</code></pre>"},{"location":"api/#occwl.viewer.Viewer.selection_mode_shell","title":"<code>selection_mode_shell()</code>","text":"<p>Allow all shapes to be selected</p> Source code in <code>src/occwl/viewer.py</code> <pre><code>def selection_mode_shell(self):\n    \"\"\"\n    Allow all shapes to be selected\n    \"\"\"\n    self._display.SetSelectionMode(TopAbs_SHELL)\n</code></pre>"},{"location":"api/#occwl.viewer.Viewer.selection_mode_solid","title":"<code>selection_mode_solid()</code>","text":"<p>Allow no shapes to be selected</p> Source code in <code>src/occwl/viewer.py</code> <pre><code>def selection_mode_solid(self):\n    \"\"\"\n    Allow no shapes to be selected\n    \"\"\"\n    self._display.SetSelectionMode(TopAbs_SOLID)\n</code></pre>"},{"location":"api/#occwl.viewer.Viewer.selection_mode_vertex","title":"<code>selection_mode_vertex()</code>","text":"<p>Allow vertices to be selected</p> Source code in <code>src/occwl/viewer.py</code> <pre><code>def selection_mode_vertex(self):\n    \"\"\"\n    Allow vertices to be selected\n    \"\"\"\n    self._display.SetSelectionMode(TopAbs_VERTEX)\n</code></pre>"},{"location":"api/#occwl.viewer.Viewer.set_background_color","title":"<code>set_background_color(top_color, bottom_color)</code>","text":"<p>Set the background gradient color</p> <p>Parameters:</p> Name Type Description Default <code>top_color</code> <code>List / Tuple[int, int, int]</code> <p>Top color</p> required <code>bottom_color</code> <code>List / Tuple[int, int, int]</code> <p>Bottom color</p> required Source code in <code>src/occwl/viewer.py</code> <pre><code>def set_background_color(self, top_color, bottom_color):\n    \"\"\"\n    Set the background gradient color\n\n    Args:\n        top_color (List/Tuple[int, int, int]): Top color\n        bottom_color (List/Tuple[int, int, int]): Bottom color\n    \"\"\"\n    assert isinstance(top_color, (tuple, list))\n    assert isinstance(bottom_color, (tuple, list))\n    self._display.set_bg_gradient_color(top_color, bottom_color)\n</code></pre>"},{"location":"api/#occwl.viewer.Viewer.set_size","title":"<code>set_size(width, height)</code>","text":"<p>Set the size of the framebuffer</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>Width of the framebuffer</p> required <code>height</code> <code>int</code> <p>Height of the framebuffer</p> required Source code in <code>src/occwl/viewer.py</code> <pre><code>def set_size(self, width, height):\n    \"\"\"\n    Set the size of the framebuffer\n\n    Args:\n        width (int): Width of the framebuffer\n        height (int): Height of the framebuffer\n    \"\"\"\n    self._display.SetSize(width, height)\n</code></pre>"},{"location":"api/#occwl.viewer.Viewer.shaded","title":"<code>shaded()</code>","text":"<p>Shade all shapes</p> Source code in <code>src/occwl/viewer.py</code> <pre><code>def shaded(self):\n    \"\"\"\n    Shade all shapes\n    \"\"\"\n    self._display.View.SetComputedMode(False)\n    self._display.Context.SetDisplayMode(AIS_Shaded, True)\n</code></pre>"},{"location":"api/#occwl.viewer.Viewer.show","title":"<code>show()</code>","text":"<p>Show the viewer</p> Source code in <code>src/occwl/viewer.py</code> <pre><code>def show(self):\n    \"\"\"\n    Show the viewer\n    \"\"\"\n    self._start_display()\n</code></pre>"},{"location":"api/#occwl.viewer.Viewer.show_axes","title":"<code>show_axes()</code>","text":"<p>Show the XYZ-axes widget</p> Source code in <code>src/occwl/viewer.py</code> <pre><code>def show_axes(self):\n    \"\"\"\n    Show the XYZ-axes widget\n    \"\"\"\n    self._display.display_triedron()\n</code></pre>"},{"location":"api/#occwl.viewer.Viewer.show_face_boundary","title":"<code>show_face_boundary()</code>","text":"<p>Show the edges bounding each face</p> Source code in <code>src/occwl/viewer.py</code> <pre><code>def show_face_boundary(self):\n    \"\"\"\n    Show the edges bounding each face\n    \"\"\"\n    self._display.default_drawer.SetFaceBoundaryDraw(True)\n</code></pre>"},{"location":"api/#occwl.viewer.Viewer.use_flat_shading","title":"<code>use_flat_shading()</code>","text":"<p>Use no interpolation when computing color for fragments in a triangle</p> Source code in <code>src/occwl/viewer.py</code> <pre><code>def use_flat_shading(self):\n    \"\"\"\n    Use no interpolation when computing color for fragments in a triangle\n    \"\"\"\n    self._display.View.SetShadingModel(Graphic3d_TOSM_FACET)\n</code></pre>"},{"location":"api/#occwl.viewer.Viewer.use_gouraud_shading","title":"<code>use_gouraud_shading()</code>","text":"<p>Compute colors per vertex and interpolate</p> Source code in <code>src/occwl/viewer.py</code> <pre><code>def use_gouraud_shading(self):\n    \"\"\"\n    Compute colors per vertex and interpolate\n    \"\"\"\n    self._display.View.SetShadingModel(Graphic3d_TOSM_VERTEX)\n</code></pre>"},{"location":"api/#occwl.viewer.Viewer.use_phong_shading","title":"<code>use_phong_shading()</code>","text":"<p>Compute colors per fragment</p> Source code in <code>src/occwl/viewer.py</code> <pre><code>def use_phong_shading(self):\n    \"\"\"\n    Compute colors per fragment\n    \"\"\"\n    self._display.View.SetShadingModel(Graphic3d_TOSM_FRAGMENT)\n</code></pre>"},{"location":"api/#occwl.viewer.Viewer.use_rasterization","title":"<code>use_rasterization()</code>","text":"<p>Render using rasterization</p> Source code in <code>src/occwl/viewer.py</code> <pre><code>def use_rasterization(self):\n    \"\"\"\n    Render using rasterization\n    \"\"\"\n    self._display.SetRasterizationMode()\n</code></pre>"},{"location":"api/#occwl.viewer.Viewer.use_raytracing","title":"<code>use_raytracing(depth=3)</code>","text":"<p>Render using raytracing</p> <p>Parameters:</p> Name Type Description Default <code>depth</code> <code>int</code> <p>Number of bounces for rays Defaults to 3.</p> <code>3</code> Source code in <code>src/occwl/viewer.py</code> <pre><code>def use_raytracing(self, depth=3):\n    \"\"\"\n    Render using raytracing\n\n    Args:\n        depth (int, optional): Number of bounces for rays Defaults to 3.\n    \"\"\"\n    self._display.SetRaytracingMode(depth=depth)\n</code></pre>"},{"location":"api/#occwl.viewer.Viewer.wireframe","title":"<code>wireframe()</code>","text":"<p>Set all shapes to appear as wireframes</p> Source code in <code>src/occwl/viewer.py</code> <pre><code>def wireframe(self):\n    \"\"\"\n    Set all shapes to appear as wireframes\n    \"\"\"\n    self._display.View.SetComputedMode(False)\n    self._display.Context.SetDisplayMode(AIS_WireFrame, True)\n</code></pre>"},{"location":"api/#occwl.wire","title":"<code>wire</code>","text":""},{"location":"api/#occwl.wire.Wire","title":"<code>Wire</code>","text":"<p>               Bases: <code>Shape</code></p> <p>A topological wire in a solid model Represents a closed loop of edges</p> Source code in <code>src/occwl/wire.py</code> <pre><code>class Wire(Shape):\n    \"\"\"\n    A topological wire in a solid model\n    Represents a closed loop of edges\n    \"\"\"\n\n    def __init__(self, topods_wire):\n        \"\"\"\n        Construct a Wire\n\n        Args:\n            topods_wire (OCC.Core.TopoDS_Wire): OCC wire type\n        \"\"\"\n        assert isinstance(topods_wire, TopoDS_Wire)\n        super().__init__(topods_wire)\n        self._wire_exp = TopologyUtils.WireExplorer(self.topods_shape())\n\n    @staticmethod\n    def make_from_edges(edges):\n        \"\"\"\n        Make a wire from connected edges\n\n        Args:\n            edges (List[occwl.edge.Edge]): List of edges\n\n        Returns:\n            occwl.wire.Wire or None: Returns a Wire or None if the operation failed\n        \"\"\"\n        wire_builder = BRepBuilderAPI_MakeWire()\n        for edge in edges:\n            wire_builder.Add(edge.topods_shape())\n        wire_builder.Build()\n        if not wire_builder.IsDone():\n            return None\n        return Wire(wire_builder.Wire())\n\n    def ordered_edges(self):\n        \"\"\"\n        Get an iterator to go over the edges while respecting the wire ordering\n\n        Returns:\n            Iterator[occwl.edge.Edge]: An iterator to edges\n        \"\"\"\n        return map(Edge, self._wire_exp.ordered_edges())\n\n    def ordered_vertices(self):\n        \"\"\"\n        Get an iterator to go over the vertices while respecting the wire ordering\n\n        Returns:\n            Iterator[occwl.vertex.Vertex]: An iterator to vertices\n        \"\"\"\n        return map(Vertex, self._wire_exp.ordered_vertices())\n</code></pre>"},{"location":"api/#occwl.wire.Wire.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Equality check for the shape</p> <p>NOTE: This function only checks if the shape is the same. It doesn't check the edge orienation for example, so </p> <p>edge1 == edge2</p> <p>does not necessarily mean </p> <p>edge1.reversed() == edge2.reversed()</p> Source code in <code>src/occwl/shape.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"\n    Equality check for the shape\n\n    NOTE: This function only checks if the shape is the same.\n    It doesn't check the edge orienation for example, so \n\n    edge1 == edge2\n\n    does not necessarily mean \n\n    edge1.reversed() == edge2.reversed()\n    \"\"\"\n    return self.topods_shape().__hash__() == other.topods_shape().__hash__()\n</code></pre>"},{"location":"api/#occwl.wire.Wire.__hash__","title":"<code>__hash__()</code>","text":"<p>Hash for the shape</p> <p>Returns:</p> Name Type Description <code>int</code> <p>Hash value</p> Source code in <code>src/occwl/shape.py</code> <pre><code>def __hash__(self):\n    \"\"\"\n    Hash for the shape\n\n    Returns:\n        int: Hash value\n    \"\"\"\n    return self.topods_shape().__hash__()\n</code></pre>"},{"location":"api/#occwl.wire.Wire.__init__","title":"<code>__init__(topods_wire)</code>","text":"<p>Construct a Wire</p> <p>Parameters:</p> Name Type Description Default <code>topods_wire</code> <code>TopoDS_Wire</code> <p>OCC wire type</p> required Source code in <code>src/occwl/wire.py</code> <pre><code>def __init__(self, topods_wire):\n    \"\"\"\n    Construct a Wire\n\n    Args:\n        topods_wire (OCC.Core.TopoDS_Wire): OCC wire type\n    \"\"\"\n    assert isinstance(topods_wire, TopoDS_Wire)\n    super().__init__(topods_wire)\n    self._wire_exp = TopologyUtils.WireExplorer(self.topods_shape())\n</code></pre>"},{"location":"api/#occwl.wire.Wire.convert_geometric_identity_transforms_to_identity","title":"<code>convert_geometric_identity_transforms_to_identity()</code>","text":"<p>Open Cascade models sometimes contain transforms which are \"geometrically\" identify transforms, but the identity flag is not set.</p> <p>This function checks each transform and sets the flag if  the appropriate.</p> Source code in <code>src/occwl/shape.py</code> <pre><code>def convert_geometric_identity_transforms_to_identity(self):\n    \"\"\"\n    Open Cascade models sometimes contain transforms which\n    are \"geometrically\" identify transforms, but the identity\n    flag is not set.\n\n    This function checks each transform and sets the flag if \n    the appropriate.\n    \"\"\"\n    identity = TopLoc_Location()\n    if geom_utils.is_geometric_identity(\n        self.topods_shape().Location().Transformation()\n    ):\n        self.topods_shape().Location(identity)\n        self._top_exp = TopologyUtils.TopologyExplorer(self.topods_shape(), True)\n\n    for face in self._top_exp.faces():\n        if geom_utils.is_geometric_identity(face.Location().Transformation()):\n            face.Location(identity)\n\n    for edge in self._top_exp.edges():\n        if geom_utils.is_geometric_identity(edge.Location().Transformation()):\n            edge.Location(identity)\n\n    for vertex in self._top_exp.vertices():\n        if geom_utils.is_geometric_identity(vertex.Location().Transformation()):\n            vertex.Location(identity)\n</code></pre>"},{"location":"api/#occwl.wire.Wire.find_closest_point_data","title":"<code>find_closest_point_data(datum)</code>","text":"<p>Find the information about the closest point on this shape</p> <p>Parameters:</p> Name Type Description Default <code>datum</code> <code>ndarray</code> <p>3D Point</p> required <p>Returns:</p> Name Type Description <code>ClosestPointData</code> <p>Data about the closest point on this shape</p> <code>None</code> <p>if error</p> Source code in <code>src/occwl/shape.py</code> <pre><code>def find_closest_point_data(self, datum):\n    \"\"\"\n    Find the information about the closest point on this shape\n\n    Args:\n        datum (np.ndarray): 3D Point\n\n    Returns:\n        ClosestPointData: Data about the closest point on this shape\n        None: if error\n    \"\"\"\n    # Folowing https://dev.opencascade.org/content/how-retrieve-nearest-face-shape-given-gppnt\n    # Create a vertex from the point\n    occ_point = geom_utils.numpy_to_gp(datum)\n    vertex_maker = BRepBuilderAPI_MakeVertex(occ_point)\n    vertex = vertex_maker.Shape()\n    dist_shape_shape = BRepExtrema_DistShapeShape(\n        vertex, self.topods_shape(), Extrema_ExtFlag_MIN\n    )\n    ok = dist_shape_shape.Perform()\n    if not ok:\n        return None\n\n    return ClosestPointData(dist_shape_shape)\n</code></pre>"},{"location":"api/#occwl.wire.Wire.make_from_edges","title":"<code>make_from_edges(edges)</code>  <code>staticmethod</code>","text":"<p>Make a wire from connected edges</p> <p>Parameters:</p> Name Type Description Default <code>edges</code> <code>List[Edge]</code> <p>List of edges</p> required <p>Returns:</p> Type Description <p>occwl.wire.Wire or None: Returns a Wire or None if the operation failed</p> Source code in <code>src/occwl/wire.py</code> <pre><code>@staticmethod\ndef make_from_edges(edges):\n    \"\"\"\n    Make a wire from connected edges\n\n    Args:\n        edges (List[occwl.edge.Edge]): List of edges\n\n    Returns:\n        occwl.wire.Wire or None: Returns a Wire or None if the operation failed\n    \"\"\"\n    wire_builder = BRepBuilderAPI_MakeWire()\n    for edge in edges:\n        wire_builder.Add(edge.topods_shape())\n    wire_builder.Build()\n    if not wire_builder.IsDone():\n        return None\n    return Wire(wire_builder.Wire())\n</code></pre>"},{"location":"api/#occwl.wire.Wire.occwl_shape","title":"<code>occwl_shape(topods_shape)</code>  <code>staticmethod</code>","text":"<p>Static method to create an occwl shape of the appropriate  class from the given topods_shape Args:     topods_shape (OCC.Core.TopoDS.TopoDS_Vertex/Edge/Face/Wire/Shell/Solid): TopoDS shape</p> <p>Returns:</p> Type Description <p>One of occwl.compound.Compound occwl.solid.Solid occwl.face.Face occwl.edge.Edge occwl.vertex.Vertex occwl.wire.Wire occwl.shell.Shell</p> <p>Raises:     Exception: [description]</p> Source code in <code>src/occwl/shape.py</code> <pre><code>@staticmethod\ndef occwl_shape(topods_shape):\n    \"\"\"\n    Static method to create an occwl shape of the appropriate \n    class from the given topods_shape\n    Args:\n        topods_shape (OCC.Core.TopoDS.TopoDS_Vertex/Edge/Face/Wire/Shell/Solid): TopoDS shape\n\n    Returns:\n        One of\n            occwl.compound.Compound\n            occwl.solid.Solid\n            occwl.face.Face\n            occwl.edge.Edge\n            occwl.vertex.Vertex\n            occwl.wire.Wire\n            occwl.shell.Shell\n    Raises:\n        Exception: [description]\n    \"\"\"\n    from occwl.compound import Compound\n    from occwl.solid import Solid\n    from occwl.face import Face\n    from occwl.edge import Edge\n    from occwl.vertex import Vertex\n    from occwl.wire import Wire\n    from occwl.shell import Shell\n\n    if isinstance(topods_shape, TopoDS_Vertex):\n        return Vertex(topods_shape)\n    if isinstance(topods_shape, TopoDS_Edge):\n        return Edge(topods_shape)\n    if isinstance(topods_shape, TopoDS_Face):\n        return Face(topods_shape)\n    if isinstance(topods_shape, TopoDS_Wire):\n        return Wire(topods_shape)\n    if isinstance(topods_shape, TopoDS_Shell):\n        return Shell(topods_shape)\n    if isinstance(topods_shape, TopoDS_Solid):\n        return Solid(topods_shape)\n    if isinstance(topods_shape, (TopoDS_Compound, TopoDS_CompSolid)):\n        return Compound(topods_shape)\n    raise Exception(\n        \"Shape must be one of TopoDS_Vertex, TopoDS_Edge, TopoDS_Face, TopoDS_Shell, TopoDS_Solid, TopoDS_Compound, TopoDS_CompSolid\"\n    )\n</code></pre>"},{"location":"api/#occwl.wire.Wire.ordered_edges","title":"<code>ordered_edges()</code>","text":"<p>Get an iterator to go over the edges while respecting the wire ordering</p> <p>Returns:</p> Type Description <p>Iterator[occwl.edge.Edge]: An iterator to edges</p> Source code in <code>src/occwl/wire.py</code> <pre><code>def ordered_edges(self):\n    \"\"\"\n    Get an iterator to go over the edges while respecting the wire ordering\n\n    Returns:\n        Iterator[occwl.edge.Edge]: An iterator to edges\n    \"\"\"\n    return map(Edge, self._wire_exp.ordered_edges())\n</code></pre>"},{"location":"api/#occwl.wire.Wire.ordered_vertices","title":"<code>ordered_vertices()</code>","text":"<p>Get an iterator to go over the vertices while respecting the wire ordering</p> <p>Returns:</p> Type Description <p>Iterator[occwl.vertex.Vertex]: An iterator to vertices</p> Source code in <code>src/occwl/wire.py</code> <pre><code>def ordered_vertices(self):\n    \"\"\"\n    Get an iterator to go over the vertices while respecting the wire ordering\n\n    Returns:\n        Iterator[occwl.vertex.Vertex]: An iterator to vertices\n    \"\"\"\n    return map(Vertex, self._wire_exp.ordered_vertices())\n</code></pre>"},{"location":"api/#occwl.wire.Wire.reversed","title":"<code>reversed()</code>","text":"<p>Whether this shape is reversed.</p> <ul> <li>For an edge this is whether the edge is reversed with respect to the curve geometry</li> <li>For a face this is whether the face is reversed with respect to the surface geometry</li> <li>For a vertex this is whether the vertex is at the upper or lower parameter value on the   edges curve</li> </ul> <p>Returns:</p> Name Type Description <code>bool</code> <p>If rational</p> Source code in <code>src/occwl/shape.py</code> <pre><code>def reversed(self):\n    \"\"\"\n    Whether this shape is reversed.\n\n    - For an edge this is whether the edge is reversed with respect to the curve geometry\n    - For a face this is whether the face is reversed with respect to the surface geometry\n    - For a vertex this is whether the vertex is at the upper or lower parameter value on the\n      edges curve\n\n    Returns:\n        bool: If rational\n    \"\"\"\n    return self.topods_shape().Orientation() == TopAbs_REVERSED\n</code></pre>"},{"location":"api/#occwl.wire.Wire.rotate_axis_angle","title":"<code>rotate_axis_angle(axis, angle_radians, origin=np.zeros(3, dtype=(np.float32)))</code>","text":"<p>Rotate the shape about the given axis by the given angle in radians</p> <p>Parameters:</p> Name Type Description Default <code>axis</code> <code>ndarray</code> <p>Rotation axis</p> required <code>angle_radians</code> <code>float</code> <p>Angle in radians</p> required Source code in <code>src/occwl/shape.py</code> <pre><code>def rotate_axis_angle(\n    self, axis, angle_radians, origin=np.zeros(3, dtype=np.float32)\n):\n    \"\"\"\n    Rotate the shape about the given axis by the given angle in radians\n\n    Args:\n        axis (np.ndarray): Rotation axis\n        angle_radians (float): Angle in radians\n    \"\"\"\n    self._shape = rotate_shape(\n        self._shape,\n        gp_Ax1(geom_utils.numpy_to_gp(origin), geom_utils.numpy_to_gp_dir(axis)),\n        angle_radians,\n        unite=\"rad\",\n    )\n</code></pre>"},{"location":"api/#occwl.wire.Wire.rotate_euler_angles","title":"<code>rotate_euler_angles(angles_xyz_radians)</code>","text":"<p>Rotate the shape by the given Euler angles in radians</p> <p>Parameters:</p> Name Type Description Default <code>angle_xyz_radians</code> <code>ndarray</code> <p>3D array with angles to rotate about x-axis, y-axis and z-axis respectively in radians</p> required Source code in <code>src/occwl/shape.py</code> <pre><code>def rotate_euler_angles(self, angles_xyz_radians):\n    \"\"\"\n    Rotate the shape by the given Euler angles in radians\n\n    Args:\n        angle_xyz_radians (np.ndarray): 3D array with angles to rotate about x-axis, y-axis and z-axis respectively in radians\n    \"\"\"\n    self._shape = rotate_shp_3_axis(\n        self._shape,\n        angles_xyz_radians[0],\n        angles_xyz_radians[1],\n        angles_xyz_radians[2],\n        unity=\"rad\",\n    )\n</code></pre>"},{"location":"api/#occwl.wire.Wire.save_shapes_to_occ_native","title":"<code>save_shapes_to_occ_native(filename, shapes, with_triangles=False, with_normals=False, format_version=None)</code>  <code>staticmethod</code>","text":"<p>Save this shape into a native OCC binary .brep file.</p> Saving to and loading from the native file format <p>is between one and two orders of magnitude faster  than loading from STEP, so it is recommended for  large scale data processing</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str or Path</code> <p>.brep filename</p> required <code>with_triangles</code> <code>bool</code> <p>Whether to save triangle data cached in the shape.</p> <code>False</code> <code>with_normals</code> <code>bool</code> <p>Whether to save vertex normals cached in the shape</p> <code>False</code> <code>format_version</code> <code>int</code> <p>Use None to save to the latest version 1 - first revision 2 - added storing of CurveOnSurface UV Points 3 - [OCCT 7.6] added storing of per-vertex normal information                and dropped storing of CurveOnSurface UV Points</p> <code>None</code> Source code in <code>src/occwl/shape.py</code> <pre><code>@staticmethod\ndef save_shapes_to_occ_native(\n        filename, \n        shapes,\n        with_triangles=False,\n        with_normals=False,\n        format_version=None\n    ):\n    \"\"\"\n    Save this shape into a native OCC binary .brep file.\n\n    Note:  Saving to and loading from the native file format \n            is between one and two orders of magnitude faster \n            than loading from STEP, so it is recommended for \n            large scale data processing\n\n    Args:\n        filename (str or pathlib.Path): .brep filename\n\n        with_triangles (bool): Whether to save triangle data cached in the shape.\n        with_normals (bool): Whether to save vertex normals cached in the shape\n        format_version (int):  Use None to save to the latest version\n            1 - first revision\n            2 - added storing of CurveOnSurface UV Points\n            3 - [OCCT 7.6] added storing of per-vertex normal information\n                           and dropped storing of CurveOnSurface UV Points\n    \"\"\"\n    new_api = False\n    shapes_set = BRepTools_ShapeSet(with_triangles)\n    # shapes_set.SetWithNormals(with_normals) # Not in OCC 7.5.0\n\n    for shp in shapes:\n        shapes_set.Add(shp.topods_shape())\n    if format_version is not None:\n        shapes_set.SetFormatNb(format_version)\n\n\n    with open(filename, \"w\") as fp:\n        s = shapes_set.WriteToString()\n        fp.write(s)\n</code></pre>"},{"location":"api/#occwl.wire.Wire.save_to_occ_native","title":"<code>save_to_occ_native(filename, verbosity=False, with_triangles=False, with_normals=False, format_version=None)</code>","text":"<p>Save this shape into a native OCC binary .brep file.</p> Saving to and loading from the native file format <p>is between one and two orders of magnitude faster  than loading from STEP, so it is recommended for  large scale data processing</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str or Path</code> <p>.brep filename</p> required <code>with_triangles</code> <code>bool</code> <p>Whether to save triangle data cached in the shape.</p> <code>False</code> <code>with_normals</code> <code>bool</code> <p>Whether to save vertex normals cached in the shape</p> <code>False</code> <code>format_version</code> <code>int</code> <p>Use None to save to the latest version 1 - first revision 2 - added storing of CurveOnSurface UV Points 3 - [OCCT 7.6] added storing of per-vertex normal information                and dropped storing of CurveOnSurface UV Points</p> <code>None</code> Source code in <code>src/occwl/shape.py</code> <pre><code>def save_to_occ_native(\n        self, \n        filename, \n        verbosity=False,\n        with_triangles=False,\n        with_normals=False,\n        format_version=None\n    ):\n    \"\"\"\n    Save this shape into a native OCC binary .brep file.\n\n    Note:  Saving to and loading from the native file format \n           is between one and two orders of magnitude faster \n           than loading from STEP, so it is recommended for \n           large scale data processing\n\n    Args:\n        filename (str or pathlib.Path): .brep filename\n        with_triangles (bool): Whether to save triangle data cached in the shape.\n        with_normals (bool): Whether to save vertex normals cached in the shape\n        format_version (int):  Use None to save to the latest version\n            1 - first revision\n            2 - added storing of CurveOnSurface UV Points\n            3 - [OCCT 7.6] added storing of per-vertex normal information\n                           and dropped storing of CurveOnSurface UV Points\n    \"\"\"\n    self.save_shapes_to_occ_native(\n        filename, \n        [ self ],\n        with_triangles=with_triangles,\n        with_normals=with_normals,\n        format_version=format_version\n    )\n</code></pre>"},{"location":"api/#occwl.wire.Wire.scale","title":"<code>scale(scale_vector)</code>","text":"<p>Scale the shape by the given 3D vector</p> <p>Parameters:</p> Name Type Description Default <code>scale_vector</code> <code>ndarray</code> <p>3D array with scales to resize the shape along the x-axis, y-axis and z-axis respectively</p> required Source code in <code>src/occwl/shape.py</code> <pre><code>def scale(self, scale_vector):\n    \"\"\"\n    Scale the shape by the given 3D vector\n\n    Args:\n        scale_vector (np.ndarray): 3D array with scales to resize the shape along the x-axis, y-axis and z-axis respectively\n    \"\"\"\n    self._shape = scale_shape(\n        self._shape, scale_vector[0], scale_vector[1], scale_vector[2]\n    )\n</code></pre>"},{"location":"api/#occwl.wire.Wire.set_transform_to_identity","title":"<code>set_transform_to_identity()</code>","text":"<p>When an assembly is loaded from a STEP file the solids will be transformed relative to their local coordinate system.   i.e. they are placed in the assembly root components  coordinate system.</p> <p>When working with individual bodies you often want them to be axis aligned, in which case  you want to remove the assembly transform. This function removes it for you.</p> <p>If however you want to bake the transform into the bodies and suppress the asserts  from parts of occwl which don't cope with transforms then use the transform() function below with copy=True</p> Source code in <code>src/occwl/shape.py</code> <pre><code>def set_transform_to_identity(self):\n    \"\"\"\n    When an assembly is loaded from a STEP file\n    the solids will be transformed relative to\n    their local coordinate system.   i.e. they\n    are placed in the assembly root components \n    coordinate system.\n\n    When working with individual bodies you often\n    want them to be axis aligned, in which case \n    you want to remove the assembly transform.\n    This function removes it for you.\n\n    If however you want to bake the transform\n    into the bodies and suppress the asserts \n    from parts of occwl which don't cope with\n    transforms then use the transform() function\n    below with copy=True\n    \"\"\"\n    identity = TopLoc_Location()\n    self.topods_shape().Location(identity)\n    self._top_exp = TopologyUtils.TopologyExplorer(self.topods_shape(), True)\n    self.convert_geometric_identity_transforms_to_identity()\n</code></pre>"},{"location":"api/#occwl.wire.Wire.topods_shape","title":"<code>topods_shape()</code>","text":"<p>Get the underlying OCC shape</p> <p>Returns:</p> Type Description <p>OCC.Core.TopoDS.TopoDS_Vertex/Edge/Face/Wire/Shell/Solid: OCC TopoDS_*</p> Source code in <code>src/occwl/shape.py</code> <pre><code>def topods_shape(self):\n    \"\"\"\n    Get the underlying OCC shape\n\n    Returns:\n        OCC.Core.TopoDS.TopoDS_Vertex/Edge/Face/Wire/Shell/Solid: OCC TopoDS_*\n    \"\"\"\n    return self._shape\n</code></pre>"},{"location":"api/#occwl.wire.Wire.transform","title":"<code>transform(a, copy=True)</code>","text":"<p>Apply the given 3x4 transform matrix to the solid.</p> <pre><code> copy (bool)    True - Copy entities and apply the transform to\n                       the underlying geometry\n                False - Apply the transform to the topods Locator\n                        if possible\n</code></pre> Source code in <code>src/occwl/shape.py</code> <pre><code>def transform(self, a: np.ndarray, copy=True):\n    \"\"\"\n    Apply the given 3x4 transform matrix to the solid.\n\n    Args: a (nd.array) - Homogeneous transform matrix\n                         The transform that will be applied is\n\n                         x' =  a[0,0]*x + a[0,1]*y + a[0,2]*z + a[0, 3]\n                         y' =  a[1,0]*x + a[1,1]*y + a[1,2]*z + a[1, 3]\n                         z' =  a[2,0]*x + a[2,1]*y + a[2,2]*z + a[2, 3]\n\n         copy (bool)    True - Copy entities and apply the transform to\n                               the underlying geometry\n                        False - Apply the transform to the topods Locator\n                                if possible \n    \"\"\"\n    assert (a.shape == (3, 4)), \"Transform matrix must be 3x4\"\n    a = a.astype(np.float64)\n\n    # Create an identity transform\n    trsf = gp_Trsf()\n\n    # If the matrix is an identity matrix then\n    # we don't want to set the values as this\n    # would give us a geometric identity without\n    # the identity flag set\n    if not np.allclose(a, np.eye(3, 4)):\n        trsf.SetValues(\n            a[0,0], a[0,1], a[0,2], a[0, 3],\n            a[1,0], a[1,1], a[1,2], a[1, 3],\n            a[2,0], a[2,1], a[2,2], a[2, 3]\n        )\n    return self._apply_transform(trsf, copy=copy)\n</code></pre>"},{"location":"api/#occwl.wire.Wire.translate","title":"<code>translate(offset)</code>","text":"<p>Translate the shape by an offset vector</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>ndarray</code> <p>Offset vector</p> required Source code in <code>src/occwl/shape.py</code> <pre><code>def translate(self, offset):\n    \"\"\"\n    Translate the shape by an offset vector\n\n    Args:\n        offset (np.ndarray): Offset vector\n    \"\"\"\n    self._shape = translate_shp(self._shape, geom_utils.numpy_to_gp_vec(offset))\n</code></pre>"},{"location":"api/#occwl.wire.Wire.valid","title":"<code>valid(return_analyzer=False)</code>","text":"<p>Check if the shape is valid</p> <p>Parameters:</p> Name Type Description Default <code>return_analyzer</code> <code>bool</code> <p>Whether to return the BRepCheck_Analyzer object for more inspection</p> <code>False</code> <p>Returns:</p> Name Type Description <code>bool</code> <p>Whether the shape is valid</p> <p>BRepCheck_Analyzer [optional]: if return_analyzer is True</p> Source code in <code>src/occwl/shape.py</code> <pre><code>def valid(self, return_analyzer=False):\n    \"\"\"\n    Check if the shape is valid\n\n    Args:\n        return_analyzer (bool): Whether to return the BRepCheck_Analyzer object for more inspection\n\n    Returns:\n        bool: Whether the shape is valid\n        BRepCheck_Analyzer [optional]: if return_analyzer is True\n    \"\"\"\n    analyzer = BRepCheck_Analyzer(self.topods_shape())\n    if return_analyzer:\n        return analyzer.IsValid(), analyzer\n    return analyzer.IsValid()\n</code></pre>"},{"location":"occwl_developers_guide/","title":"OCCWL developers and maintainers guide","text":""},{"location":"occwl_developers_guide/#installing-locally","title":"Installing locally","text":"<ul> <li>Clone OCCWL into a local directory</li> <li>CD into the cloned repository: <code>cd /path/to/occwl</code></li> <li>Create an environment</li> </ul> <pre><code>conda env create -f environment.yml\nconda activate occwl_dev\n</code></pre> <p>Then you can either use setuptools to install occwl locally</p> <pre><code>pip install .\n</code></pre> <p>or you can add the full path to the <code>src/occwl</code> folder to the <code>PYTHONPATH</code> environment variable:</p> <ul> <li>Linux:</li> </ul> <pre><code> export PYTHONPATH=$PYTHONPATH:/path/to/occwl/src/\n</code></pre> <ul> <li>Windows:</li> </ul> <pre><code>set PYTHONPATH=%PYTHONPATH%;path\\to\\occwl\\src\n</code></pre> <p>To check everything is working run </p> <pre><code>python -m unittest\n</code></pre>"},{"location":"occwl_developers_guide/#running-the-tests","title":"Running the tests","text":"<p>To run the occwl tests use the following command</p> <pre><code>python -m unittest tests\n</code></pre>"},{"location":"occwl_developers_guide/#build-conda-package-from-source-and-upload-to-anaconda","title":"Build Conda Package from Source and Upload to Anaconda","text":"<ul> <li> <p>Build and test package locally:</p> <ol> <li> <p>Set the package version by modifying version parameters in <code>ci/conda/meta.yaml</code> and <code>setup.py</code> files.</p> </li> <li> <p>Build and test package: <code>sh build_conda_package.sh</code></p> </li> </ol> </li> <li> <p>Upload the new local package to Anaconda:</p> <ol> <li> <p>Create an Anaconda account at https://anaconda.org/</p> </li> <li> <p>Login to Anaconda:     <code>anaconda login</code></p> </li> <li> <p>Upload package to Anaconda channel:     <code>anaconda upload /Users/&lt;user_name&gt;/miniconda/conda-bld/noarch/occwl-&lt;version&gt;-py_0.tar.bz2</code></p> </li> </ol> </li> <li> <p>Build and test package and upload to Anaconda:</p> <ol> <li> <p>Create an Anaconda account at https://anaconda.org/</p> </li> <li> <p>Set the package version by modifying version parameters in <code>ci/conda/meta.yaml</code> and <code>setup.py</code></p> </li> <li> <p>Build and test package and upload to Anaconda: <code>sh build_conda_package.sh &lt;anaconda_username&gt;</code></p> </li> </ol> </li> </ul>"},{"location":"occwl_developers_guide/#install-conda-package","title":"Install Conda Package","text":"<ul> <li> <p>Install conda package from local channel     <code>conda install --use-local occwl</code>     or     <code>conda install -c file:///Users/&lt;user_name&gt;/miniconda/envs/&lt;env_name&gt;/conda-bld/ occwl</code></p> </li> <li> <p>Install conda Package from Anaconda</p> <p><code>conda install -c &lt;anaconda_username&gt; -c conda-forge occwl</code> Note that packages in Anaconda account are public by default and can be installed by other usesr without login to Anaconda.</p> </li> </ul> <p>Note the following dependencies will also be automatically installed:  - pythonocc-core  - pyqt  - pyside2  - wxpython  - numpy  - networkx  - pyDeprecate</p> <p>However, in Linux platform, pyqt requires an additional system dependency, <code>libgl1-mesa-glx</code>, which needs to be installed as follows:</p> <pre><code>sudo apt update\nsudo apt install libgl1-mesa-glx\n</code></pre>"}]}